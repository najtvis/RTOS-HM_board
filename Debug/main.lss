
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000084f6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000013a  00802000  000084f6  0000858a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00001cb4  0080213a  0080213a  000086c4  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000086c4  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00001270  00000000  00000000  00008720  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0001fada  00000000  00000000  00009990  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000718d  00000000  00000000  0002946a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000d29b  00000000  00000000  000305f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00003de0  00000000  00000000  0003d894  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00007785  00000000  00000000  00041674  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000135d5  00000000  00000000  00048df9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000fd8  00000000  00000000  0005c3d0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 c9 09 	jmp	0x1392	; 0x1392 <__ctors_end>
       4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
       8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
       c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      10:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      14:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      18:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      1c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      20:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      24:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      28:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      2c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      30:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      34:	0c 94 3d 30 	jmp	0x607a	; 0x607a <__vector_13>
      38:	0c 94 70 0f 	jmp	0x1ee0	; 0x1ee0 <__vector_14>
      3c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      40:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      44:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      48:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      4c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      50:	0c 94 03 38 	jmp	0x7006	; 0x7006 <__vector_20>
      54:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      58:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      5c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      60:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      64:	0c 94 f9 32 	jmp	0x65f2	; 0x65f2 <__vector_25>
      68:	0c 94 01 34 	jmp	0x6802	; 0x6802 <__vector_26>
      6c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      70:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      74:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      78:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      7c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      80:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      84:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      88:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      8c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      90:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      94:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      98:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      9c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      a0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      a4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      a8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      ac:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      b0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      b4:	0c 94 6a 0b 	jmp	0x16d4	; 0x16d4 <__vector_45>
      b8:	0c 94 35 0b 	jmp	0x166a	; 0x166a <__vector_46>
      bc:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      c0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      c4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      c8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      cc:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      d0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      d4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      d8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      dc:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      e0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      e4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      e8:	0c 94 a9 33 	jmp	0x6752	; 0x6752 <__vector_58>
      ec:	0c 94 c7 34 	jmp	0x698e	; 0x698e <__vector_59>
      f0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      f4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      f8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
      fc:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     100:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     104:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     108:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     10c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     110:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     114:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     118:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     11c:	0c 94 c8 36 	jmp	0x6d90	; 0x6d90 <__vector_71>
     120:	0c 94 05 37 	jmp	0x6e0a	; 0x6e0a <__vector_72>
     124:	0c 94 42 37 	jmp	0x6e84	; 0x6e84 <__vector_73>
     128:	0c 94 7f 37 	jmp	0x6efe	; 0x6efe <__vector_74>
     12c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     130:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     134:	0c 94 2a 39 	jmp	0x7254	; 0x7254 <__vector_77>
     138:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     13c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     140:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     144:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     148:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     14c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     150:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     154:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     158:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     15c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     160:	0c 94 51 33 	jmp	0x66a2	; 0x66a2 <__vector_88>
     164:	0c 94 64 34 	jmp	0x68c8	; 0x68c8 <__vector_89>
     168:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     16c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     170:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     174:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     178:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     17c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     180:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     184:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     188:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     18c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     190:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     194:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     198:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     19c:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1a0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1a4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1a8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1ac:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1b0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1b4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1b8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1bc:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1c0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1c4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1c8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1cc:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1d0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1d4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1d8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1dc:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1e0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1e4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1e8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1ec:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1f0:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1f4:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1f8:	0c 94 ef 09 	jmp	0x13de	; 0x13de <__bad_interrupt>
     1fc:	37 0a       	sbc	r3, r23
     1fe:	46 0a       	sbc	r4, r22
     200:	55 0a       	sbc	r5, r21
     202:	64 0a       	sbc	r6, r20
     204:	73 0a       	sbc	r7, r19
     206:	82 0a       	sbc	r8, r18
     208:	91 0a       	sbc	r9, r17
     20a:	a0 0a       	sbc	r10, r16
     20c:	f0 1c       	adc	r15, r0
     20e:	f0 1c       	adc	r15, r0
     210:	f0 1c       	adc	r15, r0
     212:	28 1d       	adc	r18, r8
     214:	17 1d       	adc	r17, r7
     216:	25 1d       	adc	r18, r5
     218:	f0 1c       	adc	r15, r0
     21a:	f0 1c       	adc	r15, r0
     21c:	28 1d       	adc	r18, r8
     21e:	17 1d       	adc	r17, r7
     220:	3a 29       	or	r19, r10
     222:	c9 29       	or	r28, r9
     224:	44 29       	or	r20, r4
     226:	88 29       	or	r24, r8
     228:	94 29       	or	r25, r4
     22a:	a8 29       	or	r26, r8
     22c:	b9 29       	or	r27, r9
     22e:	08 00       	.word	0x0008	; ????
     230:	00 00       	nop
     232:	be 92       	st	-X, r11
     234:	24 49       	sbci	r18, 0x94	; 148
     236:	12 3e       	cpi	r17, 0xE2	; 226
     238:	ab aa       	std	Y+51, r10	; 0x33
     23a:	aa 2a       	or	r10, r26
     23c:	be cd       	rjmp	.-1156   	; 0xfffffdba <__eeprom_end+0xff7efdba>
     23e:	cc cc       	rjmp	.-1640   	; 0xfffffbd8 <__eeprom_end+0xff7efbd8>
     240:	4c 3e       	cpi	r20, 0xEC	; 236
     242:	00 00       	nop
     244:	00 80       	ld	r0, Z
     246:	be ab       	std	Y+54, r27	; 0x36
     248:	aa aa       	std	Y+50, r10	; 0x32
     24a:	aa 3e       	cpi	r26, 0xEA	; 234
     24c:	00 00       	nop
     24e:	00 00       	nop
     250:	bf 00       	.word	0x00bf	; ????
     252:	00 00       	nop
     254:	80 3f       	cpi	r24, 0xF0	; 240
     256:	00 00       	nop
     258:	00 00       	nop
     25a:	00 08       	sbc	r0, r0
     25c:	41 78       	andi	r20, 0x81	; 129
     25e:	d3 bb       	out	0x13, r29	; 19
     260:	43 87       	std	Z+11, r20	; 0x0b
     262:	d1 13       	cpse	r29, r17
     264:	3d 19       	sub	r19, r13
     266:	0e 3c       	cpi	r16, 0xCE	; 206
     268:	c3 bd       	out	0x23, r28	; 35
     26a:	42 82       	std	Z+2, r4	; 0x02
     26c:	ad 2b       	or	r26, r29
     26e:	3e 68       	ori	r19, 0x8E	; 142
     270:	ec 82       	std	Y+4, r14	; 0x04
     272:	76 be       	out	0x36, r7	; 54
     274:	d9 8f       	std	Y+25, r29	; 0x19
     276:	e1 a9       	ldd	r30, Z+49	; 0x31
     278:	3e 4c       	sbci	r19, 0xCE	; 206
     27a:	80 ef       	ldi	r24, 0xF0	; 240
     27c:	ff be       	out	0x3f, r15	; 63
     27e:	01 c4       	rjmp	.+2050   	; 0xa82 <sincos+0x3fa>
     280:	ff 7f       	andi	r31, 0xFF	; 255
     282:	3f 00       	.word	0x003f	; ????
     284:	00 00       	nop
	...

00000288 <__trampolines_end>:
     288:	00 00       	nop
     28a:	00 01       	movw	r0, r0
     28c:	80 00       	.word	0x0080	; ????
     28e:	80 01       	movw	r16, r0
     290:	40 00       	.word	0x0040	; ????
     292:	40 01       	movw	r8, r0
     294:	c0 00       	.word	0x00c0	; ????
     296:	c0 01       	movw	r24, r0
     298:	20 00       	.word	0x0020	; ????
     29a:	20 01       	movw	r4, r0
     29c:	a0 00       	.word	0x00a0	; ????
     29e:	a0 01       	movw	r20, r0
     2a0:	60 00       	.word	0x0060	; ????
     2a2:	60 01       	movw	r12, r0
     2a4:	e0 00       	.word	0x00e0	; ????
     2a6:	e0 01       	movw	r28, r0
     2a8:	10 00       	.word	0x0010	; ????
     2aa:	10 01       	movw	r2, r0
     2ac:	90 00       	.word	0x0090	; ????
     2ae:	90 01       	movw	r18, r0
     2b0:	50 00       	.word	0x0050	; ????
     2b2:	50 01       	movw	r10, r0
     2b4:	d0 00       	.word	0x00d0	; ????
     2b6:	d0 01       	movw	r26, r0
     2b8:	30 00       	.word	0x0030	; ????
     2ba:	30 01       	movw	r6, r0
     2bc:	b0 00       	.word	0x00b0	; ????
     2be:	b0 01       	movw	r22, r0
     2c0:	70 00       	.word	0x0070	; ????
     2c2:	70 01       	movw	r14, r0
     2c4:	f0 00       	.word	0x00f0	; ????
     2c6:	f0 01       	movw	r30, r0
     2c8:	08 00       	.word	0x0008	; ????
     2ca:	08 01       	movw	r0, r16
     2cc:	88 00       	.word	0x0088	; ????
     2ce:	88 01       	movw	r16, r16
     2d0:	48 00       	.word	0x0048	; ????
     2d2:	48 01       	movw	r8, r16
     2d4:	c8 00       	.word	0x00c8	; ????
     2d6:	c8 01       	movw	r24, r16
     2d8:	28 00       	.word	0x0028	; ????
     2da:	28 01       	movw	r4, r16
     2dc:	a8 00       	.word	0x00a8	; ????
     2de:	a8 01       	movw	r20, r16
     2e0:	68 00       	.word	0x0068	; ????
     2e2:	68 01       	movw	r12, r16
     2e4:	e8 00       	.word	0x00e8	; ????
     2e6:	e8 01       	movw	r28, r16
     2e8:	18 00       	.word	0x0018	; ????
     2ea:	18 01       	movw	r2, r16
     2ec:	98 00       	.word	0x0098	; ????
     2ee:	98 01       	movw	r18, r16
     2f0:	58 00       	.word	0x0058	; ????
     2f2:	58 01       	movw	r10, r16
     2f4:	d8 00       	.word	0x00d8	; ????
     2f6:	d8 01       	movw	r26, r16
     2f8:	38 00       	.word	0x0038	; ????
     2fa:	38 01       	movw	r6, r16
     2fc:	b8 00       	.word	0x00b8	; ????
     2fe:	b8 01       	movw	r22, r16
     300:	78 00       	.word	0x0078	; ????
     302:	78 01       	movw	r14, r16
     304:	f8 00       	.word	0x00f8	; ????
     306:	f8 01       	movw	r30, r16
     308:	04 00       	.word	0x0004	; ????
     30a:	04 01       	movw	r0, r8
     30c:	84 00       	.word	0x0084	; ????
     30e:	84 01       	movw	r16, r8
     310:	44 00       	.word	0x0044	; ????
     312:	44 01       	movw	r8, r8
     314:	c4 00       	.word	0x00c4	; ????
     316:	c4 01       	movw	r24, r8
     318:	24 00       	.word	0x0024	; ????
     31a:	24 01       	movw	r4, r8
     31c:	a4 00       	.word	0x00a4	; ????
     31e:	a4 01       	movw	r20, r8
     320:	64 00       	.word	0x0064	; ????
     322:	64 01       	movw	r12, r8
     324:	e4 00       	.word	0x00e4	; ????
     326:	e4 01       	movw	r28, r8
     328:	14 00       	.word	0x0014	; ????
     32a:	14 01       	movw	r2, r8
     32c:	94 00       	.word	0x0094	; ????
     32e:	94 01       	movw	r18, r8
     330:	54 00       	.word	0x0054	; ????
     332:	54 01       	movw	r10, r8
     334:	d4 00       	.word	0x00d4	; ????
     336:	d4 01       	movw	r26, r8
     338:	34 00       	.word	0x0034	; ????
     33a:	34 01       	movw	r6, r8
     33c:	b4 00       	.word	0x00b4	; ????
     33e:	b4 01       	movw	r22, r8
     340:	74 00       	.word	0x0074	; ????
     342:	74 01       	movw	r14, r8
     344:	f4 00       	.word	0x00f4	; ????
     346:	f4 01       	movw	r30, r8
     348:	0c 00       	.word	0x000c	; ????
     34a:	0c 01       	movw	r0, r24
     34c:	8c 00       	.word	0x008c	; ????
     34e:	8c 01       	movw	r16, r24
     350:	4c 00       	.word	0x004c	; ????
     352:	4c 01       	movw	r8, r24
     354:	cc 00       	.word	0x00cc	; ????
     356:	cc 01       	movw	r24, r24
     358:	2c 00       	.word	0x002c	; ????
     35a:	2c 01       	movw	r4, r24
     35c:	ac 00       	.word	0x00ac	; ????
     35e:	ac 01       	movw	r20, r24
     360:	6c 00       	.word	0x006c	; ????
     362:	6c 01       	movw	r12, r24
     364:	ec 00       	.word	0x00ec	; ????
     366:	ec 01       	movw	r28, r24
     368:	1c 00       	.word	0x001c	; ????
     36a:	1c 01       	movw	r2, r24
     36c:	9c 00       	.word	0x009c	; ????
     36e:	9c 01       	movw	r18, r24
     370:	5c 00       	.word	0x005c	; ????
     372:	5c 01       	movw	r10, r24
     374:	dc 00       	.word	0x00dc	; ????
     376:	dc 01       	movw	r26, r24
     378:	3c 00       	.word	0x003c	; ????
     37a:	3c 01       	movw	r6, r24
     37c:	bc 00       	.word	0x00bc	; ????
     37e:	bc 01       	movw	r22, r24
     380:	7c 00       	.word	0x007c	; ????
     382:	7c 01       	movw	r14, r24
     384:	fc 00       	.word	0x00fc	; ????
     386:	fc 01       	movw	r30, r24
     388:	02 00       	.word	0x0002	; ????
     38a:	02 01       	movw	r0, r4
     38c:	82 00       	.word	0x0082	; ????
     38e:	82 01       	movw	r16, r4
     390:	42 00       	.word	0x0042	; ????
     392:	42 01       	movw	r8, r4
     394:	c2 00       	.word	0x00c2	; ????
     396:	c2 01       	movw	r24, r4
     398:	22 00       	.word	0x0022	; ????
     39a:	22 01       	movw	r4, r4
     39c:	a2 00       	.word	0x00a2	; ????
     39e:	a2 01       	movw	r20, r4
     3a0:	62 00       	.word	0x0062	; ????
     3a2:	62 01       	movw	r12, r4
     3a4:	e2 00       	.word	0x00e2	; ????
     3a6:	e2 01       	movw	r28, r4
     3a8:	12 00       	.word	0x0012	; ????
     3aa:	12 01       	movw	r2, r4
     3ac:	92 00       	.word	0x0092	; ????
     3ae:	92 01       	movw	r18, r4
     3b0:	52 00       	.word	0x0052	; ????
     3b2:	52 01       	movw	r10, r4
     3b4:	d2 00       	.word	0x00d2	; ????
     3b6:	d2 01       	movw	r26, r4
     3b8:	32 00       	.word	0x0032	; ????
     3ba:	32 01       	movw	r6, r4
     3bc:	b2 00       	.word	0x00b2	; ????
     3be:	b2 01       	movw	r22, r4
     3c0:	72 00       	.word	0x0072	; ????
     3c2:	72 01       	movw	r14, r4
     3c4:	f2 00       	.word	0x00f2	; ????
     3c6:	f2 01       	movw	r30, r4
     3c8:	0a 00       	.word	0x000a	; ????
     3ca:	0a 01       	movw	r0, r20
     3cc:	8a 00       	.word	0x008a	; ????
     3ce:	8a 01       	movw	r16, r20
     3d0:	4a 00       	.word	0x004a	; ????
     3d2:	4a 01       	movw	r8, r20
     3d4:	ca 00       	.word	0x00ca	; ????
     3d6:	ca 01       	movw	r24, r20
     3d8:	2a 00       	.word	0x002a	; ????
     3da:	2a 01       	movw	r4, r20
     3dc:	aa 00       	.word	0x00aa	; ????
     3de:	aa 01       	movw	r20, r20
     3e0:	6a 00       	.word	0x006a	; ????
     3e2:	6a 01       	movw	r12, r20
     3e4:	ea 00       	.word	0x00ea	; ????
     3e6:	ea 01       	movw	r28, r20
     3e8:	1a 00       	.word	0x001a	; ????
     3ea:	1a 01       	movw	r2, r20
     3ec:	9a 00       	.word	0x009a	; ????
     3ee:	9a 01       	movw	r18, r20
     3f0:	5a 00       	.word	0x005a	; ????
     3f2:	5a 01       	movw	r10, r20
     3f4:	da 00       	.word	0x00da	; ????
     3f6:	da 01       	movw	r26, r20
     3f8:	3a 00       	.word	0x003a	; ????
     3fa:	3a 01       	movw	r6, r20
     3fc:	ba 00       	.word	0x00ba	; ????
     3fe:	ba 01       	movw	r22, r20
     400:	7a 00       	.word	0x007a	; ????
     402:	7a 01       	movw	r14, r20
     404:	fa 00       	.word	0x00fa	; ????
     406:	fa 01       	movw	r30, r20
     408:	06 00       	.word	0x0006	; ????
     40a:	06 01       	movw	r0, r12
     40c:	86 00       	.word	0x0086	; ????
     40e:	86 01       	movw	r16, r12
     410:	46 00       	.word	0x0046	; ????
     412:	46 01       	movw	r8, r12
     414:	c6 00       	.word	0x00c6	; ????
     416:	c6 01       	movw	r24, r12
     418:	26 00       	.word	0x0026	; ????
     41a:	26 01       	movw	r4, r12
     41c:	a6 00       	.word	0x00a6	; ????
     41e:	a6 01       	movw	r20, r12
     420:	66 00       	.word	0x0066	; ????
     422:	66 01       	movw	r12, r12
     424:	e6 00       	.word	0x00e6	; ????
     426:	e6 01       	movw	r28, r12
     428:	16 00       	.word	0x0016	; ????
     42a:	16 01       	movw	r2, r12
     42c:	96 00       	.word	0x0096	; ????
     42e:	96 01       	movw	r18, r12
     430:	56 00       	.word	0x0056	; ????
     432:	56 01       	movw	r10, r12
     434:	d6 00       	.word	0x00d6	; ????
     436:	d6 01       	movw	r26, r12
     438:	36 00       	.word	0x0036	; ????
     43a:	36 01       	movw	r6, r12
     43c:	b6 00       	.word	0x00b6	; ????
     43e:	b6 01       	movw	r22, r12
     440:	76 00       	.word	0x0076	; ????
     442:	76 01       	movw	r14, r12
     444:	f6 00       	.word	0x00f6	; ????
     446:	f6 01       	movw	r30, r12
     448:	0e 00       	.word	0x000e	; ????
     44a:	0e 01       	movw	r0, r28
     44c:	8e 00       	.word	0x008e	; ????
     44e:	8e 01       	movw	r16, r28
     450:	4e 00       	.word	0x004e	; ????
     452:	4e 01       	movw	r8, r28
     454:	ce 00       	.word	0x00ce	; ????
     456:	ce 01       	movw	r24, r28
     458:	2e 00       	.word	0x002e	; ????
     45a:	2e 01       	movw	r4, r28
     45c:	ae 00       	.word	0x00ae	; ????
     45e:	ae 01       	movw	r20, r28
     460:	6e 00       	.word	0x006e	; ????
     462:	6e 01       	movw	r12, r28
     464:	ee 00       	.word	0x00ee	; ????
     466:	ee 01       	movw	r28, r28
     468:	1e 00       	.word	0x001e	; ????
     46a:	1e 01       	movw	r2, r28
     46c:	9e 00       	.word	0x009e	; ????
     46e:	9e 01       	movw	r18, r28
     470:	5e 00       	.word	0x005e	; ????
     472:	5e 01       	movw	r10, r28
     474:	de 00       	.word	0x00de	; ????
     476:	de 01       	movw	r26, r28
     478:	3e 00       	.word	0x003e	; ????
     47a:	3e 01       	movw	r6, r28
     47c:	be 00       	.word	0x00be	; ????
     47e:	be 01       	movw	r22, r28
     480:	7e 00       	.word	0x007e	; ????
     482:	7e 01       	movw	r14, r28
     484:	fe 00       	.word	0x00fe	; ????
     486:	fe 01       	movw	r30, r28
     488:	01 00       	.word	0x0001	; ????
     48a:	01 01       	movw	r0, r2
     48c:	81 00       	.word	0x0081	; ????
     48e:	81 01       	movw	r16, r2
     490:	41 00       	.word	0x0041	; ????
     492:	41 01       	movw	r8, r2
     494:	c1 00       	.word	0x00c1	; ????
     496:	c1 01       	movw	r24, r2
     498:	21 00       	.word	0x0021	; ????
     49a:	21 01       	movw	r4, r2
     49c:	a1 00       	.word	0x00a1	; ????
     49e:	a1 01       	movw	r20, r2
     4a0:	61 00       	.word	0x0061	; ????
     4a2:	61 01       	movw	r12, r2
     4a4:	e1 00       	.word	0x00e1	; ????
     4a6:	e1 01       	movw	r28, r2
     4a8:	11 00       	.word	0x0011	; ????
     4aa:	11 01       	movw	r2, r2
     4ac:	91 00       	.word	0x0091	; ????
     4ae:	91 01       	movw	r18, r2
     4b0:	51 00       	.word	0x0051	; ????
     4b2:	51 01       	movw	r10, r2
     4b4:	d1 00       	.word	0x00d1	; ????
     4b6:	d1 01       	movw	r26, r2
     4b8:	31 00       	.word	0x0031	; ????
     4ba:	31 01       	movw	r6, r2
     4bc:	b1 00       	.word	0x00b1	; ????
     4be:	b1 01       	movw	r22, r2
     4c0:	71 00       	.word	0x0071	; ????
     4c2:	71 01       	movw	r14, r2
     4c4:	f1 00       	.word	0x00f1	; ????
     4c6:	f1 01       	movw	r30, r2
     4c8:	09 00       	.word	0x0009	; ????
     4ca:	09 01       	movw	r0, r18
     4cc:	89 00       	.word	0x0089	; ????
     4ce:	89 01       	movw	r16, r18
     4d0:	49 00       	.word	0x0049	; ????
     4d2:	49 01       	movw	r8, r18
     4d4:	c9 00       	.word	0x00c9	; ????
     4d6:	c9 01       	movw	r24, r18
     4d8:	29 00       	.word	0x0029	; ????
     4da:	29 01       	movw	r4, r18
     4dc:	a9 00       	.word	0x00a9	; ????
     4de:	a9 01       	movw	r20, r18
     4e0:	69 00       	.word	0x0069	; ????
     4e2:	69 01       	movw	r12, r18
     4e4:	e9 00       	.word	0x00e9	; ????
     4e6:	e9 01       	movw	r28, r18
     4e8:	19 00       	.word	0x0019	; ????
     4ea:	19 01       	movw	r2, r18
     4ec:	99 00       	.word	0x0099	; ????
     4ee:	99 01       	movw	r18, r18
     4f0:	59 00       	.word	0x0059	; ????
     4f2:	59 01       	movw	r10, r18
     4f4:	d9 00       	.word	0x00d9	; ????
     4f6:	d9 01       	movw	r26, r18
     4f8:	39 00       	.word	0x0039	; ????
     4fa:	39 01       	movw	r6, r18
     4fc:	b9 00       	.word	0x00b9	; ????
     4fe:	b9 01       	movw	r22, r18
     500:	79 00       	.word	0x0079	; ????
     502:	79 01       	movw	r14, r18
     504:	f9 00       	.word	0x00f9	; ????
     506:	f9 01       	movw	r30, r18
     508:	05 00       	.word	0x0005	; ????
     50a:	05 01       	movw	r0, r10
     50c:	85 00       	.word	0x0085	; ????
     50e:	85 01       	movw	r16, r10
     510:	45 00       	.word	0x0045	; ????
     512:	45 01       	movw	r8, r10
     514:	c5 00       	.word	0x00c5	; ????
     516:	c5 01       	movw	r24, r10
     518:	25 00       	.word	0x0025	; ????
     51a:	25 01       	movw	r4, r10
     51c:	a5 00       	.word	0x00a5	; ????
     51e:	a5 01       	movw	r20, r10
     520:	65 00       	.word	0x0065	; ????
     522:	65 01       	movw	r12, r10
     524:	e5 00       	.word	0x00e5	; ????
     526:	e5 01       	movw	r28, r10
     528:	15 00       	.word	0x0015	; ????
     52a:	15 01       	movw	r2, r10
     52c:	95 00       	.word	0x0095	; ????
     52e:	95 01       	movw	r18, r10
     530:	55 00       	.word	0x0055	; ????
     532:	55 01       	movw	r10, r10
     534:	d5 00       	.word	0x00d5	; ????
     536:	d5 01       	movw	r26, r10
     538:	35 00       	.word	0x0035	; ????
     53a:	35 01       	movw	r6, r10
     53c:	b5 00       	.word	0x00b5	; ????
     53e:	b5 01       	movw	r22, r10
     540:	75 00       	.word	0x0075	; ????
     542:	75 01       	movw	r14, r10
     544:	f5 00       	.word	0x00f5	; ????
     546:	f5 01       	movw	r30, r10
     548:	0d 00       	.word	0x000d	; ????
     54a:	0d 01       	movw	r0, r26
     54c:	8d 00       	.word	0x008d	; ????
     54e:	8d 01       	movw	r16, r26
     550:	4d 00       	.word	0x004d	; ????
     552:	4d 01       	movw	r8, r26
     554:	cd 00       	.word	0x00cd	; ????
     556:	cd 01       	movw	r24, r26
     558:	2d 00       	.word	0x002d	; ????
     55a:	2d 01       	movw	r4, r26
     55c:	ad 00       	.word	0x00ad	; ????
     55e:	ad 01       	movw	r20, r26
     560:	6d 00       	.word	0x006d	; ????
     562:	6d 01       	movw	r12, r26
     564:	ed 00       	.word	0x00ed	; ????
     566:	ed 01       	movw	r28, r26
     568:	1d 00       	.word	0x001d	; ????
     56a:	1d 01       	movw	r2, r26
     56c:	9d 00       	.word	0x009d	; ????
     56e:	9d 01       	movw	r18, r26
     570:	5d 00       	.word	0x005d	; ????
     572:	5d 01       	movw	r10, r26
     574:	dd 00       	.word	0x00dd	; ????
     576:	dd 01       	movw	r26, r26
     578:	3d 00       	.word	0x003d	; ????
     57a:	3d 01       	movw	r6, r26
     57c:	bd 00       	.word	0x00bd	; ????
     57e:	bd 01       	movw	r22, r26
     580:	7d 00       	.word	0x007d	; ????
     582:	7d 01       	movw	r14, r26
     584:	fd 00       	.word	0x00fd	; ????
     586:	fd 01       	movw	r30, r26
     588:	03 00       	.word	0x0003	; ????
     58a:	03 01       	movw	r0, r6
     58c:	83 00       	.word	0x0083	; ????
     58e:	83 01       	movw	r16, r6
     590:	43 00       	.word	0x0043	; ????
     592:	43 01       	movw	r8, r6
     594:	c3 00       	.word	0x00c3	; ????
     596:	c3 01       	movw	r24, r6
     598:	23 00       	.word	0x0023	; ????
     59a:	23 01       	movw	r4, r6
     59c:	a3 00       	.word	0x00a3	; ????
     59e:	a3 01       	movw	r20, r6
     5a0:	63 00       	.word	0x0063	; ????
     5a2:	63 01       	movw	r12, r6
     5a4:	e3 00       	.word	0x00e3	; ????
     5a6:	e3 01       	movw	r28, r6
     5a8:	13 00       	.word	0x0013	; ????
     5aa:	13 01       	movw	r2, r6
     5ac:	93 00       	.word	0x0093	; ????
     5ae:	93 01       	movw	r18, r6
     5b0:	53 00       	.word	0x0053	; ????
     5b2:	53 01       	movw	r10, r6
     5b4:	d3 00       	.word	0x00d3	; ????
     5b6:	d3 01       	movw	r26, r6
     5b8:	33 00       	.word	0x0033	; ????
     5ba:	33 01       	movw	r6, r6
     5bc:	b3 00       	.word	0x00b3	; ????
     5be:	b3 01       	movw	r22, r6
     5c0:	73 00       	.word	0x0073	; ????
     5c2:	73 01       	movw	r14, r6
     5c4:	f3 00       	.word	0x00f3	; ????
     5c6:	f3 01       	movw	r30, r6
     5c8:	0b 00       	.word	0x000b	; ????
     5ca:	0b 01       	movw	r0, r22
     5cc:	8b 00       	.word	0x008b	; ????
     5ce:	8b 01       	movw	r16, r22
     5d0:	4b 00       	.word	0x004b	; ????
     5d2:	4b 01       	movw	r8, r22
     5d4:	cb 00       	.word	0x00cb	; ????
     5d6:	cb 01       	movw	r24, r22
     5d8:	2b 00       	.word	0x002b	; ????
     5da:	2b 01       	movw	r4, r22
     5dc:	ab 00       	.word	0x00ab	; ????
     5de:	ab 01       	movw	r20, r22
     5e0:	6b 00       	.word	0x006b	; ????
     5e2:	6b 01       	movw	r12, r22
     5e4:	eb 00       	.word	0x00eb	; ????
     5e6:	eb 01       	movw	r28, r22
     5e8:	1b 00       	.word	0x001b	; ????
     5ea:	1b 01       	movw	r2, r22
     5ec:	9b 00       	.word	0x009b	; ????
     5ee:	9b 01       	movw	r18, r22
     5f0:	5b 00       	.word	0x005b	; ????
     5f2:	5b 01       	movw	r10, r22
     5f4:	db 00       	.word	0x00db	; ????
     5f6:	db 01       	movw	r26, r22
     5f8:	3b 00       	.word	0x003b	; ????
     5fa:	3b 01       	movw	r6, r22
     5fc:	bb 00       	.word	0x00bb	; ????
     5fe:	bb 01       	movw	r22, r22
     600:	7b 00       	.word	0x007b	; ????
     602:	7b 01       	movw	r14, r22
     604:	fb 00       	.word	0x00fb	; ????
     606:	fb 01       	movw	r30, r22
     608:	07 00       	.word	0x0007	; ????
     60a:	07 01       	movw	r0, r14
     60c:	87 00       	.word	0x0087	; ????
     60e:	87 01       	movw	r16, r14
     610:	47 00       	.word	0x0047	; ????
     612:	47 01       	movw	r8, r14
     614:	c7 00       	.word	0x00c7	; ????
     616:	c7 01       	movw	r24, r14
     618:	27 00       	.word	0x0027	; ????
     61a:	27 01       	movw	r4, r14
     61c:	a7 00       	.word	0x00a7	; ????
     61e:	a7 01       	movw	r20, r14
     620:	67 00       	.word	0x0067	; ????
     622:	67 01       	movw	r12, r14
     624:	e7 00       	.word	0x00e7	; ????
     626:	e7 01       	movw	r28, r14
     628:	17 00       	.word	0x0017	; ????
     62a:	17 01       	movw	r2, r14
     62c:	97 00       	.word	0x0097	; ????
     62e:	97 01       	movw	r18, r14
     630:	57 00       	.word	0x0057	; ????
     632:	57 01       	movw	r10, r14
     634:	d7 00       	.word	0x00d7	; ????
     636:	d7 01       	movw	r26, r14
     638:	37 00       	.word	0x0037	; ????
     63a:	37 01       	movw	r6, r14
     63c:	b7 00       	.word	0x00b7	; ????
     63e:	b7 01       	movw	r22, r14
     640:	77 00       	.word	0x0077	; ????
     642:	77 01       	movw	r14, r14
     644:	f7 00       	.word	0x00f7	; ????
     646:	f7 01       	movw	r30, r14
     648:	0f 00       	.word	0x000f	; ????
     64a:	0f 01       	movw	r0, r30
     64c:	8f 00       	.word	0x008f	; ????
     64e:	8f 01       	movw	r16, r30
     650:	4f 00       	.word	0x004f	; ????
     652:	4f 01       	movw	r8, r30
     654:	cf 00       	.word	0x00cf	; ????
     656:	cf 01       	movw	r24, r30
     658:	2f 00       	.word	0x002f	; ????
     65a:	2f 01       	movw	r4, r30
     65c:	af 00       	.word	0x00af	; ????
     65e:	af 01       	movw	r20, r30
     660:	6f 00       	.word	0x006f	; ????
     662:	6f 01       	movw	r12, r30
     664:	ef 00       	.word	0x00ef	; ????
     666:	ef 01       	movw	r28, r30
     668:	1f 00       	.word	0x001f	; ????
     66a:	1f 01       	movw	r2, r30
     66c:	9f 00       	.word	0x009f	; ????
     66e:	9f 01       	movw	r18, r30
     670:	5f 00       	.word	0x005f	; ????
     672:	5f 01       	movw	r10, r30
     674:	df 00       	.word	0x00df	; ????
     676:	df 01       	movw	r26, r30
     678:	3f 00       	.word	0x003f	; ????
     67a:	3f 01       	movw	r6, r30
     67c:	bf 00       	.word	0x00bf	; ????
     67e:	bf 01       	movw	r22, r30
     680:	7f 00       	.word	0x007f	; ????
     682:	7f 01       	movw	r14, r30
     684:	ff 00       	.word	0x00ff	; ????
     686:	ff 01       	movw	r30, r30

00000688 <sincos>:
     688:	00 00 00 00 00 00 80 3f 80 10 49 3c 16 fb 7f 3f     .......?..I<...?
     698:	35 0a c9 3c 46 ec 7f 3f f0 c2 16 3d 91 d3 7f 3f     5..<F..?...=...?
     6a8:	87 fb 48 3d 07 b1 7f 3f bb 2b 7b 3d a9 84 7f 3f     ..H=...?.+{=...?
     6b8:	3f a9 96 3d 66 4e 7f 3f 56 b6 af 3d 5e 0e 7f 3f     ?..=fN.?V..=^..?
     6c8:	23 bd c8 3d 72 c4 7e 3f 12 bc e1 3d b0 70 7e 3f     #..=r.~?...=.p~?
     6d8:	9e b2 fa 3d 2b 13 7e 3f 9a cf 09 3e d2 ab 7d 3f     ...=+.~?...>..}?
     6e8:	64 40 16 3e b4 3a 7d 3f ac ab 22 3e c2 bf 7c 3f     d@.>.:}?..">..|?
     6f8:	aa 10 2f 3e 2e 3b 7c 3f d6 6e 3b 3e c5 ac 7b 3f     ../>.;|?.n;>..{?
     708:	ac c5 47 3e ba 14 7b 3f e8 14 54 3e fc 72 7a 3f     ..G>..{?..T>.rz?
     718:	03 5c 60 3e 9b c7 79 3f 78 9a 6c 3e 99 12 79 3f     .\`>..y?x.l>..y?
     728:	c0 cf 78 3e f4 53 78 3f cc 7d 82 3e bd 8b 77 3f     ..x>.Sx?.}.>..w?
     738:	9b 8e 88 3e 06 ba 76 3f 2c 9a 8e 3e ce de 75 3f     ...>..v?,..>..u?
     748:	3c a0 94 3e 05 fa 74 3f 88 a0 9a 3e dd 0b 74 3f     <..>..t?...>..t?
     758:	ed 9a a0 3e 44 14 73 3f 08 8f a6 3e 4d 13 72 3f     ...>D.s?...>M.r?
     768:	d9 7c ac 3e 07 09 71 3f fa 63 b2 3e 73 f5 6f 3f     .|.>..q?.c.>s.o?
     778:	28 44 b8 3e a1 d8 6e 3f 43 1d be 3e 92 b2 6d 3f     (D.>..n?C..>..m?
     788:	07 ef c3 3e 66 83 6c 3f 52 b9 c9 3e 0e 4b 6b 3f     ...>f.l?R..>.Kk?
     798:	c0 7b cf 3e ab 09 6a 3f 50 36 d5 3e 3c bf 68 3f     .{.>..j?P6.><.h?
     7a8:	7d e8 da 3e d3 6b 67 3f 47 92 e0 3e 80 0f 66 3f     }..>.kg?G..>..f?
     7b8:	6a 33 e6 3e 54 aa 64 3f c5 cb eb 3e 60 3c 63 3f     j3.>T.d?...>`<c?
     7c8:	f3 5a f1 3e 93 c5 61 3f d2 e0 f6 3e 20 46 60 3f     .Z.>..a?...> F`?
     7d8:	20 5d fc 3e 06 be 5e 3f de e7 00 3f 56 2d 5d 3f      ].>..^?...?V-]?
     7e8:	41 9c 03 3f 21 94 5b 3f 88 4b 06 3f 67 f2 59 3f     A..?!.[?.K.?g.Y?
     7f8:	a1 f5 08 3f 5a 48 58 3f 6b 9a 0b 3f ea 95 56 3f     ...?ZHX?k..?..V?
     808:	d6 39 0e 3f 38 db 54 3f d0 d3 10 3f 44 18 53 3f     .9.?8.T?...?D.S?
     818:	27 68 13 3f 40 4d 51 3f dc f6 15 3f 1c 7a 4f 3f     'h.?@MQ?...?.zO?
     828:	bb 7f 18 3f 0a 9f 4d 3f c5 02 1b 3f f9 bb 4b 3f     ...?..M?...?..K?
     838:	d8 7f 1d 3f 0b d1 49 3f c2 f6 1f 3f 61 de 47 3f     ...?..I?...?a.G?
     848:	94 67 22 3f fc e3 45 3f 2d d2 24 3f fc e1 43 3f     .g"?..E?-.$?..C?
     858:	59 36 27 3f 73 d8 41 3f 18 94 29 3f 60 c7 3f 3f     Y6'?s.A?..)?`.??
     868:	4a eb 2b 3f f7 ae 3d 3f de 3b 2e 3f 36 8f 3b 3f     J.+?..=?.;.?6.;?
     878:	c2 85 30 3f 40 68 39 3f c5 c8 32 3f 26 3a 37 3f     ..0?@h9?..2?&:7?
     888:	f7 04 35 3f f7 04 35 3f 26 3a 37 3f c5 c8 32 3f     ..5?..5?&:7?..2?
     898:	40 68 39 3f c2 85 30 3f 36 8f 3b 3f de 3b 2e 3f     @h9?..0?6.;?.;.?
     8a8:	f7 ae 3d 3f 4a eb 2b 3f 60 c7 3f 3f 18 94 29 3f     ..=?J.+?`.??..)?
     8b8:	73 d8 41 3f 59 36 27 3f fc e1 43 3f 2d d2 24 3f     s.A?Y6'?..C?-.$?
     8c8:	fc e3 45 3f 94 67 22 3f 61 de 47 3f c2 f6 1f 3f     ..E?.g"?a.G?...?
     8d8:	0b d1 49 3f d8 7f 1d 3f f9 bb 4b 3f c5 02 1b 3f     ..I?...?..K?...?
     8e8:	0a 9f 4d 3f bb 7f 18 3f 1c 7a 4f 3f dc f6 15 3f     ..M?...?.zO?...?
     8f8:	40 4d 51 3f 27 68 13 3f 44 18 53 3f d0 d3 10 3f     @MQ?'h.?D.S?...?
     908:	38 db 54 3f d6 39 0e 3f ea 95 56 3f 6b 9a 0b 3f     8.T?.9.?..V?k..?
     918:	5a 48 58 3f a1 f5 08 3f 67 f2 59 3f 88 4b 06 3f     ZHX?...?g.Y?.K.?
     928:	21 94 5b 3f 41 9c 03 3f 56 2d 5d 3f de e7 00 3f     !.[?A..?V-]?...?
     938:	06 be 5e 3f 20 5d fc 3e 20 46 60 3f d2 e0 f6 3e     ..^? ].> F`?...>
     948:	93 c5 61 3f f3 5a f1 3e 60 3c 63 3f c5 cb eb 3e     ..a?.Z.>`<c?...>
     958:	54 aa 64 3f 6a 33 e6 3e 80 0f 66 3f 47 92 e0 3e     T.d?j3.>..f?G..>
     968:	d3 6b 67 3f 7d e8 da 3e 3c bf 68 3f 50 36 d5 3e     .kg?}..><.h?P6.>
     978:	ab 09 6a 3f c0 7b cf 3e 0e 4b 6b 3f 52 b9 c9 3e     ..j?.{.>.Kk?R..>
     988:	66 83 6c 3f 07 ef c3 3e 92 b2 6d 3f 43 1d be 3e     f.l?...>..m?C..>
     998:	a1 d8 6e 3f 28 44 b8 3e 73 f5 6f 3f fa 63 b2 3e     ..n?(D.>s.o?.c.>
     9a8:	07 09 71 3f d9 7c ac 3e 4d 13 72 3f 08 8f a6 3e     ..q?.|.>M.r?...>
     9b8:	44 14 73 3f ed 9a a0 3e dd 0b 74 3f 88 a0 9a 3e     D.s?...>..t?...>
     9c8:	05 fa 74 3f 3c a0 94 3e ce de 75 3f 2c 9a 8e 3e     ..t?<..>..u?,..>
     9d8:	06 ba 76 3f 9b 8e 88 3e bd 8b 77 3f cc 7d 82 3e     ..v?...>..w?.}.>
     9e8:	f4 53 78 3f c0 cf 78 3e 99 12 79 3f 78 9a 6c 3e     .Sx?..x>..y?x.l>
     9f8:	9b c7 79 3f 03 5c 60 3e fc 72 7a 3f e8 14 54 3e     ..y?.\`>.rz?..T>
     a08:	ba 14 7b 3f ac c5 47 3e c5 ac 7b 3f d6 6e 3b 3e     ..{?..G>..{?.n;>
     a18:	2e 3b 7c 3f aa 10 2f 3e c2 bf 7c 3f ac ab 22 3e     .;|?../>..|?..">
     a28:	b4 3a 7d 3f 64 40 16 3e d2 ab 7d 3f 9a cf 09 3e     .:}?d@.>..}?...>
     a38:	2b 13 7e 3f 9e b2 fa 3d b0 70 7e 3f 12 bc e1 3d     +.~?...=.p~?...=
     a48:	72 c4 7e 3f 23 bd c8 3d 5e 0e 7f 3f 56 b6 af 3d     r.~?#..=^..?V..=
     a58:	66 4e 7f 3f 3f a9 96 3d a9 84 7f 3f bb 2b 7b 3d     fN.??..=...?.+{=
     a68:	07 b1 7f 3f 87 fb 48 3d 91 d3 7f 3f f0 c2 16 3d     ...?..H=...?...=
     a78:	46 ec 7f 3f 35 0a c9 3c 16 fb 7f 3f 80 10 49 3c     F..?5..<...?..I<
     a88:	00 00 80 3f 00 00 00 00 16 fb 7f 3f 80 10 49 bc     ...?.......?..I.
     a98:	46 ec 7f 3f 35 0a c9 bc 91 d3 7f 3f f0 c2 16 bd     F..?5......?....
     aa8:	07 b1 7f 3f 87 fb 48 bd a9 84 7f 3f bb 2b 7b bd     ...?..H....?.+{.
     ab8:	66 4e 7f 3f 3f a9 96 bd 5e 0e 7f 3f 56 b6 af bd     fN.??...^..?V...
     ac8:	72 c4 7e 3f 23 bd c8 bd b0 70 7e 3f 12 bc e1 bd     r.~?#....p~?....
     ad8:	2b 13 7e 3f 9e b2 fa bd d2 ab 7d 3f 9a cf 09 be     +.~?......}?....
     ae8:	b4 3a 7d 3f 64 40 16 be c2 bf 7c 3f ac ab 22 be     .:}?d@....|?..".
     af8:	2e 3b 7c 3f aa 10 2f be c5 ac 7b 3f d6 6e 3b be     .;|?../...{?.n;.
     b08:	ba 14 7b 3f ac c5 47 be fc 72 7a 3f e8 14 54 be     ..{?..G..rz?..T.
     b18:	9b c7 79 3f 03 5c 60 be 99 12 79 3f 78 9a 6c be     ..y?.\`...y?x.l.
     b28:	f4 53 78 3f c0 cf 78 be bd 8b 77 3f cc 7d 82 be     .Sx?..x...w?.}..
     b38:	06 ba 76 3f 9b 8e 88 be ce de 75 3f 2c 9a 8e be     ..v?......u?,...
     b48:	05 fa 74 3f 3c a0 94 be dd 0b 74 3f 88 a0 9a be     ..t?<.....t?....
     b58:	44 14 73 3f ed 9a a0 be 4d 13 72 3f 08 8f a6 be     D.s?....M.r?....
     b68:	07 09 71 3f d9 7c ac be 73 f5 6f 3f fa 63 b2 be     ..q?.|..s.o?.c..
     b78:	a1 d8 6e 3f 28 44 b8 be 92 b2 6d 3f 43 1d be be     ..n?(D....m?C...
     b88:	66 83 6c 3f 07 ef c3 be 0e 4b 6b 3f 52 b9 c9 be     f.l?.....Kk?R...
     b98:	ab 09 6a 3f c0 7b cf be 3c bf 68 3f 50 36 d5 be     ..j?.{..<.h?P6..
     ba8:	d3 6b 67 3f 7d e8 da be 80 0f 66 3f 47 92 e0 be     .kg?}.....f?G...
     bb8:	54 aa 64 3f 6a 33 e6 be 60 3c 63 3f c5 cb eb be     T.d?j3..`<c?....
     bc8:	93 c5 61 3f f3 5a f1 be 20 46 60 3f d2 e0 f6 be     ..a?.Z.. F`?....
     bd8:	06 be 5e 3f 20 5d fc be 56 2d 5d 3f de e7 00 bf     ..^? ]..V-]?....
     be8:	21 94 5b 3f 41 9c 03 bf 67 f2 59 3f 88 4b 06 bf     !.[?A...g.Y?.K..
     bf8:	5a 48 58 3f a1 f5 08 bf ea 95 56 3f 6b 9a 0b bf     ZHX?......V?k...
     c08:	38 db 54 3f d6 39 0e bf 44 18 53 3f d0 d3 10 bf     8.T?.9..D.S?....
     c18:	40 4d 51 3f 27 68 13 bf 1c 7a 4f 3f dc f6 15 bf     @MQ?'h...zO?....
     c28:	0a 9f 4d 3f bb 7f 18 bf f9 bb 4b 3f c5 02 1b bf     ..M?......K?....
     c38:	0b d1 49 3f d8 7f 1d bf 61 de 47 3f c2 f6 1f bf     ..I?....a.G?....
     c48:	fc e3 45 3f 94 67 22 bf fc e1 43 3f 2d d2 24 bf     ..E?.g"...C?-.$.
     c58:	73 d8 41 3f 59 36 27 bf 60 c7 3f 3f 18 94 29 bf     s.A?Y6'.`.??..).
     c68:	f7 ae 3d 3f 4a eb 2b bf 36 8f 3b 3f de 3b 2e bf     ..=?J.+.6.;?.;..
     c78:	40 68 39 3f c2 85 30 bf 26 3a 37 3f c5 c8 32 bf     @h9?..0.&:7?..2.
     c88:	f7 04 35 3f f7 04 35 bf c5 c8 32 3f 26 3a 37 bf     ..5?..5...2?&:7.
     c98:	c2 85 30 3f 40 68 39 bf de 3b 2e 3f 36 8f 3b bf     ..0?@h9..;.?6.;.
     ca8:	4a eb 2b 3f f7 ae 3d bf 18 94 29 3f 60 c7 3f bf     J.+?..=...)?`.?.
     cb8:	59 36 27 3f 73 d8 41 bf 2d d2 24 3f fc e1 43 bf     Y6'?s.A.-.$?..C.
     cc8:	94 67 22 3f fc e3 45 bf c2 f6 1f 3f 61 de 47 bf     .g"?..E....?a.G.
     cd8:	d8 7f 1d 3f 0b d1 49 bf c5 02 1b 3f f9 bb 4b bf     ...?..I....?..K.
     ce8:	bb 7f 18 3f 0a 9f 4d bf dc f6 15 3f 1c 7a 4f bf     ...?..M....?.zO.
     cf8:	27 68 13 3f 40 4d 51 bf d0 d3 10 3f 44 18 53 bf     'h.?@MQ....?D.S.
     d08:	d6 39 0e 3f 38 db 54 bf 6b 9a 0b 3f ea 95 56 bf     .9.?8.T.k..?..V.
     d18:	a1 f5 08 3f 5a 48 58 bf 88 4b 06 3f 67 f2 59 bf     ...?ZHX..K.?g.Y.
     d28:	41 9c 03 3f 21 94 5b bf de e7 00 3f 56 2d 5d bf     A..?!.[....?V-].
     d38:	20 5d fc 3e 06 be 5e bf d2 e0 f6 3e 20 46 60 bf      ].>..^....> F`.
     d48:	f3 5a f1 3e 93 c5 61 bf c5 cb eb 3e 60 3c 63 bf     .Z.>..a....>`<c.
     d58:	6a 33 e6 3e 54 aa 64 bf 47 92 e0 3e 80 0f 66 bf     j3.>T.d.G..>..f.
     d68:	7d e8 da 3e d3 6b 67 bf 50 36 d5 3e 3c bf 68 bf     }..>.kg.P6.><.h.
     d78:	c0 7b cf 3e ab 09 6a bf 52 b9 c9 3e 0e 4b 6b bf     .{.>..j.R..>.Kk.
     d88:	07 ef c3 3e 66 83 6c bf 43 1d be 3e 92 b2 6d bf     ...>f.l.C..>..m.
     d98:	28 44 b8 3e a1 d8 6e bf fa 63 b2 3e 73 f5 6f bf     (D.>..n..c.>s.o.
     da8:	d9 7c ac 3e 07 09 71 bf 08 8f a6 3e 4d 13 72 bf     .|.>..q....>M.r.
     db8:	ed 9a a0 3e 44 14 73 bf 88 a0 9a 3e dd 0b 74 bf     ...>D.s....>..t.
     dc8:	3c a0 94 3e 05 fa 74 bf 2c 9a 8e 3e ce de 75 bf     <..>..t.,..>..u.
     dd8:	9b 8e 88 3e 06 ba 76 bf cc 7d 82 3e bd 8b 77 bf     ...>..v..}.>..w.
     de8:	c0 cf 78 3e f4 53 78 bf 78 9a 6c 3e 99 12 79 bf     ..x>.Sx.x.l>..y.
     df8:	03 5c 60 3e 9b c7 79 bf e8 14 54 3e fc 72 7a bf     .\`>..y...T>.rz.
     e08:	ac c5 47 3e ba 14 7b bf d6 6e 3b 3e c5 ac 7b bf     ..G>..{..n;>..{.
     e18:	aa 10 2f 3e 2e 3b 7c bf ac ab 22 3e c2 bf 7c bf     ../>.;|...">..|.
     e28:	64 40 16 3e b4 3a 7d bf 9a cf 09 3e d2 ab 7d bf     d@.>.:}....>..}.
     e38:	9e b2 fa 3d 2b 13 7e bf 12 bc e1 3d b0 70 7e bf     ...=+.~....=.p~.
     e48:	23 bd c8 3d 72 c4 7e bf 56 b6 af 3d 5e 0e 7f bf     #..=r.~.V..=^...
     e58:	3f a9 96 3d 66 4e 7f bf bb 2b 7b 3d a9 84 7f bf     ?..=fN...+{=....
     e68:	87 fb 48 3d 07 b1 7f bf f0 c2 16 3d 91 d3 7f bf     ..H=.......=....
     e78:	35 0a c9 3c 46 ec 7f bf 80 10 49 3c 16 fb 7f bf     5..<F.....I<....
     e88:	00 00 00 00 00 00 80 bf                             ........

00000e90 <crc_tab>:
     e90:	00 00 00 00 03 83 6b f2 f7 70 3b e1 f4 f3 50 13     ......k..p;...P.
     ea0:	1f 97 9a c7 1c 14 f1 35 e8 e7 a1 26 eb 64 ca d4     .......5...&.d..
     eb0:	cf 58 d9 8a cc db b2 78 38 28 e2 6b 3b ab 89 99     .X.....x8(.k;...
     ec0:	d0 cf 43 4d d3 4c 28 bf 27 bf 78 ac 24 3c 13 5e     ..CM.L(.'.x.$<.^
     ed0:	6f c7 5e 10 6c 44 35 e2 98 b7 65 f1 9b 34 0e 03     o.^.lD5...e..4..
     ee0:	70 50 c4 d7 73 d3 af 25 87 20 ff 36 84 a3 94 c4     pP..s..%. .6....
     ef0:	a0 9f 87 9a a3 1c ec 68 57 ef bc 7b 54 6c d7 89     .......hW..{Tl..
     f00:	bf 08 1d 5d bc 8b 76 af 48 78 26 bc 4b fb 4d 4e     ...]..v.Hx&.K.MN
     f10:	de 8e bd 20 dd 0d d6 d2 29 fe 86 c1 2a 7d ed 33     ... ....)...*}.3
     f20:	c1 19 27 e7 c2 9a 4c 15 36 69 1c 06 35 ea 77 f4     ..'...L.6i..5.w.
     f30:	11 d6 64 aa 12 55 0f 58 e6 a6 5f 4b e5 25 34 b9     ..d..U.X.._K.%4.
     f40:	0e 41 fe 6d 0d c2 95 9f f9 31 c5 8c fa b2 ae 7e     .A.m.....1.....~
     f50:	b1 49 e3 30 b2 ca 88 c2 46 39 d8 d1 45 ba b3 23     .I.0....F9..E..#
     f60:	ae de 79 f7 ad 5d 12 05 59 ae 42 16 5a 2d 29 e4     ..y..]..Y.B.Z-).
     f70:	7e 11 3a ba 7d 92 51 48 89 61 01 5b 8a e2 6a a9     ~.:.}.QH.a.[..j.
     f80:	61 86 a0 7d 62 05 cb 8f 96 f6 9b 9c 95 75 f0 6e     a..}b........u.n
     f90:	bc 1d 7b 41 bf 9e 10 b3 4b 6d 40 a0 48 ee 2b 52     ..{A....Km@.H.+R
     fa0:	a3 8a e1 86 a0 09 8a 74 54 fa da 67 57 79 b1 95     .......tT..gWy..
     fb0:	73 45 a2 cb 70 c6 c9 39 84 35 99 2a 87 b6 f2 d8     sE..p..9.5.*....
     fc0:	6c d2 38 0c 6f 51 53 fe 9b a2 03 ed 98 21 68 1f     l.8.oQS......!h.
     fd0:	d3 da 25 51 d0 59 4e a3 24 aa 1e b0 27 29 75 42     ..%Q.YN.$...')uB
     fe0:	cc 4d bf 96 cf ce d4 64 3b 3d 84 77 38 be ef 85     .M.....d;=.w8...
     ff0:	1c 82 fc db 1f 01 97 29 eb f2 c7 3a e8 71 ac c8     .......)...:.q..
    1000:	03 15 66 1c 00 96 0d ee f4 65 5d fd f7 e6 36 0f     ..f......e]...6.
    1010:	62 93 c6 61 61 10 ad 93 95 e3 fd 80 96 60 96 72     b..aa........`.r
    1020:	7d 04 5c a6 7e 87 37 54 8a 74 67 47 89 f7 0c b5     }.\.~.7T.tgG....
    1030:	ad cb 1f eb ae 48 74 19 5a bb 24 0a 59 38 4f f8     .....Ht.Z.$.Y8O.
    1040:	b2 5c 85 2c b1 df ee de 45 2c be cd 46 af d5 3f     .\.,....E,..F..?
    1050:	0d 54 98 71 0e d7 f3 83 fa 24 a3 90 f9 a7 c8 62     .T.q.....$.....b
    1060:	12 c3 02 b6 11 40 69 44 e5 b3 39 57 e6 30 52 a5     .....@iD..9W.0R.
    1070:	c2 0c 41 fb c1 8f 2a 09 35 7c 7a 1a 36 ff 11 e8     ..A...*.5|z.6...
    1080:	dd 9b db 3c de 18 b0 ce 2a eb e0 dd 29 68 8b 2f     ...<....*...)h./
    1090:	78 3b f6 82 7b b8 9d 70 8f 4b cd 63 8c c8 a6 91     x;..{..p.K.c....
    10a0:	67 ac 6c 45 64 2f 07 b7 90 dc 57 a4 93 5f 3c 56     g.lEd/....W.._<V
    10b0:	b7 63 2f 08 b4 e0 44 fa 40 13 14 e9 43 90 7f 1b     .c/...D.@...C...
    10c0:	a8 f4 b5 cf ab 77 de 3d 5f 84 8e 2e 5c 07 e5 dc     .....w.=_...\...
    10d0:	17 fc a8 92 14 7f c3 60 e0 8c 93 73 e3 0f f8 81     .......`...s....
    10e0:	08 6b 32 55 0b e8 59 a7 ff 1b 09 b4 fc 98 62 46     .k2U..Y.......bF
    10f0:	d8 a4 71 18 db 27 1a ea 2f d4 4a f9 2c 57 21 0b     ..q..'../.J.,W!.
    1100:	c7 33 eb df c4 b0 80 2d 30 43 d0 3e 33 c0 bb cc     .3.....-0C.>3...
    1110:	a6 b5 4b a2 a5 36 20 50 51 c5 70 43 52 46 1b b1     ..K..6 PQ.pCRF..
    1120:	b9 22 d1 65 ba a1 ba 97 4e 52 ea 84 4d d1 81 76     .".e....NR..M..v
    1130:	69 ed 92 28 6a 6e f9 da 9e 9d a9 c9 9d 1e c2 3b     i..(jn.........;
    1140:	76 7a 08 ef 75 f9 63 1d 81 0a 33 0e 82 89 58 fc     vz..u.c...3...X.
    1150:	c9 72 15 b2 ca f1 7e 40 3e 02 2e 53 3d 81 45 a1     .r....~@>..S=.E.
    1160:	d6 e5 8f 75 d5 66 e4 87 21 95 b4 94 22 16 df 66     ...u.f..!..."..f
    1170:	06 2a cc 38 05 a9 a7 ca f1 5a f7 d9 f2 d9 9c 2b     .*.8.....Z.....+
    1180:	19 bd 56 ff 1a 3e 3d 0d ee cd 6d 1e ed 4e 06 ec     ..V..>=...m..N..
    1190:	c4 26 8d c3 c7 a5 e6 31 33 56 b6 22 30 d5 dd d0     .&.....13V."0...
    11a0:	db b1 17 04 d8 32 7c f6 2c c1 2c e5 2f 42 47 17     .....2|.,.,./BG.
    11b0:	0b 7e 54 49 08 fd 3f bb fc 0e 6f a8 ff 8d 04 5a     .~TI..?...o....Z
    11c0:	14 e9 ce 8e 17 6a a5 7c e3 99 f5 6f e0 1a 9e 9d     .....j.|...o....
    11d0:	ab e1 d3 d3 a8 62 b8 21 5c 91 e8 32 5f 12 83 c0     .....b.!\..2_...
    11e0:	b4 76 49 14 b7 f5 22 e6 43 06 72 f5 40 85 19 07     .vI...".C.r.@...
    11f0:	64 b9 0a 59 67 3a 61 ab 93 c9 31 b8 90 4a 5a 4a     d..Yg:a...1..JZJ
    1200:	7b 2e 90 9e 78 ad fb 6c 8c 5e ab 7f 8f dd c0 8d     {...x..l.^......
    1210:	1a a8 30 e3 19 2b 5b 11 ed d8 0b 02 ee 5b 60 f0     ..0..+[......[`.
    1220:	05 3f aa 24 06 bc c1 d6 f2 4f 91 c5 f1 cc fa 37     .?.$.....O.....7
    1230:	d5 f0 e9 69 d6 73 82 9b 22 80 d2 88 21 03 b9 7a     ...i.s.."...!..z
    1240:	ca 67 73 ae c9 e4 18 5c 3d 17 48 4f 3e 94 23 bd     .gs....\=.HO>.#.
    1250:	75 6f 6e f3 76 ec 05 01 82 1f 55 12 81 9c 3e e0     uon.v.....U...>.
    1260:	6a f8 f4 34 69 7b 9f c6 9d 88 cf d5 9e 0b a4 27     j..4i{.........'
    1270:	ba 37 b7 79 b9 b4 dc 8b 4d 47 8c 98 4e c4 e7 6a     .7.y....MG..N..j
    1280:	a5 a0 2d be a6 23 46 4c 52 d0 16 5f 51 53 7d ad     ..-..#FLR.._QS}.

00001290 <__c.2161>:
    1290:	6e 61 6e 00                                         nan.

00001294 <__c.2159>:
    1294:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
    12a4:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
    12b4:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
    12c4:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
    12d4:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
    12e4:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
    12f4:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
    1304:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
    1314:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
    1324:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
    1334:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
    1344:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
    1354:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
    1364:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
    1374:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
    1384:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00001392 <__ctors_end>:
    1392:	11 24       	eor	r1, r1
    1394:	1f be       	out	0x3f, r1	; 63
    1396:	cf ef       	ldi	r28, 0xFF	; 255
    1398:	cd bf       	out	0x3d, r28	; 61
    139a:	df e3       	ldi	r29, 0x3F	; 63
    139c:	de bf       	out	0x3e, r29	; 62
    139e:	00 e0       	ldi	r16, 0x00	; 0
    13a0:	0c bf       	out	0x3c, r16	; 60
    13a2:	18 be       	out	0x38, r1	; 56
    13a4:	19 be       	out	0x39, r1	; 57
    13a6:	1a be       	out	0x3a, r1	; 58
    13a8:	1b be       	out	0x3b, r1	; 59

000013aa <__do_copy_data>:
    13aa:	11 e2       	ldi	r17, 0x21	; 33
    13ac:	a0 e0       	ldi	r26, 0x00	; 0
    13ae:	b0 e2       	ldi	r27, 0x20	; 32
    13b0:	e6 ef       	ldi	r30, 0xF6	; 246
    13b2:	f4 e8       	ldi	r31, 0x84	; 132
    13b4:	00 e0       	ldi	r16, 0x00	; 0
    13b6:	0b bf       	out	0x3b, r16	; 59
    13b8:	02 c0       	rjmp	.+4      	; 0x13be <__do_copy_data+0x14>
    13ba:	07 90       	elpm	r0, Z+
    13bc:	0d 92       	st	X+, r0
    13be:	aa 33       	cpi	r26, 0x3A	; 58
    13c0:	b1 07       	cpc	r27, r17
    13c2:	d9 f7       	brne	.-10     	; 0x13ba <__do_copy_data+0x10>
    13c4:	1b be       	out	0x3b, r1	; 59

000013c6 <__do_clear_bss>:
    13c6:	2d e3       	ldi	r18, 0x3D	; 61
    13c8:	aa e3       	ldi	r26, 0x3A	; 58
    13ca:	b1 e2       	ldi	r27, 0x21	; 33
    13cc:	01 c0       	rjmp	.+2      	; 0x13d0 <.do_clear_bss_start>

000013ce <.do_clear_bss_loop>:
    13ce:	1d 92       	st	X+, r1

000013d0 <.do_clear_bss_start>:
    13d0:	ae 3e       	cpi	r26, 0xEE	; 238
    13d2:	b2 07       	cpc	r27, r18
    13d4:	e1 f7       	brne	.-8      	; 0x13ce <.do_clear_bss_loop>
    13d6:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <main>
    13da:	0c 94 79 42 	jmp	0x84f2	; 0x84f2 <_exit>

000013de <__bad_interrupt>:
    13de:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000013e2 <cspTask>:
/*	Task that handles CSP incoming packets								*/
/* -------------------------------------------------------------------- */
void cspTask(void *p) {
	
	/* Create socket without any socket options */
	csp_socket_t * sock = csp_socket(CSP_SO_NONE);
    13e2:	60 e0       	ldi	r22, 0x00	; 0
    13e4:	70 e0       	ldi	r23, 0x00	; 0
    13e6:	cb 01       	movw	r24, r22
    13e8:	0e 94 86 22 	call	0x450c	; 0x450c <csp_socket>
    13ec:	7c 01       	movw	r14, r24

	/* Bind all ports to socket */
	csp_bind(sock, CSP_ANY);
    13ee:	60 e2       	ldi	r22, 0x20	; 32
    13f0:	0e 94 aa 24 	call	0x4954	; 0x4954 <csp_bind>

	/* Create 10 connections backlog queue */
	csp_listen(sock, 10);
    13f4:	6a e0       	ldi	r22, 0x0A	; 10
    13f6:	70 e0       	ldi	r23, 0x00	; 0
    13f8:	c7 01       	movw	r24, r14
    13fa:	0e 94 8f 24 	call	0x491e	; 0x491e <csp_listen>

	/* Pointer to current connection and packet */
	csp_conn_t * conn;
	csp_packet_t * packet;
	
	xCSPEventQueue = xQueueCreate(10, (portBASE_TYPE) sizeof(xCSPStackEvent_t));
    13fe:	40 e0       	ldi	r20, 0x00	; 0
    1400:	63 e0       	ldi	r22, 0x03	; 3
    1402:	8a e0       	ldi	r24, 0x0A	; 10
    1404:	4f d7       	rcall	.+3742   	; 0x22a4 <xQueueGenericCreate>
    1406:	80 93 01 3b 	sts	0x3B01, r24
    140a:	90 93 02 3b 	sts	0x3B02, r25
				
				/* if Port 22 packet received */
				// Return computed attenuation signal
				case 22:
				
				newEvent->eEventType = sendAttenuationEvent;
    140e:	0f 2e       	mov	r0, r31
    1410:	f7 e0       	ldi	r31, 0x07	; 7
    1412:	7f 2e       	mov	r7, r31
    1414:	f0 2d       	mov	r31, r0
				
				/* if Port 21 packet received */
				// Return summary info of calculated signal (resonant frequency and attenuation coefficient)
				case 21:
				
				newEvent->eEventType = sendSummaryInfoEvent;
    1416:	0f 2e       	mov	r0, r31
    1418:	f6 e0       	ldi	r31, 0x06	; 6
    141a:	8f 2e       	mov	r8, r31
    141c:	f0 2d       	mov	r31, r0
				
				/* if Port 20 packet received */
				// Return calculated FFT
				case 20:
				
				newEvent->eEventType = sendFFTEvent;
    141e:	0f 2e       	mov	r0, r31
    1420:	f5 e0       	ldi	r31, 0x05	; 5
    1422:	9f 2e       	mov	r9, r31
    1424:	f0 2d       	mov	r31, r0
				
				/* if Port 19 packet received */
				// Return sampled signal
				case 19:
				
				newEvent->eEventType = sendSignalEvent;
    1426:	68 94       	set
    1428:	aa 24       	eor	r10, r10
    142a:	a2 f8       	bld	r10, 2
				
				/* if Port 18 packet received */
				// Start measure and calculate all
				case 18:
				
				newEvent->eEventType = processAllEvent;
    142c:	0f 2e       	mov	r0, r31
    142e:	f3 e0       	ldi	r31, 0x03	; 3
    1430:	bf 2e       	mov	r11, r31
    1432:	f0 2d       	mov	r31, r0
				
				/* if Port 17 packet received */
				// Return info status message
				case 17:
				
					newEvent->eEventType = housKeepingEvent;
    1434:	68 94       	set
    1436:	cc 24       	eor	r12, r12
    1438:	c1 f8       	bld	r12, 1
					
				/* if Port 16 packet received */
				// Free Heap space in Human readable form
				case 16:
				
					newEvent->eEventType = freeHeapEvent;
    143a:	dd 24       	eor	r13, r13
    143c:	d3 94       	inc	r13

	/* Process incoming connections */
	while (1) {
		
		/* Wait for connection, 10000 ms timeout */
		if ((conn = csp_accept(sock, 10000)) == NULL)
    143e:	40 e1       	ldi	r20, 0x10	; 16
    1440:	57 e2       	ldi	r21, 0x27	; 39
    1442:	60 e0       	ldi	r22, 0x00	; 0
    1444:	70 e0       	ldi	r23, 0x00	; 0
    1446:	c7 01       	movw	r24, r14
    1448:	0e 94 cc 22 	call	0x4598	; 0x4598 <csp_accept>
    144c:	8c 01       	movw	r16, r24
    144e:	00 97       	sbiw	r24, 0x00	; 0
    1450:	b1 f3       	breq	.-20     	; 0x143e <cspTask+0x5c>
    1452:	89 c0       	rjmp	.+274    	; 0x1566 <cspTask+0x184>
		continue;

		/* Read packets. Timout is 1000 ms */
		while ((packet = csp_read(conn, 100)) != NULL) {
			switch (csp_conn_dport(conn)) {
    1454:	c8 01       	movw	r24, r16
    1456:	0e 94 39 21 	call	0x4272	; 0x4272 <csp_conn_dport>
    145a:	0f 97       	sbiw	r24, 0x0f	; 15
    145c:	88 30       	cpi	r24, 0x08	; 8
    145e:	91 05       	cpc	r25, r1
    1460:	08 f0       	brcs	.+2      	; 0x1464 <cspTask+0x82>
    1462:	7d c0       	rjmp	.+250    	; 0x155e <cspTask+0x17c>
    1464:	82 50       	subi	r24, 0x02	; 2
    1466:	9f 4f       	sbci	r25, 0xFF	; 255
    1468:	fc 01       	movw	r30, r24
    146a:	0c 94 e0 3f 	jmp	0x7fc0	; 0x7fc0 <__tablejump2__>
				
				/* if Port 15 packet received */
				// Echo back the incoming packet
				case 15:
				
					newEvent->eEventType = echoBackEvent;
    146e:	e0 e0       	ldi	r30, 0x00	; 0
    1470:	f0 e0       	ldi	r31, 0x00	; 0
    1472:	10 82       	st	Z, r1
					newEvent->pvData = packet;
    1474:	c1 83       	std	Z+1, r28	; 0x01
    1476:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 100);
    1478:	20 e0       	ldi	r18, 0x00	; 0
    147a:	44 e6       	ldi	r20, 0x64	; 100
    147c:	50 e0       	ldi	r21, 0x00	; 0
    147e:	bf 01       	movw	r22, r30
    1480:	80 91 01 3b 	lds	r24, 0x3B01
    1484:	90 91 02 3b 	lds	r25, 0x3B02
    1488:	3c d7       	rcall	.+3704   	; 0x2302 <xQueueGenericSend>
					
				break;
    148a:	6d c0       	rjmp	.+218    	; 0x1566 <cspTask+0x184>
					
				/* if Port 16 packet received */
				// Free Heap space in Human readable form
				case 16:
				
					newEvent->eEventType = freeHeapEvent;
    148c:	e0 e0       	ldi	r30, 0x00	; 0
    148e:	f0 e0       	ldi	r31, 0x00	; 0
    1490:	d0 82       	st	Z, r13
					newEvent->pvData = packet;
    1492:	c1 83       	std	Z+1, r28	; 0x01
    1494:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 100);	
    1496:	20 e0       	ldi	r18, 0x00	; 0
    1498:	44 e6       	ldi	r20, 0x64	; 100
    149a:	50 e0       	ldi	r21, 0x00	; 0
    149c:	bf 01       	movw	r22, r30
    149e:	80 91 01 3b 	lds	r24, 0x3B01
    14a2:	90 91 02 3b 	lds	r25, 0x3B02
    14a6:	2d d7       	rcall	.+3674   	; 0x2302 <xQueueGenericSend>
					
				break;	
    14a8:	5e c0       	rjmp	.+188    	; 0x1566 <cspTask+0x184>
				
				/* if Port 17 packet received */
				// Return info status message
				case 17:
				
					newEvent->eEventType = housKeepingEvent;
    14aa:	e0 e0       	ldi	r30, 0x00	; 0
    14ac:	f0 e0       	ldi	r31, 0x00	; 0
    14ae:	c0 82       	st	Z, r12
					newEvent->pvData = packet;
    14b0:	c1 83       	std	Z+1, r28	; 0x01
    14b2:	d2 83       	std	Z+2, r29	; 0x02
					xQueueSend(xCSPEventQueue, newEvent, 10);
    14b4:	20 e0       	ldi	r18, 0x00	; 0
    14b6:	4a e0       	ldi	r20, 0x0A	; 10
    14b8:	50 e0       	ldi	r21, 0x00	; 0
    14ba:	bf 01       	movw	r22, r30
    14bc:	80 91 01 3b 	lds	r24, 0x3B01
    14c0:	90 91 02 3b 	lds	r25, 0x3B02
    14c4:	1e d7       	rcall	.+3644   	; 0x2302 <xQueueGenericSend>
				
				break;	
    14c6:	4f c0       	rjmp	.+158    	; 0x1566 <cspTask+0x184>
				
				/* if Port 18 packet received */
				// Start measure and calculate all
				case 18:
				
				newEvent->eEventType = processAllEvent;
    14c8:	e0 e0       	ldi	r30, 0x00	; 0
    14ca:	f0 e0       	ldi	r31, 0x00	; 0
    14cc:	b0 82       	st	Z, r11
				newEvent->pvData = packet;
    14ce:	c1 83       	std	Z+1, r28	; 0x01
    14d0:	d2 83       	std	Z+2, r29	; 0x02
				xQueueSend(xCSPEventQueue, newEvent, 100);
    14d2:	20 e0       	ldi	r18, 0x00	; 0
    14d4:	44 e6       	ldi	r20, 0x64	; 100
    14d6:	50 e0       	ldi	r21, 0x00	; 0
    14d8:	bf 01       	movw	r22, r30
    14da:	80 91 01 3b 	lds	r24, 0x3B01
    14de:	90 91 02 3b 	lds	r25, 0x3B02
    14e2:	0f d7       	rcall	.+3614   	; 0x2302 <xQueueGenericSend>
				
				break;
    14e4:	40 c0       	rjmp	.+128    	; 0x1566 <cspTask+0x184>
				
				/* if Port 19 packet received */
				// Return sampled signal
				case 19:
				
				newEvent->eEventType = sendSignalEvent;
    14e6:	e0 e0       	ldi	r30, 0x00	; 0
    14e8:	f0 e0       	ldi	r31, 0x00	; 0
    14ea:	a0 82       	st	Z, r10
				newEvent->pvData = packet;
    14ec:	c1 83       	std	Z+1, r28	; 0x01
    14ee:	d2 83       	std	Z+2, r29	; 0x02
				xQueueSend(xCSPEventQueue, newEvent, 100);
    14f0:	20 e0       	ldi	r18, 0x00	; 0
    14f2:	44 e6       	ldi	r20, 0x64	; 100
    14f4:	50 e0       	ldi	r21, 0x00	; 0
    14f6:	bf 01       	movw	r22, r30
    14f8:	80 91 01 3b 	lds	r24, 0x3B01
    14fc:	90 91 02 3b 	lds	r25, 0x3B02
    1500:	00 d7       	rcall	.+3584   	; 0x2302 <xQueueGenericSend>
				
				break;
    1502:	31 c0       	rjmp	.+98     	; 0x1566 <cspTask+0x184>
				
				/* if Port 20 packet received */
				// Return calculated FFT
				case 20:
				
				newEvent->eEventType = sendFFTEvent;
    1504:	e0 e0       	ldi	r30, 0x00	; 0
    1506:	f0 e0       	ldi	r31, 0x00	; 0
    1508:	90 82       	st	Z, r9
				newEvent->pvData = packet;
    150a:	c1 83       	std	Z+1, r28	; 0x01
    150c:	d2 83       	std	Z+2, r29	; 0x02
				xQueueSend(xCSPEventQueue, newEvent, 100);
    150e:	20 e0       	ldi	r18, 0x00	; 0
    1510:	44 e6       	ldi	r20, 0x64	; 100
    1512:	50 e0       	ldi	r21, 0x00	; 0
    1514:	bf 01       	movw	r22, r30
    1516:	80 91 01 3b 	lds	r24, 0x3B01
    151a:	90 91 02 3b 	lds	r25, 0x3B02
    151e:	f1 d6       	rcall	.+3554   	; 0x2302 <xQueueGenericSend>
				
				break;
    1520:	22 c0       	rjmp	.+68     	; 0x1566 <cspTask+0x184>
				
				/* if Port 21 packet received */
				// Return summary info of calculated signal (resonant frequency and attenuation coefficient)
				case 21:
				
				newEvent->eEventType = sendSummaryInfoEvent;
    1522:	e0 e0       	ldi	r30, 0x00	; 0
    1524:	f0 e0       	ldi	r31, 0x00	; 0
    1526:	80 82       	st	Z, r8
				newEvent->pvData = packet;
    1528:	c1 83       	std	Z+1, r28	; 0x01
    152a:	d2 83       	std	Z+2, r29	; 0x02
				xQueueSend(xCSPEventQueue, newEvent, 100);
    152c:	20 e0       	ldi	r18, 0x00	; 0
    152e:	44 e6       	ldi	r20, 0x64	; 100
    1530:	50 e0       	ldi	r21, 0x00	; 0
    1532:	bf 01       	movw	r22, r30
    1534:	80 91 01 3b 	lds	r24, 0x3B01
    1538:	90 91 02 3b 	lds	r25, 0x3B02
    153c:	e2 d6       	rcall	.+3524   	; 0x2302 <xQueueGenericSend>
				
				break;	
    153e:	13 c0       	rjmp	.+38     	; 0x1566 <cspTask+0x184>
				
				/* if Port 22 packet received */
				// Return computed attenuation signal
				case 22:
				
				newEvent->eEventType = sendAttenuationEvent;
    1540:	e0 e0       	ldi	r30, 0x00	; 0
    1542:	f0 e0       	ldi	r31, 0x00	; 0
    1544:	70 82       	st	Z, r7
				newEvent->pvData = packet;
    1546:	c1 83       	std	Z+1, r28	; 0x01
    1548:	d2 83       	std	Z+2, r29	; 0x02
				xQueueSend(xCSPEventQueue, newEvent, 100);
    154a:	20 e0       	ldi	r18, 0x00	; 0
    154c:	44 e6       	ldi	r20, 0x64	; 100
    154e:	50 e0       	ldi	r21, 0x00	; 0
    1550:	bf 01       	movw	r22, r30
    1552:	80 91 01 3b 	lds	r24, 0x3B01
    1556:	90 91 02 3b 	lds	r25, 0x3B02
    155a:	d3 d6       	rcall	.+3494   	; 0x2302 <xQueueGenericSend>
				
				break;
    155c:	04 c0       	rjmp	.+8      	; 0x1566 <cspTask+0x184>
				
				/* Process packet here */
				default:
				
				/* Let the service handler reply pings, buffer use, etc. */
				csp_service_handler(conn, packet);
    155e:	be 01       	movw	r22, r28
    1560:	c8 01       	movw	r24, r16
    1562:	0e 94 24 29 	call	0x5248	; 0x5248 <csp_service_handler>
		/* Wait for connection, 10000 ms timeout */
		if ((conn = csp_accept(sock, 10000)) == NULL)
		continue;

		/* Read packets. Timout is 1000 ms */
		while ((packet = csp_read(conn, 100)) != NULL) {
    1566:	44 e6       	ldi	r20, 0x64	; 100
    1568:	50 e0       	ldi	r21, 0x00	; 0
    156a:	60 e0       	ldi	r22, 0x00	; 0
    156c:	70 e0       	ldi	r23, 0x00	; 0
    156e:	c8 01       	movw	r24, r16
    1570:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <csp_read>
    1574:	ec 01       	movw	r28, r24
    1576:	00 97       	sbiw	r24, 0x00	; 0
    1578:	09 f0       	breq	.+2      	; 0x157c <cspTask+0x19a>
    157a:	6c cf       	rjmp	.-296    	; 0x1454 <cspTask+0x72>
				break;
			}
		}

		/* Close current connection, and handle next */
		csp_close(conn);
    157c:	c8 01       	movw	r24, r16
    157e:	0e 94 14 21 	call	0x4228	; 0x4228 <csp_close>
    1582:	5d cf       	rjmp	.-326    	; 0x143e <cspTask+0x5c>

00001584 <TWI_CSP_SlaveProcessData>:
TWI_Slave_t twi_csp_slave;			/*!< TWI slave module. */
i2c_callback_t callbackFunction;

// this function processes received data on the I2C Slave line
// It is call by the I2C driver
void TWI_CSP_SlaveProcessData(void) {
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	cd b7       	in	r28, 0x3d	; 61
    158a:	de b7       	in	r29, 0x3e	; 62
    158c:	c9 50       	subi	r28, 0x09	; 9
    158e:	d1 40       	sbci	r29, 0x01	; 1
    1590:	cd bf       	out	0x3d, r28	; 61
    1592:	de bf       	out	0x3e, r29	; 62
	
	if (twi_csp_slave.result == TWIS_RESULT_OK) {
    1594:	80 91 54 3b 	lds	r24, 0x3B54
    1598:	81 30       	cpi	r24, 0x01	; 1
    159a:	49 f5       	brne	.+82     	; 0x15ee <TWI_CSP_SlaveProcessData+0x6a>
		
		i2c_frame_t newFrame;
		
		if (twi_csp_slave.bytesReceived > 0) {
    159c:	80 91 51 3b 	lds	r24, 0x3B51
    15a0:	88 23       	and	r24, r24
    15a2:	e1 f0       	breq	.+56     	; 0x15dc <TWI_CSP_SlaveProcessData+0x58>
			
			// set the data len
			newFrame.len = twi_csp_slave.bytesReceived;
    15a4:	e1 e5       	ldi	r30, 0x51	; 81
    15a6:	fb e3       	ldi	r31, 0x3B	; 59
    15a8:	80 81       	ld	r24, Z
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	89 87       	std	Y+9, r24	; 0x09
    15ae:	9a 87       	std	Y+10, r25	; 0x0a
			
			// copy the data
			int i;
			for (i = 0; i < twi_csp_slave.bytesReceived; i++) {
    15b0:	80 81       	ld	r24, Z
    15b2:	88 23       	and	r24, r24
    15b4:	99 f0       	breq	.+38     	; 0x15dc <TWI_CSP_SlaveProcessData+0x58>
    15b6:	fe 01       	movw	r30, r28
    15b8:	3b 96       	adiw	r30, 0x0b	; 11
    15ba:	80 e0       	ldi	r24, 0x00	; 0
    15bc:	90 e0       	ldi	r25, 0x00	; 0
    15be:	41 e5       	ldi	r20, 0x51	; 81
    15c0:	5b e3       	ldi	r21, 0x3B	; 59
				
				newFrame.data[i] = twi_csp_slave.receivedData[i];
    15c2:	dc 01       	movw	r26, r24
    15c4:	ac 5f       	subi	r26, 0xFC	; 252
    15c6:	b4 4c       	sbci	r27, 0xC4	; 196
    15c8:	14 96       	adiw	r26, 0x04	; 4
    15ca:	2c 91       	ld	r18, X
    15cc:	21 93       	st	Z+, r18
			// set the data len
			newFrame.len = twi_csp_slave.bytesReceived;
			
			// copy the data
			int i;
			for (i = 0; i < twi_csp_slave.bytesReceived; i++) {
    15ce:	01 96       	adiw	r24, 0x01	; 1
    15d0:	da 01       	movw	r26, r20
    15d2:	2c 91       	ld	r18, X
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	82 17       	cp	r24, r18
    15d8:	93 07       	cpc	r25, r19
    15da:	9c f3       	brlt	.-26     	; 0x15c2 <TWI_CSP_SlaveProcessData+0x3e>
				
				newFrame.data[i] = twi_csp_slave.receivedData[i];
			}
		}
		
		callbackFunction(&newFrame, false);
    15dc:	e0 91 72 3c 	lds	r30, 0x3C72
    15e0:	f0 91 73 3c 	lds	r31, 0x3C73
    15e4:	60 e0       	ldi	r22, 0x00	; 0
    15e6:	70 e0       	ldi	r23, 0x00	; 0
    15e8:	ce 01       	movw	r24, r28
    15ea:	01 96       	adiw	r24, 0x01	; 1
    15ec:	19 95       	eicall
		
	}
}
    15ee:	c7 5f       	subi	r28, 0xF7	; 247
    15f0:	de 4f       	sbci	r29, 0xFE	; 254
    15f2:	cd bf       	out	0x3d, r28	; 61
    15f4:	de bf       	out	0x3e, r29	; 62
    15f6:	df 91       	pop	r29
    15f8:	cf 91       	pop	r28
    15fa:	08 95       	ret

000015fc <i2c_init>:

// Initialize the i2c interface for CSP
int i2c_init(int handle, int mode, uint8_t addr, uint16_t speed, int queue_len_tx, int queue_len_rx, i2c_callback_t callback) {
    15fc:	cf 92       	push	r12
    15fe:	df 92       	push	r13
    1600:	cf 93       	push	r28
    1602:	c4 2f       	mov	r28, r20
	
	// Initialize TWI master for CSP
	TWI_MasterInit(&twi_csp_master, &CSP_I2C_INTERFACE, TWI_MASTER_INTLVL_LO_gc, speed);
    1604:	40 e4       	ldi	r20, 0x40	; 64
    1606:	60 ea       	ldi	r22, 0xA0	; 160
    1608:	74 e0       	ldi	r23, 0x04	; 4
    160a:	86 e5       	ldi	r24, 0x56	; 86
    160c:	9b e3       	ldi	r25, 0x3B	; 59
    160e:	0e 94 c5 30 	call	0x618a	; 0x618a <TWI_MasterInit>
			
	// Initialize TWI slave for CSP
	TWI_SlaveInitializeDriver(&twi_csp_slave, &CSP_I2C_INTERFACE, TWI_CSP_SlaveProcessData);
    1612:	42 ec       	ldi	r20, 0xC2	; 194
    1614:	5a e0       	ldi	r21, 0x0A	; 10
    1616:	60 ea       	ldi	r22, 0xA0	; 160
    1618:	74 e0       	ldi	r23, 0x04	; 4
    161a:	84 e0       	ldi	r24, 0x04	; 4
    161c:	9b e3       	ldi	r25, 0x3B	; 59
    161e:	0e 94 e6 31 	call	0x63cc	; 0x63cc <TWI_SlaveInitializeDriver>
	TWI_SlaveInitializeModule(&twi_csp_slave, addr, TWI_SLAVE_INTLVL_LO_gc);
    1622:	40 e4       	ldi	r20, 0x40	; 64
    1624:	6c 2f       	mov	r22, r28
    1626:	84 e0       	ldi	r24, 0x04	; 4
    1628:	9b e3       	ldi	r25, 0x3B	; 59
    162a:	0e 94 f7 31 	call	0x63ee	; 0x63ee <TWI_SlaveInitializeModule>
	
	callbackFunction = callback;
    162e:	c0 92 72 3c 	sts	0x3C72, r12
    1632:	d0 92 73 3c 	sts	0x3C73, r13
	
	return E_NO_ERR;
}
    1636:	8f ef       	ldi	r24, 0xFF	; 255
    1638:	9f ef       	ldi	r25, 0xFF	; 255
    163a:	cf 91       	pop	r28
    163c:	df 90       	pop	r13
    163e:	cf 90       	pop	r12
    1640:	08 95       	ret

00001642 <i2c_send>:
 * @param timeout Ticks to wait
 * @return Error code
 */
int i2c_send(int handle, i2c_frame_t * frame, uint16_t timeout) {
		
	if (TWI_MasterWrite(&twi_csp_master, frame->dest, (uint8_t *) frame->data, frame->len)) {
    1642:	ab 01       	movw	r20, r22
    1644:	46 5f       	subi	r20, 0xF6	; 246
    1646:	5f 4f       	sbci	r21, 0xFF	; 255
    1648:	fb 01       	movw	r30, r22
    164a:	20 85       	ldd	r18, Z+8	; 0x08
    164c:	66 81       	ldd	r22, Z+6	; 0x06
    164e:	86 e5       	ldi	r24, 0x56	; 86
    1650:	9b e3       	ldi	r25, 0x3B	; 59
    1652:	0e 94 31 31 	call	0x6262	; 0x6262 <TWI_MasterWrite>
    1656:	88 23       	and	r24, r24
    1658:	19 f0       	breq	.+6      	; 0x1660 <i2c_send+0x1e>
		
		return E_NO_ERR;
    165a:	8f ef       	ldi	r24, 0xFF	; 255
    165c:	9f ef       	ldi	r25, 0xFF	; 255
    165e:	08 95       	ret
	} else {
		
		return 1;
    1660:	81 e0       	ldi	r24, 0x01	; 1
    1662:	90 e0       	ldi	r25, 0x00	; 0
	}
}
    1664:	08 95       	ret

00001666 <clock_get_time>:

/* User functions required */
void clock_get_time(csp_timestamp_t * time) {
    1666:	08 95       	ret

00001668 <clock_set_time>:
	
	
}

extern void clock_set_time(csp_timestamp_t * time) {
    1668:	08 95       	ret

0000166a <__vector_46>:
	
}

/*! CSP Master Interrupt vector. */
ISR(CSP_I2C_TWIM)
{
    166a:	1f 92       	push	r1
    166c:	0f 92       	push	r0
    166e:	0f b6       	in	r0, 0x3f	; 63
    1670:	0f 92       	push	r0
    1672:	11 24       	eor	r1, r1
    1674:	08 b6       	in	r0, 0x38	; 56
    1676:	0f 92       	push	r0
    1678:	18 be       	out	0x38, r1	; 56
    167a:	09 b6       	in	r0, 0x39	; 57
    167c:	0f 92       	push	r0
    167e:	19 be       	out	0x39, r1	; 57
    1680:	0b b6       	in	r0, 0x3b	; 59
    1682:	0f 92       	push	r0
    1684:	1b be       	out	0x3b, r1	; 59
    1686:	2f 93       	push	r18
    1688:	3f 93       	push	r19
    168a:	4f 93       	push	r20
    168c:	5f 93       	push	r21
    168e:	6f 93       	push	r22
    1690:	7f 93       	push	r23
    1692:	8f 93       	push	r24
    1694:	9f 93       	push	r25
    1696:	af 93       	push	r26
    1698:	bf 93       	push	r27
    169a:	ef 93       	push	r30
    169c:	ff 93       	push	r31
	TWI_MasterInterruptHandler(&twi_csp_master);
    169e:	86 e5       	ldi	r24, 0x56	; 86
    16a0:	9b e3       	ldi	r25, 0x3B	; 59
    16a2:	0e 94 cd 31 	call	0x639a	; 0x639a <TWI_MasterInterruptHandler>
}
    16a6:	ff 91       	pop	r31
    16a8:	ef 91       	pop	r30
    16aa:	bf 91       	pop	r27
    16ac:	af 91       	pop	r26
    16ae:	9f 91       	pop	r25
    16b0:	8f 91       	pop	r24
    16b2:	7f 91       	pop	r23
    16b4:	6f 91       	pop	r22
    16b6:	5f 91       	pop	r21
    16b8:	4f 91       	pop	r20
    16ba:	3f 91       	pop	r19
    16bc:	2f 91       	pop	r18
    16be:	0f 90       	pop	r0
    16c0:	0b be       	out	0x3b, r0	; 59
    16c2:	0f 90       	pop	r0
    16c4:	09 be       	out	0x39, r0	; 57
    16c6:	0f 90       	pop	r0
    16c8:	08 be       	out	0x38, r0	; 56
    16ca:	0f 90       	pop	r0
    16cc:	0f be       	out	0x3f, r0	; 63
    16ce:	0f 90       	pop	r0
    16d0:	1f 90       	pop	r1
    16d2:	18 95       	reti

000016d4 <__vector_45>:

/*! CPS Slave Interrupt vector. */
ISR(CSP_I2C_TWIS)
{
    16d4:	1f 92       	push	r1
    16d6:	0f 92       	push	r0
    16d8:	0f b6       	in	r0, 0x3f	; 63
    16da:	0f 92       	push	r0
    16dc:	11 24       	eor	r1, r1
    16de:	08 b6       	in	r0, 0x38	; 56
    16e0:	0f 92       	push	r0
    16e2:	18 be       	out	0x38, r1	; 56
    16e4:	09 b6       	in	r0, 0x39	; 57
    16e6:	0f 92       	push	r0
    16e8:	19 be       	out	0x39, r1	; 57
    16ea:	0b b6       	in	r0, 0x3b	; 59
    16ec:	0f 92       	push	r0
    16ee:	1b be       	out	0x3b, r1	; 59
    16f0:	2f 93       	push	r18
    16f2:	3f 93       	push	r19
    16f4:	4f 93       	push	r20
    16f6:	5f 93       	push	r21
    16f8:	6f 93       	push	r22
    16fa:	7f 93       	push	r23
    16fc:	8f 93       	push	r24
    16fe:	9f 93       	push	r25
    1700:	af 93       	push	r26
    1702:	bf 93       	push	r27
    1704:	ef 93       	push	r30
    1706:	ff 93       	push	r31
	TWI_SlaveInterruptHandler(&twi_csp_slave);
    1708:	84 e0       	ldi	r24, 0x04	; 4
    170a:	9b e3       	ldi	r25, 0x3B	; 59
    170c:	0e 94 c6 32 	call	0x658c	; 0x658c <TWI_SlaveInterruptHandler>
    1710:	ff 91       	pop	r31
    1712:	ef 91       	pop	r30
    1714:	bf 91       	pop	r27
    1716:	af 91       	pop	r26
    1718:	9f 91       	pop	r25
    171a:	8f 91       	pop	r24
    171c:	7f 91       	pop	r23
    171e:	6f 91       	pop	r22
    1720:	5f 91       	pop	r21
    1722:	4f 91       	pop	r20
    1724:	3f 91       	pop	r19
    1726:	2f 91       	pop	r18
    1728:	0f 90       	pop	r0
    172a:	0b be       	out	0x3b, r0	; 59
    172c:	0f 90       	pop	r0
    172e:	09 be       	out	0x39, r0	; 57
    1730:	0f 90       	pop	r0
    1732:	08 be       	out	0x38, r0	; 56
    1734:	0f 90       	pop	r0
    1736:	0f be       	out	0x3f, r0	; 63
    1738:	0f 90       	pop	r0
    173a:	1f 90       	pop	r1
    173c:	18 95       	reti

0000173e <decimate_and_store>:
//**************************************************************************
// Storing and bitreversing for FFT
//**************************************************************************
	
void decimate_and_store(void)
{
    173e:	4f 92       	push	r4
    1740:	5f 92       	push	r5
    1742:	6f 92       	push	r6
    1744:	7f 92       	push	r7
    1746:	8f 92       	push	r8
    1748:	9f 92       	push	r9
    174a:	af 92       	push	r10
    174c:	bf 92       	push	r11
    174e:	cf 92       	push	r12
    1750:	df 92       	push	r13
    1752:	ef 92       	push	r14
    1754:	ff 92       	push	r15
    1756:	0f 93       	push	r16
    1758:	1f 93       	push	r17
    175a:	cf 93       	push	r28
    175c:	df 93       	push	r29
    175e:	cd b7       	in	r28, 0x3d	; 61
    1760:	de b7       	in	r29, 0x3e	; 62
    1762:	28 97       	sbiw	r28, 0x08	; 8
    1764:	cd bf       	out	0x3d, r28	; 61
    1766:	de bf       	out	0x3e, r29	; 62
	complex point;
	int signal_offset2;
	int read_data;
	int position;
	
	signal_offset2 = spi_mem_read_word(MEM_SIGNAL_OFFSET);
    1768:	60 e0       	ldi	r22, 0x00	; 0
    176a:	78 e1       	ldi	r23, 0x18	; 24
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	0e 94 ca 35 	call	0x6b94	; 0x6b94 <spi_mem_read_word>
    1774:	4c 01       	movw	r8, r24

	point.imag = 0;
    1776:	1d 82       	std	Y+5, r1	; 0x05
    1778:	1e 82       	std	Y+6, r1	; 0x06
    177a:	1f 82       	std	Y+7, r1	; 0x07
    177c:	18 86       	std	Y+8, r1	; 0x08
    177e:	0f 2e       	mov	r0, r31
    1780:	f8 e8       	ldi	r31, 0x88	; 136
    1782:	cf 2e       	mov	r12, r31
    1784:	f2 e0       	ldi	r31, 0x02	; 2
    1786:	df 2e       	mov	r13, r31
    1788:	f0 2d       	mov	r31, r0
    178a:	0f 2e       	mov	r0, r31
    178c:	f8 e8       	ldi	r31, 0x88	; 136
    178e:	af 2e       	mov	r10, r31
    1790:	f6 e0       	ldi	r31, 0x06	; 6
    1792:	bf 2e       	mov	r11, r31
    1794:	f0 2d       	mov	r31, r0
    1796:	0f 2e       	mov	r0, r31
    1798:	41 2c       	mov	r4, r1
    179a:	f8 e1       	ldi	r31, 0x18	; 24
    179c:	5f 2e       	mov	r5, r31
    179e:	61 2c       	mov	r6, r1
    17a0:	71 2c       	mov	r7, r1
    17a2:	f0 2d       	mov	r31, r0
	
	for (i=0;i<NO_POINTS;++i)		// storing and bitreversing raw signal into spi memory
	{
		position = pgm_read_dword_far(&bitrev[i]);
    17a4:	c6 01       	movw	r24, r12
    17a6:	aa 27       	eor	r26, r26
    17a8:	97 fd       	sbrc	r25, 7
    17aa:	a0 95       	com	r26
    17ac:	ba 2f       	mov	r27, r26
    17ae:	0b b6       	in	r0, 0x3b	; 59
    17b0:	ab bf       	out	0x3b, r26	; 59
    17b2:	fc 01       	movw	r30, r24
    17b4:	87 91       	elpm	r24, Z+
    17b6:	97 91       	elpm	r25, Z+
    17b8:	a7 91       	elpm	r26, Z+
    17ba:	b6 91       	elpm	r27, Z
    17bc:	0b be       	out	0x3b, r0	; 59
		decimation_position = (long) position*DECIMATION_FACTOR;
    17be:	aa 27       	eor	r26, r26
    17c0:	97 fd       	sbrc	r25, 7
    17c2:	a0 95       	com	r26
    17c4:	ba 2f       	mov	r27, r26
    17c6:	88 0f       	add	r24, r24
    17c8:	99 1f       	adc	r25, r25
    17ca:	aa 1f       	adc	r26, r26
    17cc:	bb 1f       	adc	r27, r27
		if (decimation_position<MEM_SIGNAL_LENGTH)
    17ce:	81 15       	cp	r24, r1
    17d0:	28 e0       	ldi	r18, 0x08	; 8
    17d2:	92 07       	cpc	r25, r18
    17d4:	a1 05       	cpc	r26, r1
    17d6:	b1 05       	cpc	r27, r1
    17d8:	b0 f4       	brcc	.+44     	; 0x1806 <decimate_and_store+0xc8>
		{
			read_data = spi_mem_read_word(decimation_position*2 + MEM_SIGNAL_BEGIN) - signal_offset2;
    17da:	bc 01       	movw	r22, r24
    17dc:	cd 01       	movw	r24, r26
    17de:	66 0f       	add	r22, r22
    17e0:	77 1f       	adc	r23, r23
    17e2:	88 1f       	adc	r24, r24
    17e4:	99 1f       	adc	r25, r25
    17e6:	0e 94 ca 35 	call	0x6b94	; 0x6b94 <spi_mem_read_word>
    17ea:	88 19       	sub	r24, r8
    17ec:	99 09       	sbc	r25, r9
			point.real = read_data;
    17ee:	bc 01       	movw	r22, r24
    17f0:	88 27       	eor	r24, r24
    17f2:	77 fd       	sbrc	r23, 7
    17f4:	80 95       	com	r24
    17f6:	98 2f       	mov	r25, r24
    17f8:	0e 94 c3 3a 	call	0x7586	; 0x7586 <__floatsisf>
    17fc:	69 83       	std	Y+1, r22	; 0x01
    17fe:	7a 83       	std	Y+2, r23	; 0x02
    1800:	8b 83       	std	Y+3, r24	; 0x03
    1802:	9c 83       	std	Y+4, r25	; 0x04
    1804:	04 c0       	rjmp	.+8      	; 0x180e <decimate_and_store+0xd0>
		}
		else
			point.real = 0;
    1806:	19 82       	std	Y+1, r1	; 0x01
    1808:	1a 82       	std	Y+2, r1	; 0x02
    180a:	1b 82       	std	Y+3, r1	; 0x03
    180c:	1c 82       	std	Y+4, r1	; 0x04
					
		
		spi_mem_write_complex((i*8)+MEM_FFT_BEGIN,point);	
    180e:	e9 80       	ldd	r14, Y+1	; 0x01
    1810:	fa 80       	ldd	r15, Y+2	; 0x02
    1812:	0b 81       	ldd	r16, Y+3	; 0x03
    1814:	1c 81       	ldd	r17, Y+4	; 0x04
    1816:	2d 81       	ldd	r18, Y+5	; 0x05
    1818:	3e 81       	ldd	r19, Y+6	; 0x06
    181a:	4f 81       	ldd	r20, Y+7	; 0x07
    181c:	58 85       	ldd	r21, Y+8	; 0x08
    181e:	c3 01       	movw	r24, r6
    1820:	b2 01       	movw	r22, r4
    1822:	0e 94 83 35 	call	0x6b06	; 0x6b06 <spi_mem_write_complex>
    1826:	82 e0       	ldi	r24, 0x02	; 2
    1828:	c8 0e       	add	r12, r24
    182a:	d1 1c       	adc	r13, r1
    182c:	28 e0       	ldi	r18, 0x08	; 8
    182e:	42 0e       	add	r4, r18
    1830:	51 1c       	adc	r5, r1
    1832:	61 1c       	adc	r6, r1
    1834:	71 1c       	adc	r7, r1
	
	signal_offset2 = spi_mem_read_word(MEM_SIGNAL_OFFSET);

	point.imag = 0;
	
	for (i=0;i<NO_POINTS;++i)		// storing and bitreversing raw signal into spi memory
    1836:	ca 14       	cp	r12, r10
    1838:	db 04       	cpc	r13, r11
    183a:	09 f0       	breq	.+2      	; 0x183e <decimate_and_store+0x100>
    183c:	b3 cf       	rjmp	.-154    	; 0x17a4 <decimate_and_store+0x66>
					
		
		spi_mem_write_complex((i*8)+MEM_FFT_BEGIN,point);	

	}
}
    183e:	28 96       	adiw	r28, 0x08	; 8
    1840:	cd bf       	out	0x3d, r28	; 61
    1842:	de bf       	out	0x3e, r29	; 62
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	1f 91       	pop	r17
    184a:	0f 91       	pop	r16
    184c:	ff 90       	pop	r15
    184e:	ef 90       	pop	r14
    1850:	df 90       	pop	r13
    1852:	cf 90       	pop	r12
    1854:	bf 90       	pop	r11
    1856:	af 90       	pop	r10
    1858:	9f 90       	pop	r9
    185a:	8f 90       	pop	r8
    185c:	7f 90       	pop	r7
    185e:	6f 90       	pop	r6
    1860:	5f 90       	pop	r5
    1862:	4f 90       	pop	r4
    1864:	08 95       	ret

00001866 <FFT_calculate>:
//**************************************************************************
// FFT algorithm
//**************************************************************************
	
void FFT_calculate(void)
{
    1866:	2f 92       	push	r2
    1868:	3f 92       	push	r3
    186a:	4f 92       	push	r4
    186c:	5f 92       	push	r5
    186e:	6f 92       	push	r6
    1870:	7f 92       	push	r7
    1872:	8f 92       	push	r8
    1874:	9f 92       	push	r9
    1876:	af 92       	push	r10
    1878:	bf 92       	push	r11
    187a:	cf 92       	push	r12
    187c:	df 92       	push	r13
    187e:	ef 92       	push	r14
    1880:	ff 92       	push	r15
    1882:	0f 93       	push	r16
    1884:	1f 93       	push	r17
    1886:	cf 93       	push	r28
    1888:	df 93       	push	r29
    188a:	cd b7       	in	r28, 0x3d	; 61
    188c:	de b7       	in	r29, 0x3e	; 62
    188e:	c6 54       	subi	r28, 0x46	; 70
    1890:	d1 09       	sbc	r29, r1
    1892:	cd bf       	out	0x3d, r28	; 61
    1894:	de bf       	out	0x3e, r29	; 62
	complex A, B, C;            // A, B - input points, C - calculated point
	
    float dsin,dcos;
    unsigned int s,k;
    unsigned int n=1;
    unsigned int angf=NO_POINTS/2;
    1896:	20 e0       	ldi	r18, 0x00	; 0
    1898:	31 e0       	ldi	r19, 0x01	; 1
    189a:	29 ab       	std	Y+49, r18	; 0x31
    189c:	3a ab       	std	Y+50, r19	; 0x32
{
	complex A, B, C;            // A, B - input points, C - calculated point
	
    float dsin,dcos;
    unsigned int s,k;
    unsigned int n=1;
    189e:	41 e0       	ldi	r20, 0x01	; 1
    18a0:	50 e0       	ldi	r21, 0x00	; 0
    18a2:	25 96       	adiw	r28, 0x05	; 5
    18a4:	4e af       	std	Y+62, r20	; 0x3e
    18a6:	5f af       	std	Y+63, r21	; 0x3f
    18a8:	25 97       	sbiw	r28, 0x05	; 5
	Fnk=0;
    
    while(n<NO_POINTS)		// number of iterations log2(NO_POINTS)
    {
		pointer_A = MEM_FFT_BEGIN;
		pointer_B = MEM_FFT_BEGIN + n*8;
    18aa:	25 96       	adiw	r28, 0x05	; 5
    18ac:	8e ad       	ldd	r24, Y+62	; 0x3e
    18ae:	9f ad       	ldd	r25, Y+63	; 0x3f
    18b0:	25 97       	sbiw	r28, 0x05	; 5
    18b2:	9d 5f       	subi	r25, 0xFD	; 253
    18b4:	88 0f       	add	r24, r24
    18b6:	99 1f       	adc	r25, r25
    18b8:	88 0f       	add	r24, r24
    18ba:	99 1f       	adc	r25, r25
    18bc:	88 0f       	add	r24, r24
    18be:	99 1f       	adc	r25, r25
    18c0:	9c 01       	movw	r18, r24
    18c2:	40 e0       	ldi	r20, 0x00	; 0
    18c4:	50 e0       	ldi	r21, 0x00	; 0
    18c6:	2f ab       	std	Y+55, r18	; 0x37
    18c8:	38 af       	std	Y+56, r19	; 0x38
    18ca:	49 af       	std	Y+57, r20	; 0x39
    18cc:	5a af       	std	Y+58, r21	; 0x3a
	    Fnk = 0;
	    
	    for(k=0;k<n;k++)	// distance between butterflies
    18ce:	25 96       	adiw	r28, 0x05	; 5
    18d0:	4e ad       	ldd	r20, Y+62	; 0x3e
    18d2:	5f ad       	ldd	r21, Y+63	; 0x3f
    18d4:	25 97       	sbiw	r28, 0x05	; 5
    18d6:	41 15       	cp	r20, r1
    18d8:	51 05       	cpc	r21, r1
    18da:	09 f4       	brne	.+2      	; 0x18de <FFT_calculate+0x78>
    18dc:	b4 c1       	rjmp	.+872    	; 0x1c46 <FFT_calculate+0x3e0>
				A.imag=A.imag + C.imag;
				
				spi_mem_write_complex(pointer_A,A);
				spi_mem_write_complex(pointer_B,B);
				
				pointer_A += 16*n;
    18de:	ca 01       	movw	r24, r20
    18e0:	82 95       	swap	r24
    18e2:	92 95       	swap	r25
    18e4:	90 7f       	andi	r25, 0xF0	; 240
    18e6:	98 27       	eor	r25, r24
    18e8:	80 7f       	andi	r24, 0xF0	; 240
    18ea:	98 27       	eor	r25, r24
    18ec:	9c 01       	movw	r18, r24
    18ee:	40 e0       	ldi	r20, 0x00	; 0
    18f0:	50 e0       	ldi	r21, 0x00	; 0
    18f2:	29 a7       	std	Y+41, r18	; 0x29
    18f4:	3a a7       	std	Y+42, r19	; 0x2a
    18f6:	4b a7       	std	Y+43, r20	; 0x2b
    18f8:	5c a7       	std	Y+44, r21	; 0x2c
    18fa:	49 a9       	ldd	r20, Y+49	; 0x31
    18fc:	5a a9       	ldd	r21, Y+50	; 0x32
    18fe:	44 0f       	add	r20, r20
    1900:	55 1f       	adc	r21, r21
    1902:	44 0f       	add	r20, r20
    1904:	55 1f       	adc	r21, r21
    1906:	44 0f       	add	r20, r20
    1908:	55 1f       	adc	r21, r21
    190a:	27 96       	adiw	r28, 0x07	; 7
    190c:	4e af       	std	Y+62, r20	; 0x3e
    190e:	5f af       	std	Y+63, r21	; 0x3f
    1910:	27 97       	sbiw	r28, 0x07	; 7
    1912:	88 e8       	ldi	r24, 0x88	; 136
    1914:	96 e0       	ldi	r25, 0x06	; 6
    1916:	8b af       	std	Y+59, r24	; 0x3b
    1918:	9c af       	std	Y+60, r25	; 0x3c
    191a:	a9 a9       	ldd	r26, Y+49	; 0x31
    191c:	ba a9       	ldd	r27, Y+50	; 0x32
    191e:	11 97       	sbiw	r26, 0x01	; 1
    1920:	29 a5       	ldd	r18, Y+41	; 0x29
    1922:	3a a5       	ldd	r19, Y+42	; 0x2a
    1924:	4b a5       	ldd	r20, Y+43	; 0x2b
    1926:	5c a5       	ldd	r21, Y+44	; 0x2c
    1928:	0e 94 fb 3f 	call	0x7ff6	; 0x7ff6 <__muluhisi3>
	unsigned long pointer_A,pointer_B;
	Fnk=0;
    
    while(n<NO_POINTS)		// number of iterations log2(NO_POINTS)
    {
		pointer_A = MEM_FFT_BEGIN;
    192c:	1b aa       	std	Y+51, r1	; 0x33
    192e:	a8 e1       	ldi	r26, 0x18	; 24
    1930:	ac ab       	std	Y+52, r26	; 0x34
    1932:	1d aa       	std	Y+53, r1	; 0x35
    1934:	1e aa       	std	Y+54, r1	; 0x36
		pointer_B = MEM_FFT_BEGIN + n*8;
	    Fnk = 0;
	    
	    for(k=0;k<n;k++)	// distance between butterflies
    1936:	1d ae       	std	Y+61, r1	; 0x3d
    1938:	1e ae       	std	Y+62, r1	; 0x3e
    193a:	26 0f       	add	r18, r22
    193c:	37 1f       	adc	r19, r23
    193e:	48 1f       	adc	r20, r24
    1940:	59 1f       	adc	r21, r25
    1942:	23 96       	adiw	r28, 0x03	; 3
    1944:	2c af       	std	Y+60, r18	; 0x3c
    1946:	3d af       	std	Y+61, r19	; 0x3d
    1948:	4e af       	std	Y+62, r20	; 0x3e
    194a:	5f af       	std	Y+63, r21	; 0x3f
    194c:	23 97       	sbiw	r28, 0x03	; 3
	    {
		    dsin = pgm_read_float(&sincos[Fnk++]);
    194e:	eb ad       	ldd	r30, Y+59	; 0x3b
    1950:	fc ad       	ldd	r31, Y+60	; 0x3c
    1952:	85 91       	lpm	r24, Z+
    1954:	95 91       	lpm	r25, Z+
    1956:	a5 91       	lpm	r26, Z+
    1958:	b4 91       	lpm	r27, Z
    195a:	89 a3       	std	Y+33, r24	; 0x21
    195c:	9a a3       	std	Y+34, r25	; 0x22
    195e:	ab a3       	std	Y+35, r26	; 0x23
    1960:	bc a3       	std	Y+36, r27	; 0x24
    1962:	eb ad       	ldd	r30, Y+59	; 0x3b
    1964:	fc ad       	ldd	r31, Y+60	; 0x3c
    1966:	34 96       	adiw	r30, 0x04	; 4
		    dcos = pgm_read_float(&sincos[Fnk++]);
    1968:	25 91       	lpm	r18, Z+
    196a:	35 91       	lpm	r19, Z+
    196c:	45 91       	lpm	r20, Z+
    196e:	54 91       	lpm	r21, Z
    1970:	2d a3       	std	Y+37, r18	; 0x25
    1972:	3e a3       	std	Y+38, r19	; 0x26
    1974:	4f a3       	std	Y+39, r20	; 0x27
    1976:	58 a7       	std	Y+40, r21	; 0x28
		    
		    for(s=0;s<angf;s++)		// number of groups
    1978:	49 a9       	ldd	r20, Y+49	; 0x31
    197a:	5a a9       	ldd	r21, Y+50	; 0x32
    197c:	45 2b       	or	r20, r21
    197e:	09 f4       	brne	.+2      	; 0x1982 <FFT_calculate+0x11c>
    1980:	21 c1       	rjmp	.+578    	; 0x1bc4 <FFT_calculate+0x35e>
    1982:	8f a9       	ldd	r24, Y+55	; 0x37
    1984:	98 ad       	ldd	r25, Y+56	; 0x38
    1986:	a9 ad       	ldd	r26, Y+57	; 0x39
    1988:	ba ad       	ldd	r27, Y+58	; 0x3a
    198a:	8d 8b       	std	Y+21, r24	; 0x15
    198c:	9e 8b       	std	Y+22, r25	; 0x16
    198e:	af 8b       	std	Y+23, r26	; 0x17
    1990:	b8 8f       	std	Y+24, r27	; 0x18
    1992:	2b a9       	ldd	r18, Y+51	; 0x33
    1994:	3c a9       	ldd	r19, Y+52	; 0x34
    1996:	4d a9       	ldd	r20, Y+53	; 0x35
    1998:	5e a9       	ldd	r21, Y+54	; 0x36
    199a:	29 8b       	std	Y+17, r18	; 0x11
    199c:	3a 8b       	std	Y+18, r19	; 0x12
    199e:	4b 8b       	std	Y+19, r20	; 0x13
    19a0:	5c 8b       	std	Y+20, r21	; 0x14
    19a2:	21 2c       	mov	r2, r1
    19a4:	31 2c       	mov	r3, r1
		    {
				A = spi_mem_read_complex(pointer_A);
    19a6:	69 89       	ldd	r22, Y+17	; 0x11
    19a8:	7a 89       	ldd	r23, Y+18	; 0x12
    19aa:	8b 89       	ldd	r24, Y+19	; 0x13
    19ac:	9c 89       	ldd	r25, Y+20	; 0x14
    19ae:	0e 94 fc 35 	call	0x6bf8	; 0x6bf8 <spi_mem_read_complex>
    19b2:	29 83       	std	Y+1, r18	; 0x01
    19b4:	3a 83       	std	Y+2, r19	; 0x02
    19b6:	4b 83       	std	Y+3, r20	; 0x03
    19b8:	5c 83       	std	Y+4, r21	; 0x04
    19ba:	6d 83       	std	Y+5, r22	; 0x05
    19bc:	7e 83       	std	Y+6, r23	; 0x06
    19be:	8f 83       	std	Y+7, r24	; 0x07
    19c0:	98 87       	std	Y+8, r25	; 0x08
    19c2:	89 81       	ldd	r24, Y+1	; 0x01
    19c4:	9a 81       	ldd	r25, Y+2	; 0x02
    19c6:	ab 81       	ldd	r26, Y+3	; 0x03
    19c8:	bc 81       	ldd	r27, Y+4	; 0x04
    19ca:	8d 8f       	std	Y+29, r24	; 0x1d
    19cc:	9e 8f       	std	Y+30, r25	; 0x1e
    19ce:	af 8f       	std	Y+31, r26	; 0x1f
    19d0:	b8 a3       	std	Y+32, r27	; 0x20
    19d2:	2d 81       	ldd	r18, Y+5	; 0x05
    19d4:	3e 81       	ldd	r19, Y+6	; 0x06
    19d6:	4f 81       	ldd	r20, Y+7	; 0x07
    19d8:	58 85       	ldd	r21, Y+8	; 0x08
    19da:	29 8f       	std	Y+25, r18	; 0x19
    19dc:	3a 8f       	std	Y+26, r19	; 0x1a
    19de:	4b 8f       	std	Y+27, r20	; 0x1b
    19e0:	5c 8f       	std	Y+28, r21	; 0x1c
				B = spi_mem_read_complex(pointer_B);
    19e2:	6d 89       	ldd	r22, Y+21	; 0x15
    19e4:	7e 89       	ldd	r23, Y+22	; 0x16
    19e6:	8f 89       	ldd	r24, Y+23	; 0x17
    19e8:	98 8d       	ldd	r25, Y+24	; 0x18
    19ea:	0e 94 fc 35 	call	0x6bf8	; 0x6bf8 <spi_mem_read_complex>
    19ee:	29 87       	std	Y+9, r18	; 0x09
    19f0:	3a 87       	std	Y+10, r19	; 0x0a
    19f2:	4b 87       	std	Y+11, r20	; 0x0b
    19f4:	5c 87       	std	Y+12, r21	; 0x0c
    19f6:	6d 87       	std	Y+13, r22	; 0x0d
    19f8:	7e 87       	std	Y+14, r23	; 0x0e
    19fa:	8f 87       	std	Y+15, r24	; 0x0f
    19fc:	98 8b       	std	Y+16, r25	; 0x10
    19fe:	49 84       	ldd	r4, Y+9	; 0x09
    1a00:	5a 84       	ldd	r5, Y+10	; 0x0a
    1a02:	6b 84       	ldd	r6, Y+11	; 0x0b
    1a04:	7c 84       	ldd	r7, Y+12	; 0x0c
    1a06:	8d 84       	ldd	r8, Y+13	; 0x0d
    1a08:	9e 84       	ldd	r9, Y+14	; 0x0e
    1a0a:	af 84       	ldd	r10, Y+15	; 0x0f
    1a0c:	b8 88       	ldd	r11, Y+16	; 0x10
				
				C.real=(B.real*dcos - B.imag*dsin);
    1a0e:	a3 01       	movw	r20, r6
    1a10:	92 01       	movw	r18, r4
    1a12:	6d a1       	ldd	r22, Y+37	; 0x25
    1a14:	7e a1       	ldd	r23, Y+38	; 0x26
    1a16:	8f a1       	ldd	r24, Y+39	; 0x27
    1a18:	98 a5       	ldd	r25, Y+40	; 0x28
    1a1a:	0e 94 94 3b 	call	0x7728	; 0x7728 <__mulsf3>
    1a1e:	6b 01       	movw	r12, r22
    1a20:	7c 01       	movw	r14, r24
    1a22:	a5 01       	movw	r20, r10
    1a24:	94 01       	movw	r18, r8
    1a26:	69 a1       	ldd	r22, Y+33	; 0x21
    1a28:	7a a1       	ldd	r23, Y+34	; 0x22
    1a2a:	8b a1       	ldd	r24, Y+35	; 0x23
    1a2c:	9c a1       	ldd	r25, Y+36	; 0x24
    1a2e:	0e 94 94 3b 	call	0x7728	; 0x7728 <__mulsf3>
    1a32:	9b 01       	movw	r18, r22
    1a34:	ac 01       	movw	r20, r24
    1a36:	c7 01       	movw	r24, r14
    1a38:	b6 01       	movw	r22, r12
    1a3a:	0e 94 2b 3a 	call	0x7456	; 0x7456 <__subsf3>
    1a3e:	6b 01       	movw	r12, r22
    1a40:	7c 01       	movw	r14, r24
				C.imag=(B.real*dsin + B.imag*dcos);
    1a42:	a3 01       	movw	r20, r6
    1a44:	92 01       	movw	r18, r4
    1a46:	69 a1       	ldd	r22, Y+33	; 0x21
    1a48:	7a a1       	ldd	r23, Y+34	; 0x22
    1a4a:	8b a1       	ldd	r24, Y+35	; 0x23
    1a4c:	9c a1       	ldd	r25, Y+36	; 0x24
    1a4e:	0e 94 94 3b 	call	0x7728	; 0x7728 <__mulsf3>
    1a52:	2b 01       	movw	r4, r22
    1a54:	3c 01       	movw	r6, r24
    1a56:	a5 01       	movw	r20, r10
    1a58:	94 01       	movw	r18, r8
    1a5a:	6d a1       	ldd	r22, Y+37	; 0x25
    1a5c:	7e a1       	ldd	r23, Y+38	; 0x26
    1a5e:	8f a1       	ldd	r24, Y+39	; 0x27
    1a60:	98 a5       	ldd	r25, Y+40	; 0x28
    1a62:	0e 94 94 3b 	call	0x7728	; 0x7728 <__mulsf3>
    1a66:	9b 01       	movw	r18, r22
    1a68:	ac 01       	movw	r20, r24
    1a6a:	c3 01       	movw	r24, r6
    1a6c:	b2 01       	movw	r22, r4
    1a6e:	0e 94 2c 3a 	call	0x7458	; 0x7458 <__addsf3>
    1a72:	4b 01       	movw	r8, r22
    1a74:	5c 01       	movw	r10, r24
				
				B.real=A.real - C.real;
    1a76:	a7 01       	movw	r20, r14
    1a78:	96 01       	movw	r18, r12
    1a7a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1a7c:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1a7e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1a80:	98 a1       	ldd	r25, Y+32	; 0x20
    1a82:	0e 94 2b 3a 	call	0x7456	; 0x7456 <__subsf3>
    1a86:	76 2e       	mov	r7, r22
    1a88:	57 2e       	mov	r5, r23
    1a8a:	48 2e       	mov	r4, r24
    1a8c:	9d a7       	std	Y+45, r25	; 0x2d
				B.imag=A.imag - C.imag;
    1a8e:	a5 01       	movw	r20, r10
    1a90:	94 01       	movw	r18, r8
    1a92:	69 8d       	ldd	r22, Y+25	; 0x19
    1a94:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1a96:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a98:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1a9a:	0e 94 2b 3a 	call	0x7456	; 0x7456 <__subsf3>
    1a9e:	66 2e       	mov	r6, r22
    1aa0:	7e a7       	std	Y+46, r23	; 0x2e
    1aa2:	8f a7       	std	Y+47, r24	; 0x2f
    1aa4:	98 ab       	std	Y+48, r25	; 0x30
				A.real=A.real + C.real;
    1aa6:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1aa8:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1aaa:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1aac:	58 a1       	ldd	r21, Y+32	; 0x20
    1aae:	c7 01       	movw	r24, r14
    1ab0:	b6 01       	movw	r22, r12
    1ab2:	0e 94 2c 3a 	call	0x7458	; 0x7458 <__addsf3>
				A.imag=A.imag + C.imag;
				
				spi_mem_write_complex(pointer_A,A);
    1ab6:	e6 2e       	mov	r14, r22
    1ab8:	46 2f       	mov	r20, r22
    1aba:	57 2f       	mov	r21, r23
    1abc:	68 2f       	mov	r22, r24
    1abe:	79 2f       	mov	r23, r25
    1ac0:	49 83       	std	Y+1, r20	; 0x01
    1ac2:	5a 83       	std	Y+2, r21	; 0x02
    1ac4:	6b 83       	std	Y+3, r22	; 0x03
    1ac6:	7c 83       	std	Y+4, r23	; 0x04
				C.imag=(B.real*dsin + B.imag*dcos);
				
				B.real=A.real - C.real;
				B.imag=A.imag - C.imag;
				A.real=A.real + C.real;
				A.imag=A.imag + C.imag;
    1ac8:	29 8d       	ldd	r18, Y+25	; 0x19
    1aca:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1acc:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1ace:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1ad0:	c5 01       	movw	r24, r10
    1ad2:	b4 01       	movw	r22, r8
    1ad4:	0e 94 2c 3a 	call	0x7458	; 0x7458 <__addsf3>
				
				spi_mem_write_complex(pointer_A,A);
    1ad8:	26 2f       	mov	r18, r22
    1ada:	46 2f       	mov	r20, r22
    1adc:	57 2f       	mov	r21, r23
    1ade:	68 2f       	mov	r22, r24
    1ae0:	79 2f       	mov	r23, r25
    1ae2:	4d 83       	std	Y+5, r20	; 0x05
    1ae4:	5e 83       	std	Y+6, r21	; 0x06
    1ae6:	6f 83       	std	Y+7, r22	; 0x07
    1ae8:	78 87       	std	Y+8, r23	; 0x08
    1aea:	fa 80       	ldd	r15, Y+2	; 0x02
    1aec:	0b 81       	ldd	r16, Y+3	; 0x03
    1aee:	1c 81       	ldd	r17, Y+4	; 0x04
    1af0:	3e 81       	ldd	r19, Y+6	; 0x06
    1af2:	4f 81       	ldd	r20, Y+7	; 0x07
    1af4:	58 85       	ldd	r21, Y+8	; 0x08
    1af6:	69 89       	ldd	r22, Y+17	; 0x11
    1af8:	7a 89       	ldd	r23, Y+18	; 0x12
    1afa:	8b 89       	ldd	r24, Y+19	; 0x13
    1afc:	9c 89       	ldd	r25, Y+20	; 0x14
    1afe:	0e 94 83 35 	call	0x6b06	; 0x6b06 <spi_mem_write_complex>
				spi_mem_write_complex(pointer_B,B);
    1b02:	e7 2c       	mov	r14, r7
    1b04:	87 2d       	mov	r24, r7
    1b06:	95 2d       	mov	r25, r5
    1b08:	a4 2d       	mov	r26, r4
    1b0a:	bd a5       	ldd	r27, Y+45	; 0x2d
    1b0c:	89 87       	std	Y+9, r24	; 0x09
    1b0e:	9a 87       	std	Y+10, r25	; 0x0a
    1b10:	ab 87       	std	Y+11, r26	; 0x0b
    1b12:	bc 87       	std	Y+12, r27	; 0x0c
    1b14:	26 2d       	mov	r18, r6
    1b16:	86 2d       	mov	r24, r6
    1b18:	9e a5       	ldd	r25, Y+46	; 0x2e
    1b1a:	af a5       	ldd	r26, Y+47	; 0x2f
    1b1c:	b8 a9       	ldd	r27, Y+48	; 0x30
    1b1e:	8d 87       	std	Y+13, r24	; 0x0d
    1b20:	9e 87       	std	Y+14, r25	; 0x0e
    1b22:	af 87       	std	Y+15, r26	; 0x0f
    1b24:	b8 8b       	std	Y+16, r27	; 0x10
    1b26:	fa 84       	ldd	r15, Y+10	; 0x0a
    1b28:	0b 85       	ldd	r16, Y+11	; 0x0b
    1b2a:	1c 85       	ldd	r17, Y+12	; 0x0c
    1b2c:	3e 85       	ldd	r19, Y+14	; 0x0e
    1b2e:	4f 85       	ldd	r20, Y+15	; 0x0f
    1b30:	58 89       	ldd	r21, Y+16	; 0x10
    1b32:	6d 89       	ldd	r22, Y+21	; 0x15
    1b34:	7e 89       	ldd	r23, Y+22	; 0x16
    1b36:	8f 89       	ldd	r24, Y+23	; 0x17
    1b38:	98 8d       	ldd	r25, Y+24	; 0x18
    1b3a:	0e 94 83 35 	call	0x6b06	; 0x6b06 <spi_mem_write_complex>
				
				pointer_A += 16*n;
    1b3e:	89 89       	ldd	r24, Y+17	; 0x11
    1b40:	9a 89       	ldd	r25, Y+18	; 0x12
    1b42:	ab 89       	ldd	r26, Y+19	; 0x13
    1b44:	bc 89       	ldd	r27, Y+20	; 0x14
    1b46:	29 a5       	ldd	r18, Y+41	; 0x29
    1b48:	3a a5       	ldd	r19, Y+42	; 0x2a
    1b4a:	4b a5       	ldd	r20, Y+43	; 0x2b
    1b4c:	5c a5       	ldd	r21, Y+44	; 0x2c
    1b4e:	82 0f       	add	r24, r18
    1b50:	93 1f       	adc	r25, r19
    1b52:	a4 1f       	adc	r26, r20
    1b54:	b5 1f       	adc	r27, r21
    1b56:	89 8b       	std	Y+17, r24	; 0x11
    1b58:	9a 8b       	std	Y+18, r25	; 0x12
    1b5a:	ab 8b       	std	Y+19, r26	; 0x13
    1b5c:	bc 8b       	std	Y+20, r27	; 0x14
				pointer_B += 16*n;
    1b5e:	8d 89       	ldd	r24, Y+21	; 0x15
    1b60:	9e 89       	ldd	r25, Y+22	; 0x16
    1b62:	af 89       	ldd	r26, Y+23	; 0x17
    1b64:	b8 8d       	ldd	r27, Y+24	; 0x18
    1b66:	82 0f       	add	r24, r18
    1b68:	93 1f       	adc	r25, r19
    1b6a:	a4 1f       	adc	r26, r20
    1b6c:	b5 1f       	adc	r27, r21
    1b6e:	8d 8b       	std	Y+21, r24	; 0x15
    1b70:	9e 8b       	std	Y+22, r25	; 0x16
    1b72:	af 8b       	std	Y+23, r26	; 0x17
    1b74:	b8 8f       	std	Y+24, r27	; 0x18
	    for(k=0;k<n;k++)	// distance between butterflies
	    {
		    dsin = pgm_read_float(&sincos[Fnk++]);
		    dcos = pgm_read_float(&sincos[Fnk++]);
		    
		    for(s=0;s<angf;s++)		// number of groups
    1b76:	9f ef       	ldi	r25, 0xFF	; 255
    1b78:	29 1a       	sub	r2, r25
    1b7a:	39 0a       	sbc	r3, r25
    1b7c:	a9 a9       	ldd	r26, Y+49	; 0x31
    1b7e:	ba a9       	ldd	r27, Y+50	; 0x32
    1b80:	2a 16       	cp	r2, r26
    1b82:	3b 06       	cpc	r3, r27
    1b84:	09 f0       	breq	.+2      	; 0x1b88 <FFT_calculate+0x322>
    1b86:	0f cf       	rjmp	.-482    	; 0x19a6 <FFT_calculate+0x140>
    1b88:	2b a9       	ldd	r18, Y+51	; 0x33
    1b8a:	3c a9       	ldd	r19, Y+52	; 0x34
    1b8c:	4d a9       	ldd	r20, Y+53	; 0x35
    1b8e:	5e a9       	ldd	r21, Y+54	; 0x36
    1b90:	23 96       	adiw	r28, 0x03	; 3
    1b92:	8c ad       	ldd	r24, Y+60	; 0x3c
    1b94:	9d ad       	ldd	r25, Y+61	; 0x3d
    1b96:	ae ad       	ldd	r26, Y+62	; 0x3e
    1b98:	bf ad       	ldd	r27, Y+63	; 0x3f
    1b9a:	23 97       	sbiw	r28, 0x03	; 3
    1b9c:	28 0f       	add	r18, r24
    1b9e:	39 1f       	adc	r19, r25
    1ba0:	4a 1f       	adc	r20, r26
    1ba2:	5b 1f       	adc	r21, r27
    1ba4:	2b ab       	std	Y+51, r18	; 0x33
    1ba6:	3c ab       	std	Y+52, r19	; 0x34
    1ba8:	4d ab       	std	Y+53, r20	; 0x35
    1baa:	5e ab       	std	Y+54, r21	; 0x36
    1bac:	2f a9       	ldd	r18, Y+55	; 0x37
    1bae:	38 ad       	ldd	r19, Y+56	; 0x38
    1bb0:	49 ad       	ldd	r20, Y+57	; 0x39
    1bb2:	5a ad       	ldd	r21, Y+58	; 0x3a
    1bb4:	28 0f       	add	r18, r24
    1bb6:	39 1f       	adc	r19, r25
    1bb8:	4a 1f       	adc	r20, r26
    1bba:	5b 1f       	adc	r21, r27
    1bbc:	2f ab       	std	Y+55, r18	; 0x37
    1bbe:	38 af       	std	Y+56, r19	; 0x38
    1bc0:	49 af       	std	Y+57, r20	; 0x39
    1bc2:	5a af       	std	Y+58, r21	; 0x3a
				spi_mem_write_complex(pointer_B,B);
				
				pointer_A += 16*n;
				pointer_B += 16*n;
		    }
		    pointer_A-=((NO_POINTS-1)*8);
    1bc4:	8b a9       	ldd	r24, Y+51	; 0x33
    1bc6:	9c a9       	ldd	r25, Y+52	; 0x34
    1bc8:	ad a9       	ldd	r26, Y+53	; 0x35
    1bca:	be a9       	ldd	r27, Y+54	; 0x36
    1bcc:	88 5f       	subi	r24, 0xF8	; 248
    1bce:	9f 40       	sbci	r25, 0x0F	; 15
    1bd0:	a1 09       	sbc	r26, r1
    1bd2:	b1 09       	sbc	r27, r1
    1bd4:	8b ab       	std	Y+51, r24	; 0x33
    1bd6:	9c ab       	std	Y+52, r25	; 0x34
    1bd8:	ad ab       	std	Y+53, r26	; 0x35
    1bda:	be ab       	std	Y+54, r27	; 0x36
		    pointer_B-=((NO_POINTS-1)*8);
    1bdc:	2f a9       	ldd	r18, Y+55	; 0x37
    1bde:	38 ad       	ldd	r19, Y+56	; 0x38
    1be0:	49 ad       	ldd	r20, Y+57	; 0x39
    1be2:	5a ad       	ldd	r21, Y+58	; 0x3a
    1be4:	28 5f       	subi	r18, 0xF8	; 248
    1be6:	3f 40       	sbci	r19, 0x0F	; 15
    1be8:	41 09       	sbc	r20, r1
    1bea:	51 09       	sbc	r21, r1
    1bec:	2f ab       	std	Y+55, r18	; 0x37
    1bee:	38 af       	std	Y+56, r19	; 0x38
    1bf0:	49 af       	std	Y+57, r20	; 0x39
    1bf2:	5a af       	std	Y+58, r21	; 0x3a
    {
		pointer_A = MEM_FFT_BEGIN;
		pointer_B = MEM_FFT_BEGIN + n*8;
	    Fnk = 0;
	    
	    for(k=0;k<n;k++)	// distance between butterflies
    1bf4:	4d ad       	ldd	r20, Y+61	; 0x3d
    1bf6:	5e ad       	ldd	r21, Y+62	; 0x3e
    1bf8:	4f 5f       	subi	r20, 0xFF	; 255
    1bfa:	5f 4f       	sbci	r21, 0xFF	; 255
    1bfc:	4d af       	std	Y+61, r20	; 0x3d
    1bfe:	5e af       	std	Y+62, r21	; 0x3e
    1c00:	8b ad       	ldd	r24, Y+59	; 0x3b
    1c02:	9c ad       	ldd	r25, Y+60	; 0x3c
    1c04:	27 96       	adiw	r28, 0x07	; 7
    1c06:	ae ad       	ldd	r26, Y+62	; 0x3e
    1c08:	bf ad       	ldd	r27, Y+63	; 0x3f
    1c0a:	27 97       	sbiw	r28, 0x07	; 7
    1c0c:	8a 0f       	add	r24, r26
    1c0e:	9b 1f       	adc	r25, r27
    1c10:	8b af       	std	Y+59, r24	; 0x3b
    1c12:	9c af       	std	Y+60, r25	; 0x3c
    1c14:	25 96       	adiw	r28, 0x05	; 5
    1c16:	2e ad       	ldd	r18, Y+62	; 0x3e
    1c18:	3f ad       	ldd	r19, Y+63	; 0x3f
    1c1a:	25 97       	sbiw	r28, 0x05	; 5
    1c1c:	42 17       	cp	r20, r18
    1c1e:	53 07       	cpc	r21, r19
    1c20:	09 f0       	breq	.+2      	; 0x1c24 <FFT_calculate+0x3be>
    1c22:	95 ce       	rjmp	.-726    	; 0x194e <FFT_calculate+0xe8>
		    }
		    pointer_A-=((NO_POINTS-1)*8);
		    pointer_B-=((NO_POINTS-1)*8);
		    Fnk+=(angf-1)*2;
	    }
	    n<<=1;
    1c24:	22 0f       	add	r18, r18
    1c26:	33 1f       	adc	r19, r19
    1c28:	25 96       	adiw	r28, 0x05	; 5
    1c2a:	2e af       	std	Y+62, r18	; 0x3e
    1c2c:	3f af       	std	Y+63, r19	; 0x3f
    1c2e:	25 97       	sbiw	r28, 0x05	; 5
	    angf>>=1;
    1c30:	49 a9       	ldd	r20, Y+49	; 0x31
    1c32:	5a a9       	ldd	r21, Y+50	; 0x32
    1c34:	56 95       	lsr	r21
    1c36:	47 95       	ror	r20
    1c38:	49 ab       	std	Y+49, r20	; 0x31
    1c3a:	5a ab       	std	Y+50, r21	; 0x32
	unsigned int Fnk;
	
	unsigned long pointer_A,pointer_B;
	Fnk=0;
    
    while(n<NO_POINTS)		// number of iterations log2(NO_POINTS)
    1c3c:	21 15       	cp	r18, r1
    1c3e:	32 40       	sbci	r19, 0x02	; 2
    1c40:	08 f4       	brcc	.+2      	; 0x1c44 <FFT_calculate+0x3de>
    1c42:	33 ce       	rjmp	.-922    	; 0x18aa <FFT_calculate+0x44>
    1c44:	07 c0       	rjmp	.+14     	; 0x1c54 <FFT_calculate+0x3ee>
		    pointer_A-=((NO_POINTS-1)*8);
		    pointer_B-=((NO_POINTS-1)*8);
		    Fnk+=(angf-1)*2;
	    }
	    n<<=1;
	    angf>>=1;
    1c46:	89 a9       	ldd	r24, Y+49	; 0x31
    1c48:	9a a9       	ldd	r25, Y+50	; 0x32
    1c4a:	96 95       	lsr	r25
    1c4c:	87 95       	ror	r24
    1c4e:	89 ab       	std	Y+49, r24	; 0x31
    1c50:	9a ab       	std	Y+50, r25	; 0x32
    1c52:	2b ce       	rjmp	.-938    	; 0x18aa <FFT_calculate+0x44>
    }
}
    1c54:	ca 5b       	subi	r28, 0xBA	; 186
    1c56:	df 4f       	sbci	r29, 0xFF	; 255
    1c58:	cd bf       	out	0x3d, r28	; 61
    1c5a:	de bf       	out	0x3e, r29	; 62
    1c5c:	df 91       	pop	r29
    1c5e:	cf 91       	pop	r28
    1c60:	1f 91       	pop	r17
    1c62:	0f 91       	pop	r16
    1c64:	ff 90       	pop	r15
    1c66:	ef 90       	pop	r14
    1c68:	df 90       	pop	r13
    1c6a:	cf 90       	pop	r12
    1c6c:	bf 90       	pop	r11
    1c6e:	af 90       	pop	r10
    1c70:	9f 90       	pop	r9
    1c72:	8f 90       	pop	r8
    1c74:	7f 90       	pop	r7
    1c76:	6f 90       	pop	r6
    1c78:	5f 90       	pop	r5
    1c7a:	4f 90       	pop	r4
    1c7c:	3f 90       	pop	r3
    1c7e:	2f 90       	pop	r2
    1c80:	08 95       	ret

00001c82 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1c82:	cf 93       	push	r28
    1c84:	df 93       	push	r29
    1c86:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1c88:	d9 d7       	rcall	.+4018   	; 0x2c3c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1c8a:	40 91 3a 21 	lds	r20, 0x213A
    1c8e:	50 91 3b 21 	lds	r21, 0x213B
    1c92:	9e 01       	movw	r18, r28
    1c94:	24 0f       	add	r18, r20
    1c96:	35 1f       	adc	r19, r21
    1c98:	20 37       	cpi	r18, 0x70	; 112
    1c9a:	87 e1       	ldi	r24, 0x17	; 23
    1c9c:	38 07       	cpc	r19, r24
    1c9e:	58 f4       	brcc	.+22     	; 0x1cb6 <pvPortMalloc+0x34>
    1ca0:	42 17       	cp	r20, r18
    1ca2:	53 07       	cpc	r21, r19
    1ca4:	58 f4       	brcc	.+22     	; 0x1cbc <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1ca6:	ea 01       	movw	r28, r20
    1ca8:	c4 5c       	subi	r28, 0xC4	; 196
    1caa:	de 4d       	sbci	r29, 0xDE	; 222
			xNextFreeByte += xWantedSize;			
    1cac:	20 93 3a 21 	sts	0x213A, r18
    1cb0:	30 93 3b 21 	sts	0x213B, r19
    1cb4:	05 c0       	rjmp	.+10     	; 0x1cc0 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1cb6:	c0 e0       	ldi	r28, 0x00	; 0
    1cb8:	d0 e0       	ldi	r29, 0x00	; 0
    1cba:	02 c0       	rjmp	.+4      	; 0x1cc0 <pvPortMalloc+0x3e>
    1cbc:	c0 e0       	ldi	r28, 0x00	; 0
    1cbe:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1cc0:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1cc4:	ce 01       	movw	r24, r28
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	08 95       	ret

00001ccc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1ccc:	08 95       	ret

00001cce <pxPortInitialiseStack>:
    /* Should not get here. */
    return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler(void) {
    1cce:	31 e1       	ldi	r19, 0x11	; 17
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	30 83       	st	Z, r19
    1cd4:	31 97       	sbiw	r30, 0x01	; 1
    1cd6:	22 e2       	ldi	r18, 0x22	; 34
    1cd8:	20 83       	st	Z, r18
    1cda:	31 97       	sbiw	r30, 0x01	; 1
    1cdc:	a3 e3       	ldi	r26, 0x33	; 51
    1cde:	a0 83       	st	Z, r26
    1ce0:	31 97       	sbiw	r30, 0x01	; 1
    1ce2:	60 83       	st	Z, r22
    1ce4:	31 97       	sbiw	r30, 0x01	; 1
    1ce6:	70 83       	st	Z, r23
    1ce8:	31 97       	sbiw	r30, 0x01	; 1
    1cea:	10 82       	st	Z, r1
    1cec:	31 97       	sbiw	r30, 0x01	; 1
    1cee:	10 82       	st	Z, r1
    1cf0:	31 97       	sbiw	r30, 0x01	; 1
    1cf2:	60 e8       	ldi	r22, 0x80	; 128
    1cf4:	60 83       	st	Z, r22
    1cf6:	31 97       	sbiw	r30, 0x01	; 1
    1cf8:	10 82       	st	Z, r1
    1cfa:	31 97       	sbiw	r30, 0x01	; 1
    1cfc:	62 e0       	ldi	r22, 0x02	; 2
    1cfe:	60 83       	st	Z, r22
    1d00:	31 97       	sbiw	r30, 0x01	; 1
    1d02:	63 e0       	ldi	r22, 0x03	; 3
    1d04:	60 83       	st	Z, r22
    1d06:	31 97       	sbiw	r30, 0x01	; 1
    1d08:	64 e0       	ldi	r22, 0x04	; 4
    1d0a:	60 83       	st	Z, r22
    1d0c:	31 97       	sbiw	r30, 0x01	; 1
    1d0e:	65 e0       	ldi	r22, 0x05	; 5
    1d10:	60 83       	st	Z, r22
    1d12:	31 97       	sbiw	r30, 0x01	; 1
    1d14:	66 e0       	ldi	r22, 0x06	; 6
    1d16:	60 83       	st	Z, r22
    1d18:	31 97       	sbiw	r30, 0x01	; 1
    1d1a:	67 e0       	ldi	r22, 0x07	; 7
    1d1c:	60 83       	st	Z, r22
    1d1e:	31 97       	sbiw	r30, 0x01	; 1
    1d20:	68 e0       	ldi	r22, 0x08	; 8
    1d22:	60 83       	st	Z, r22
    1d24:	31 97       	sbiw	r30, 0x01	; 1
    1d26:	69 e0       	ldi	r22, 0x09	; 9
    1d28:	60 83       	st	Z, r22
    1d2a:	31 97       	sbiw	r30, 0x01	; 1
    1d2c:	60 e1       	ldi	r22, 0x10	; 16
    1d2e:	60 83       	st	Z, r22
    1d30:	31 97       	sbiw	r30, 0x01	; 1
    1d32:	30 83       	st	Z, r19
    1d34:	31 97       	sbiw	r30, 0x01	; 1
    1d36:	32 e1       	ldi	r19, 0x12	; 18
    1d38:	30 83       	st	Z, r19
    1d3a:	31 97       	sbiw	r30, 0x01	; 1
    1d3c:	33 e1       	ldi	r19, 0x13	; 19
    1d3e:	30 83       	st	Z, r19
    1d40:	31 97       	sbiw	r30, 0x01	; 1
    1d42:	34 e1       	ldi	r19, 0x14	; 20
    1d44:	30 83       	st	Z, r19
    1d46:	31 97       	sbiw	r30, 0x01	; 1
    1d48:	35 e1       	ldi	r19, 0x15	; 21
    1d4a:	30 83       	st	Z, r19
    1d4c:	31 97       	sbiw	r30, 0x01	; 1
    1d4e:	36 e1       	ldi	r19, 0x16	; 22
    1d50:	30 83       	st	Z, r19
    1d52:	31 97       	sbiw	r30, 0x01	; 1
    1d54:	37 e1       	ldi	r19, 0x17	; 23
    1d56:	30 83       	st	Z, r19
    1d58:	31 97       	sbiw	r30, 0x01	; 1
    1d5a:	38 e1       	ldi	r19, 0x18	; 24
    1d5c:	30 83       	st	Z, r19
    1d5e:	31 97       	sbiw	r30, 0x01	; 1
    1d60:	39 e1       	ldi	r19, 0x19	; 25
    1d62:	30 83       	st	Z, r19
    1d64:	31 97       	sbiw	r30, 0x01	; 1
    1d66:	30 e2       	ldi	r19, 0x20	; 32
    1d68:	30 83       	st	Z, r19
    1d6a:	31 97       	sbiw	r30, 0x01	; 1
    1d6c:	31 e2       	ldi	r19, 0x21	; 33
    1d6e:	30 83       	st	Z, r19
    1d70:	31 97       	sbiw	r30, 0x01	; 1
    1d72:	20 83       	st	Z, r18
    1d74:	31 97       	sbiw	r30, 0x01	; 1
    1d76:	23 e2       	ldi	r18, 0x23	; 35
    1d78:	20 83       	st	Z, r18
    1d7a:	31 97       	sbiw	r30, 0x01	; 1
    1d7c:	40 83       	st	Z, r20
    1d7e:	31 97       	sbiw	r30, 0x01	; 1
    1d80:	50 83       	st	Z, r21
    1d82:	31 97       	sbiw	r30, 0x01	; 1
    1d84:	26 e2       	ldi	r18, 0x26	; 38
    1d86:	20 83       	st	Z, r18
    1d88:	31 97       	sbiw	r30, 0x01	; 1
    1d8a:	27 e2       	ldi	r18, 0x27	; 39
    1d8c:	20 83       	st	Z, r18
    1d8e:	31 97       	sbiw	r30, 0x01	; 1
    1d90:	28 e2       	ldi	r18, 0x28	; 40
    1d92:	20 83       	st	Z, r18
    1d94:	31 97       	sbiw	r30, 0x01	; 1
    1d96:	29 e2       	ldi	r18, 0x29	; 41
    1d98:	20 83       	st	Z, r18
    1d9a:	31 97       	sbiw	r30, 0x01	; 1
    1d9c:	20 e3       	ldi	r18, 0x30	; 48
    1d9e:	20 83       	st	Z, r18
    1da0:	31 97       	sbiw	r30, 0x01	; 1
    1da2:	21 e3       	ldi	r18, 0x31	; 49
    1da4:	20 83       	st	Z, r18
    1da6:	87 97       	sbiw	r24, 0x27	; 39
    1da8:	08 95       	ret

00001daa <xPortStartScheduler>:
    1daa:	65 e0       	ldi	r22, 0x05	; 5
    1dac:	80 e0       	ldi	r24, 0x00	; 0
    1dae:	98 e0       	ldi	r25, 0x08	; 8
    1db0:	0e 94 ad 30 	call	0x615a	; 0x615a <TC0_ConfigClockSource>
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	92 e0       	ldi	r25, 0x02	; 2
    1db8:	e0 e0       	ldi	r30, 0x00	; 0
    1dba:	f8 e0       	ldi	r31, 0x08	; 8
    1dbc:	86 a3       	std	Z+38, r24	; 0x26
    1dbe:	97 a3       	std	Z+39, r25	; 0x27
    1dc0:	61 e0       	ldi	r22, 0x01	; 1
    1dc2:	80 e0       	ldi	r24, 0x00	; 0
    1dc4:	98 e0       	ldi	r25, 0x08	; 8
    1dc6:	0e 94 b9 30 	call	0x6172	; 0x6172 <TC0_SetOverflowIntLevel>
    1dca:	e0 ea       	ldi	r30, 0xA0	; 160
    1dcc:	f0 e0       	ldi	r31, 0x00	; 0
    1dce:	82 81       	ldd	r24, Z+2	; 0x02
    1dd0:	81 60       	ori	r24, 0x01	; 1
    1dd2:	82 83       	std	Z+2, r24	; 0x02
    1dd4:	a0 91 15 39 	lds	r26, 0x3915
    1dd8:	b0 91 16 39 	lds	r27, 0x3916
    1ddc:	cd 91       	ld	r28, X+
    1dde:	cd bf       	out	0x3d, r28	; 61
    1de0:	dd 91       	ld	r29, X+
    1de2:	de bf       	out	0x3e, r29	; 62
    1de4:	ff 91       	pop	r31
    1de6:	ef 91       	pop	r30
    1de8:	df 91       	pop	r29
    1dea:	cf 91       	pop	r28
    1dec:	bf 91       	pop	r27
    1dee:	af 91       	pop	r26
    1df0:	9f 91       	pop	r25
    1df2:	8f 91       	pop	r24
    1df4:	7f 91       	pop	r23
    1df6:	6f 91       	pop	r22
    1df8:	5f 91       	pop	r21
    1dfa:	4f 91       	pop	r20
    1dfc:	3f 91       	pop	r19
    1dfe:	2f 91       	pop	r18
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	ff 90       	pop	r15
    1e06:	ef 90       	pop	r14
    1e08:	df 90       	pop	r13
    1e0a:	cf 90       	pop	r12
    1e0c:	bf 90       	pop	r11
    1e0e:	af 90       	pop	r10
    1e10:	9f 90       	pop	r9
    1e12:	8f 90       	pop	r8
    1e14:	7f 90       	pop	r7
    1e16:	6f 90       	pop	r6
    1e18:	5f 90       	pop	r5
    1e1a:	4f 90       	pop	r4
    1e1c:	3f 90       	pop	r3
    1e1e:	2f 90       	pop	r2
    1e20:	1f 90       	pop	r1
    1e22:	0f 90       	pop	r0
    1e24:	0f be       	out	0x3f, r0	; 63
    1e26:	0f 90       	pop	r0
    1e28:	08 95       	ret
    1e2a:	81 e0       	ldi	r24, 0x01	; 1
    1e2c:	08 95       	ret

00001e2e <vPortYield>:
 * Manual context switch.  The first thing we do is save the registers so we
 * can use a naked attribute.
 */
void vPortYield(void) __attribute__ ( ( naked ) );
void vPortYield(void) {
    portSAVE_CONTEXT();
    1e2e:	0f 92       	push	r0
    1e30:	0f b6       	in	r0, 0x3f	; 63
    1e32:	f8 94       	cli
    1e34:	0f 92       	push	r0
    1e36:	1f 92       	push	r1
    1e38:	11 24       	eor	r1, r1
    1e3a:	2f 92       	push	r2
    1e3c:	3f 92       	push	r3
    1e3e:	4f 92       	push	r4
    1e40:	5f 92       	push	r5
    1e42:	6f 92       	push	r6
    1e44:	7f 92       	push	r7
    1e46:	8f 92       	push	r8
    1e48:	9f 92       	push	r9
    1e4a:	af 92       	push	r10
    1e4c:	bf 92       	push	r11
    1e4e:	cf 92       	push	r12
    1e50:	df 92       	push	r13
    1e52:	ef 92       	push	r14
    1e54:	ff 92       	push	r15
    1e56:	0f 93       	push	r16
    1e58:	1f 93       	push	r17
    1e5a:	2f 93       	push	r18
    1e5c:	3f 93       	push	r19
    1e5e:	4f 93       	push	r20
    1e60:	5f 93       	push	r21
    1e62:	6f 93       	push	r22
    1e64:	7f 93       	push	r23
    1e66:	8f 93       	push	r24
    1e68:	9f 93       	push	r25
    1e6a:	af 93       	push	r26
    1e6c:	bf 93       	push	r27
    1e6e:	cf 93       	push	r28
    1e70:	df 93       	push	r29
    1e72:	ef 93       	push	r30
    1e74:	ff 93       	push	r31
    1e76:	a0 91 15 39 	lds	r26, 0x3915
    1e7a:	b0 91 16 39 	lds	r27, 0x3916
    1e7e:	0d b6       	in	r0, 0x3d	; 61
    1e80:	0d 92       	st	X+, r0
    1e82:	0e b6       	in	r0, 0x3e	; 62
    1e84:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    1e86:	0e 94 47 18 	call	0x308e	; 0x308e <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1e8a:	a0 91 15 39 	lds	r26, 0x3915
    1e8e:	b0 91 16 39 	lds	r27, 0x3916
    1e92:	cd 91       	ld	r28, X+
    1e94:	cd bf       	out	0x3d, r28	; 61
    1e96:	dd 91       	ld	r29, X+
    1e98:	de bf       	out	0x3e, r29	; 62
    1e9a:	ff 91       	pop	r31
    1e9c:	ef 91       	pop	r30
    1e9e:	df 91       	pop	r29
    1ea0:	cf 91       	pop	r28
    1ea2:	bf 91       	pop	r27
    1ea4:	af 91       	pop	r26
    1ea6:	9f 91       	pop	r25
    1ea8:	8f 91       	pop	r24
    1eaa:	7f 91       	pop	r23
    1eac:	6f 91       	pop	r22
    1eae:	5f 91       	pop	r21
    1eb0:	4f 91       	pop	r20
    1eb2:	3f 91       	pop	r19
    1eb4:	2f 91       	pop	r18
    1eb6:	1f 91       	pop	r17
    1eb8:	0f 91       	pop	r16
    1eba:	ff 90       	pop	r15
    1ebc:	ef 90       	pop	r14
    1ebe:	df 90       	pop	r13
    1ec0:	cf 90       	pop	r12
    1ec2:	bf 90       	pop	r11
    1ec4:	af 90       	pop	r10
    1ec6:	9f 90       	pop	r9
    1ec8:	8f 90       	pop	r8
    1eca:	7f 90       	pop	r7
    1ecc:	6f 90       	pop	r6
    1ece:	5f 90       	pop	r5
    1ed0:	4f 90       	pop	r4
    1ed2:	3f 90       	pop	r3
    1ed4:	2f 90       	pop	r2
    1ed6:	1f 90       	pop	r1
    1ed8:	0f 90       	pop	r0
    1eda:	0f be       	out	0x3f, r0	; 63
    1edc:	0f 90       	pop	r0

    asm volatile ( "ret" );
    1ede:	08 95       	ret

00001ee0 <__vector_14>:
     * Context switch function used by the tick.  This must be identical to
     * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
     * difference from vPortYield() is the tick count is incremented as the
     * call comes from the tick ISR.
     */
    portSAVE_CONTEXT();
    1ee0:	0f 92       	push	r0
    1ee2:	0f b6       	in	r0, 0x3f	; 63
    1ee4:	f8 94       	cli
    1ee6:	0f 92       	push	r0
    1ee8:	1f 92       	push	r1
    1eea:	11 24       	eor	r1, r1
    1eec:	2f 92       	push	r2
    1eee:	3f 92       	push	r3
    1ef0:	4f 92       	push	r4
    1ef2:	5f 92       	push	r5
    1ef4:	6f 92       	push	r6
    1ef6:	7f 92       	push	r7
    1ef8:	8f 92       	push	r8
    1efa:	9f 92       	push	r9
    1efc:	af 92       	push	r10
    1efe:	bf 92       	push	r11
    1f00:	cf 92       	push	r12
    1f02:	df 92       	push	r13
    1f04:	ef 92       	push	r14
    1f06:	ff 92       	push	r15
    1f08:	0f 93       	push	r16
    1f0a:	1f 93       	push	r17
    1f0c:	2f 93       	push	r18
    1f0e:	3f 93       	push	r19
    1f10:	4f 93       	push	r20
    1f12:	5f 93       	push	r21
    1f14:	6f 93       	push	r22
    1f16:	7f 93       	push	r23
    1f18:	8f 93       	push	r24
    1f1a:	9f 93       	push	r25
    1f1c:	af 93       	push	r26
    1f1e:	bf 93       	push	r27
    1f20:	cf 93       	push	r28
    1f22:	df 93       	push	r29
    1f24:	ef 93       	push	r30
    1f26:	ff 93       	push	r31
    1f28:	a0 91 15 39 	lds	r26, 0x3915
    1f2c:	b0 91 16 39 	lds	r27, 0x3916
    1f30:	0d b6       	in	r0, 0x3d	; 61
    1f32:	0d 92       	st	X+, r0
    1f34:	0e b6       	in	r0, 0x3e	; 62
    1f36:	0d 92       	st	X+, r0
    xTaskIncrementTick();
    1f38:	94 d6       	rcall	.+3368   	; 0x2c62 <xTaskIncrementTick>
    vTaskSwitchContext();
    1f3a:	0e 94 47 18 	call	0x308e	; 0x308e <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1f3e:	a0 91 15 39 	lds	r26, 0x3915
    1f42:	b0 91 16 39 	lds	r27, 0x3916
    1f46:	cd 91       	ld	r28, X+
    1f48:	cd bf       	out	0x3d, r28	; 61
    1f4a:	dd 91       	ld	r29, X+
    1f4c:	de bf       	out	0x3e, r29	; 62
    1f4e:	ff 91       	pop	r31
    1f50:	ef 91       	pop	r30
    1f52:	df 91       	pop	r29
    1f54:	cf 91       	pop	r28
    1f56:	bf 91       	pop	r27
    1f58:	af 91       	pop	r26
    1f5a:	9f 91       	pop	r25
    1f5c:	8f 91       	pop	r24
    1f5e:	7f 91       	pop	r23
    1f60:	6f 91       	pop	r22
    1f62:	5f 91       	pop	r21
    1f64:	4f 91       	pop	r20
    1f66:	3f 91       	pop	r19
    1f68:	2f 91       	pop	r18
    1f6a:	1f 91       	pop	r17
    1f6c:	0f 91       	pop	r16
    1f6e:	ff 90       	pop	r15
    1f70:	ef 90       	pop	r14
    1f72:	df 90       	pop	r13
    1f74:	cf 90       	pop	r12
    1f76:	bf 90       	pop	r11
    1f78:	af 90       	pop	r10
    1f7a:	9f 90       	pop	r9
    1f7c:	8f 90       	pop	r8
    1f7e:	7f 90       	pop	r7
    1f80:	6f 90       	pop	r6
    1f82:	5f 90       	pop	r5
    1f84:	4f 90       	pop	r4
    1f86:	3f 90       	pop	r3
    1f88:	2f 90       	pop	r2
    1f8a:	1f 90       	pop	r1
    1f8c:	0f 90       	pop	r0
    1f8e:	0f be       	out	0x3f, r0	; 63
    1f90:	0f 90       	pop	r0
    asm volatile ( "reti" );
    1f92:	18 95       	reti

00001f94 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1f94:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f96:	03 96       	adiw	r24, 0x03	; 3
    1f98:	81 83       	std	Z+1, r24	; 0x01
    1f9a:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f9c:	2f ef       	ldi	r18, 0xFF	; 255
    1f9e:	3f ef       	ldi	r19, 0xFF	; 255
    1fa0:	23 83       	std	Z+3, r18	; 0x03
    1fa2:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1fa4:	85 83       	std	Z+5, r24	; 0x05
    1fa6:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1fa8:	87 83       	std	Z+7, r24	; 0x07
    1faa:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( unsigned char ) 0U;
    1fac:	10 82       	st	Z, r1
    1fae:	08 95       	ret

00001fb0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1fb0:	fc 01       	movw	r30, r24
    1fb2:	10 86       	std	Z+8, r1	; 0x08
    1fb4:	11 86       	std	Z+9, r1	; 0x09
    1fb6:	08 95       	ret

00001fb8 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1fb8:	cf 93       	push	r28
    1fba:	df 93       	push	r29
    1fbc:	9c 01       	movw	r18, r24
    1fbe:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1fc0:	dc 01       	movw	r26, r24
    1fc2:	11 96       	adiw	r26, 0x01	; 1
    1fc4:	cd 91       	ld	r28, X+
    1fc6:	dc 91       	ld	r29, X
    1fc8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1fca:	c2 83       	std	Z+2, r28	; 0x02
    1fcc:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1fce:	8c 81       	ldd	r24, Y+4	; 0x04
    1fd0:	9d 81       	ldd	r25, Y+5	; 0x05
    1fd2:	84 83       	std	Z+4, r24	; 0x04
    1fd4:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1fd6:	8c 81       	ldd	r24, Y+4	; 0x04
    1fd8:	9d 81       	ldd	r25, Y+5	; 0x05
    1fda:	dc 01       	movw	r26, r24
    1fdc:	12 96       	adiw	r26, 0x02	; 2
    1fde:	6d 93       	st	X+, r22
    1fe0:	7c 93       	st	X, r23
    1fe2:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1fe4:	6c 83       	std	Y+4, r22	; 0x04
    1fe6:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1fe8:	20 87       	std	Z+8, r18	; 0x08
    1fea:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1fec:	f9 01       	movw	r30, r18
    1fee:	80 81       	ld	r24, Z
    1ff0:	8f 5f       	subi	r24, 0xFF	; 255
    1ff2:	80 83       	st	Z, r24
}
    1ff4:	df 91       	pop	r29
    1ff6:	cf 91       	pop	r28
    1ff8:	08 95       	ret

00001ffa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1ffa:	cf 93       	push	r28
    1ffc:	df 93       	push	r29
    1ffe:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const unsigned int xValueOfInsertion = pxNewListItem->xItemValue;
    2000:	48 81       	ld	r20, Y
    2002:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2004:	4f 3f       	cpi	r20, 0xFF	; 255
    2006:	2f ef       	ldi	r18, 0xFF	; 255
    2008:	52 07       	cpc	r21, r18
    200a:	21 f4       	brne	.+8      	; 0x2014 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    200c:	fc 01       	movw	r30, r24
    200e:	a7 81       	ldd	r26, Z+7	; 0x07
    2010:	b0 85       	ldd	r27, Z+8	; 0x08
    2012:	0d c0       	rjmp	.+26     	; 0x202e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2014:	dc 01       	movw	r26, r24
    2016:	13 96       	adiw	r26, 0x03	; 3
    2018:	12 96       	adiw	r26, 0x02	; 2
    201a:	ed 91       	ld	r30, X+
    201c:	fc 91       	ld	r31, X
    201e:	13 97       	sbiw	r26, 0x03	; 3
    2020:	20 81       	ld	r18, Z
    2022:	31 81       	ldd	r19, Z+1	; 0x01
    2024:	42 17       	cp	r20, r18
    2026:	53 07       	cpc	r21, r19
    2028:	10 f0       	brcs	.+4      	; 0x202e <vListInsert+0x34>
    202a:	df 01       	movw	r26, r30
    202c:	f5 cf       	rjmp	.-22     	; 0x2018 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    202e:	12 96       	adiw	r26, 0x02	; 2
    2030:	ed 91       	ld	r30, X+
    2032:	fc 91       	ld	r31, X
    2034:	13 97       	sbiw	r26, 0x03	; 3
    2036:	ea 83       	std	Y+2, r30	; 0x02
    2038:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    203a:	c4 83       	std	Z+4, r28	; 0x04
    203c:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    203e:	ac 83       	std	Y+4, r26	; 0x04
    2040:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    2042:	12 96       	adiw	r26, 0x02	; 2
    2044:	cd 93       	st	X+, r28
    2046:	dc 93       	st	X, r29
    2048:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    204a:	88 87       	std	Y+8, r24	; 0x08
    204c:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    204e:	fc 01       	movw	r30, r24
    2050:	20 81       	ld	r18, Z
    2052:	2f 5f       	subi	r18, 0xFF	; 255
    2054:	20 83       	st	Z, r18
}
    2056:	df 91       	pop	r29
    2058:	cf 91       	pop	r28
    205a:	08 95       	ret

0000205c <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned char uxListRemove( ListItem_t * const pxItemToRemove )
{
    205c:	cf 93       	push	r28
    205e:	df 93       	push	r29
    2060:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2062:	a0 85       	ldd	r26, Z+8	; 0x08
    2064:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2066:	c2 81       	ldd	r28, Z+2	; 0x02
    2068:	d3 81       	ldd	r29, Z+3	; 0x03
    206a:	84 81       	ldd	r24, Z+4	; 0x04
    206c:	95 81       	ldd	r25, Z+5	; 0x05
    206e:	8c 83       	std	Y+4, r24	; 0x04
    2070:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2072:	c4 81       	ldd	r28, Z+4	; 0x04
    2074:	d5 81       	ldd	r29, Z+5	; 0x05
    2076:	82 81       	ldd	r24, Z+2	; 0x02
    2078:	93 81       	ldd	r25, Z+3	; 0x03
    207a:	8a 83       	std	Y+2, r24	; 0x02
    207c:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    207e:	11 96       	adiw	r26, 0x01	; 1
    2080:	cd 91       	ld	r28, X+
    2082:	dc 91       	ld	r29, X
    2084:	12 97       	sbiw	r26, 0x02	; 2
    2086:	ce 17       	cp	r28, r30
    2088:	df 07       	cpc	r29, r31
    208a:	31 f4       	brne	.+12     	; 0x2098 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    208c:	8c 81       	ldd	r24, Y+4	; 0x04
    208e:	9d 81       	ldd	r25, Y+5	; 0x05
    2090:	11 96       	adiw	r26, 0x01	; 1
    2092:	8d 93       	st	X+, r24
    2094:	9c 93       	st	X, r25
    2096:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2098:	10 86       	std	Z+8, r1	; 0x08
    209a:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    209c:	8c 91       	ld	r24, X
    209e:	81 50       	subi	r24, 0x01	; 1
    20a0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    20a2:	df 91       	pop	r29
    20a4:	cf 91       	pop	r28
    20a6:	08 95       	ret

000020a8 <prvCopyDataToQueue>:
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
}
    20a8:	1f 93       	push	r17
    20aa:	cf 93       	push	r28
    20ac:	df 93       	push	r29
    20ae:	ec 01       	movw	r28, r24
    20b0:	14 2f       	mov	r17, r20
    20b2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    20b4:	81 11       	cpse	r24, r1
    20b6:	0c c0       	rjmp	.+24     	; 0x20d0 <prvCopyDataToQueue+0x28>
    20b8:	88 81       	ld	r24, Y
    20ba:	99 81       	ldd	r25, Y+1	; 0x01
    20bc:	89 2b       	or	r24, r25
    20be:	09 f0       	breq	.+2      	; 0x20c2 <prvCopyDataToQueue+0x1a>
    20c0:	47 c0       	rjmp	.+142    	; 0x2150 <prvCopyDataToQueue+0xa8>
    20c2:	8a 81       	ldd	r24, Y+2	; 0x02
    20c4:	9b 81       	ldd	r25, Y+3	; 0x03
    20c6:	0e 94 e7 19 	call	0x33ce	; 0x33ce <xTaskPriorityDisinherit>
    20ca:	1a 82       	std	Y+2, r1	; 0x02
    20cc:	1b 82       	std	Y+3, r1	; 0x03
    20ce:	47 c0       	rjmp	.+142    	; 0x215e <prvCopyDataToQueue+0xb6>
    20d0:	41 11       	cpse	r20, r1
    20d2:	18 c0       	rjmp	.+48     	; 0x2104 <prvCopyDataToQueue+0x5c>
    20d4:	48 2f       	mov	r20, r24
    20d6:	50 e0       	ldi	r21, 0x00	; 0
    20d8:	8c 81       	ldd	r24, Y+4	; 0x04
    20da:	9d 81       	ldd	r25, Y+5	; 0x05
    20dc:	0e 94 60 41 	call	0x82c0	; 0x82c0 <memcpy>
    20e0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    20e2:	8c 81       	ldd	r24, Y+4	; 0x04
    20e4:	9d 81       	ldd	r25, Y+5	; 0x05
    20e6:	82 0f       	add	r24, r18
    20e8:	91 1d       	adc	r25, r1
    20ea:	8c 83       	std	Y+4, r24	; 0x04
    20ec:	9d 83       	std	Y+5, r25	; 0x05
    20ee:	2a 81       	ldd	r18, Y+2	; 0x02
    20f0:	3b 81       	ldd	r19, Y+3	; 0x03
    20f2:	82 17       	cp	r24, r18
    20f4:	93 07       	cpc	r25, r19
    20f6:	70 f1       	brcs	.+92     	; 0x2154 <prvCopyDataToQueue+0xac>
    20f8:	88 81       	ld	r24, Y
    20fa:	99 81       	ldd	r25, Y+1	; 0x01
    20fc:	8c 83       	std	Y+4, r24	; 0x04
    20fe:	9d 83       	std	Y+5, r25	; 0x05
    2100:	80 e0       	ldi	r24, 0x00	; 0
    2102:	2d c0       	rjmp	.+90     	; 0x215e <prvCopyDataToQueue+0xb6>
    2104:	48 2f       	mov	r20, r24
    2106:	50 e0       	ldi	r21, 0x00	; 0
    2108:	8e 81       	ldd	r24, Y+6	; 0x06
    210a:	9f 81       	ldd	r25, Y+7	; 0x07
    210c:	0e 94 60 41 	call	0x82c0	; 0x82c0 <memcpy>
    2110:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2112:	30 e0       	ldi	r19, 0x00	; 0
    2114:	31 95       	neg	r19
    2116:	21 95       	neg	r18
    2118:	31 09       	sbc	r19, r1
    211a:	8e 81       	ldd	r24, Y+6	; 0x06
    211c:	9f 81       	ldd	r25, Y+7	; 0x07
    211e:	82 0f       	add	r24, r18
    2120:	93 1f       	adc	r25, r19
    2122:	8e 83       	std	Y+6, r24	; 0x06
    2124:	9f 83       	std	Y+7, r25	; 0x07
    2126:	68 81       	ld	r22, Y
    2128:	79 81       	ldd	r23, Y+1	; 0x01
    212a:	86 17       	cp	r24, r22
    212c:	97 07       	cpc	r25, r23
    212e:	30 f4       	brcc	.+12     	; 0x213c <prvCopyDataToQueue+0x94>
    2130:	8a 81       	ldd	r24, Y+2	; 0x02
    2132:	9b 81       	ldd	r25, Y+3	; 0x03
    2134:	28 0f       	add	r18, r24
    2136:	39 1f       	adc	r19, r25
    2138:	2e 83       	std	Y+6, r18	; 0x06
    213a:	3f 83       	std	Y+7, r19	; 0x07
    213c:	12 30       	cpi	r17, 0x02	; 2
    213e:	61 f4       	brne	.+24     	; 0x2158 <prvCopyDataToQueue+0xb0>
    2140:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2142:	88 23       	and	r24, r24
    2144:	59 f0       	breq	.+22     	; 0x215c <prvCopyDataToQueue+0xb4>
    2146:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2148:	81 50       	subi	r24, 0x01	; 1
    214a:	8a 8f       	std	Y+26, r24	; 0x1a
    214c:	80 e0       	ldi	r24, 0x00	; 0
    214e:	07 c0       	rjmp	.+14     	; 0x215e <prvCopyDataToQueue+0xb6>
    2150:	80 e0       	ldi	r24, 0x00	; 0
    2152:	05 c0       	rjmp	.+10     	; 0x215e <prvCopyDataToQueue+0xb6>
    2154:	80 e0       	ldi	r24, 0x00	; 0
    2156:	03 c0       	rjmp	.+6      	; 0x215e <prvCopyDataToQueue+0xb6>
    2158:	80 e0       	ldi	r24, 0x00	; 0
    215a:	01 c0       	rjmp	.+2      	; 0x215e <prvCopyDataToQueue+0xb6>
    215c:	80 e0       	ldi	r24, 0x00	; 0
    215e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2160:	9f 5f       	subi	r25, 0xFF	; 255
    2162:	9a 8f       	std	Y+26, r25	; 0x1a
    2164:	df 91       	pop	r29
    2166:	cf 91       	pop	r28
    2168:	1f 91       	pop	r17
    216a:	08 95       	ret

0000216c <prvCopyDataFromQueue>:
    216c:	fc 01       	movw	r30, r24
    216e:	cb 01       	movw	r24, r22
    2170:	44 8d       	ldd	r20, Z+28	; 0x1c
    2172:	44 23       	and	r20, r20
    2174:	a1 f0       	breq	.+40     	; 0x219e <prvCopyDataFromQueue+0x32>
    2176:	50 e0       	ldi	r21, 0x00	; 0
    2178:	26 81       	ldd	r18, Z+6	; 0x06
    217a:	37 81       	ldd	r19, Z+7	; 0x07
    217c:	24 0f       	add	r18, r20
    217e:	35 1f       	adc	r19, r21
    2180:	26 83       	std	Z+6, r18	; 0x06
    2182:	37 83       	std	Z+7, r19	; 0x07
    2184:	62 81       	ldd	r22, Z+2	; 0x02
    2186:	73 81       	ldd	r23, Z+3	; 0x03
    2188:	26 17       	cp	r18, r22
    218a:	37 07       	cpc	r19, r23
    218c:	20 f0       	brcs	.+8      	; 0x2196 <prvCopyDataFromQueue+0x2a>
    218e:	20 81       	ld	r18, Z
    2190:	31 81       	ldd	r19, Z+1	; 0x01
    2192:	26 83       	std	Z+6, r18	; 0x06
    2194:	37 83       	std	Z+7, r19	; 0x07
    2196:	66 81       	ldd	r22, Z+6	; 0x06
    2198:	77 81       	ldd	r23, Z+7	; 0x07
    219a:	0c 94 60 41 	jmp	0x82c0	; 0x82c0 <memcpy>
    219e:	08 95       	ret

000021a0 <prvUnlockQueue>:
    21a0:	0f 93       	push	r16
    21a2:	1f 93       	push	r17
    21a4:	cf 93       	push	r28
    21a6:	df 93       	push	r29
    21a8:	ec 01       	movw	r28, r24
    21aa:	0f b6       	in	r0, 0x3f	; 63
    21ac:	f8 94       	cli
    21ae:	0f 92       	push	r0
    21b0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21b2:	88 23       	and	r24, r24
    21b4:	b1 f0       	breq	.+44     	; 0x21e2 <prvUnlockQueue+0x42>
    21b6:	89 89       	ldd	r24, Y+17	; 0x11
    21b8:	88 23       	and	r24, r24
    21ba:	99 f0       	breq	.+38     	; 0x21e2 <prvUnlockQueue+0x42>
    21bc:	8e 01       	movw	r16, r28
    21be:	0f 5e       	subi	r16, 0xEF	; 239
    21c0:	1f 4f       	sbci	r17, 0xFF	; 255
    21c2:	03 c0       	rjmp	.+6      	; 0x21ca <prvUnlockQueue+0x2a>
    21c4:	89 89       	ldd	r24, Y+17	; 0x11
    21c6:	88 23       	and	r24, r24
    21c8:	61 f0       	breq	.+24     	; 0x21e2 <prvUnlockQueue+0x42>
    21ca:	c8 01       	movw	r24, r16
    21cc:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <xTaskRemoveFromEventList>
    21d0:	81 11       	cpse	r24, r1
    21d2:	0e 94 77 19 	call	0x32ee	; 0x32ee <vTaskMissedYield>
    21d6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21d8:	81 50       	subi	r24, 0x01	; 1
    21da:	8e 8f       	std	Y+30, r24	; 0x1e
    21dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21de:	81 11       	cpse	r24, r1
    21e0:	f1 cf       	rjmp	.-30     	; 0x21c4 <prvUnlockQueue+0x24>
    21e2:	8f ef       	ldi	r24, 0xFF	; 255
    21e4:	8e 8f       	std	Y+30, r24	; 0x1e
    21e6:	0f 90       	pop	r0
    21e8:	0f be       	out	0x3f, r0	; 63
    21ea:	0f b6       	in	r0, 0x3f	; 63
    21ec:	f8 94       	cli
    21ee:	0f 92       	push	r0
    21f0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    21f2:	88 23       	and	r24, r24
    21f4:	a9 f0       	breq	.+42     	; 0x2220 <prvUnlockQueue+0x80>
    21f6:	88 85       	ldd	r24, Y+8	; 0x08
    21f8:	88 23       	and	r24, r24
    21fa:	91 f0       	breq	.+36     	; 0x2220 <prvUnlockQueue+0x80>
    21fc:	8e 01       	movw	r16, r28
    21fe:	08 5f       	subi	r16, 0xF8	; 248
    2200:	1f 4f       	sbci	r17, 0xFF	; 255
    2202:	03 c0       	rjmp	.+6      	; 0x220a <prvUnlockQueue+0x6a>
    2204:	88 85       	ldd	r24, Y+8	; 0x08
    2206:	88 23       	and	r24, r24
    2208:	59 f0       	breq	.+22     	; 0x2220 <prvUnlockQueue+0x80>
    220a:	c8 01       	movw	r24, r16
    220c:	e5 d7       	rcall	.+4042   	; 0x31d8 <xTaskRemoveFromEventList>
    220e:	81 11       	cpse	r24, r1
    2210:	0e 94 77 19 	call	0x32ee	; 0x32ee <vTaskMissedYield>
    2214:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2216:	81 50       	subi	r24, 0x01	; 1
    2218:	8d 8f       	std	Y+29, r24	; 0x1d
    221a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    221c:	81 11       	cpse	r24, r1
    221e:	f2 cf       	rjmp	.-28     	; 0x2204 <prvUnlockQueue+0x64>
    2220:	8f ef       	ldi	r24, 0xFF	; 255
    2222:	8d 8f       	std	Y+29, r24	; 0x1d
    2224:	0f 90       	pop	r0
    2226:	0f be       	out	0x3f, r0	; 63
    2228:	df 91       	pop	r29
    222a:	cf 91       	pop	r28
    222c:	1f 91       	pop	r17
    222e:	0f 91       	pop	r16
    2230:	08 95       	ret

00002232 <xQueueGenericReset>:
    2232:	cf 93       	push	r28
    2234:	df 93       	push	r29
    2236:	ec 01       	movw	r28, r24
    2238:	0f b6       	in	r0, 0x3f	; 63
    223a:	f8 94       	cli
    223c:	0f 92       	push	r0
    223e:	88 81       	ld	r24, Y
    2240:	99 81       	ldd	r25, Y+1	; 0x01
    2242:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2244:	30 e0       	ldi	r19, 0x00	; 0
    2246:	7b 8d       	ldd	r23, Y+27	; 0x1b
    2248:	72 9f       	mul	r23, r18
    224a:	a0 01       	movw	r20, r0
    224c:	73 9f       	mul	r23, r19
    224e:	50 0d       	add	r21, r0
    2250:	11 24       	eor	r1, r1
    2252:	fc 01       	movw	r30, r24
    2254:	e4 0f       	add	r30, r20
    2256:	f5 1f       	adc	r31, r21
    2258:	ea 83       	std	Y+2, r30	; 0x02
    225a:	fb 83       	std	Y+3, r31	; 0x03
    225c:	1a 8e       	std	Y+26, r1	; 0x1a
    225e:	8c 83       	std	Y+4, r24	; 0x04
    2260:	9d 83       	std	Y+5, r25	; 0x05
    2262:	42 1b       	sub	r20, r18
    2264:	53 0b       	sbc	r21, r19
    2266:	84 0f       	add	r24, r20
    2268:	95 1f       	adc	r25, r21
    226a:	8e 83       	std	Y+6, r24	; 0x06
    226c:	9f 83       	std	Y+7, r25	; 0x07
    226e:	8f ef       	ldi	r24, 0xFF	; 255
    2270:	8d 8f       	std	Y+29, r24	; 0x1d
    2272:	8e 8f       	std	Y+30, r24	; 0x1e
    2274:	61 11       	cpse	r22, r1
    2276:	0a c0       	rjmp	.+20     	; 0x228c <xQueueGenericReset+0x5a>
    2278:	88 85       	ldd	r24, Y+8	; 0x08
    227a:	88 23       	and	r24, r24
    227c:	69 f0       	breq	.+26     	; 0x2298 <xQueueGenericReset+0x66>
    227e:	ce 01       	movw	r24, r28
    2280:	08 96       	adiw	r24, 0x08	; 8
    2282:	aa d7       	rcall	.+3924   	; 0x31d8 <xTaskRemoveFromEventList>
    2284:	81 30       	cpi	r24, 0x01	; 1
    2286:	41 f4       	brne	.+16     	; 0x2298 <xQueueGenericReset+0x66>
    2288:	d2 dd       	rcall	.-1116   	; 0x1e2e <vPortYield>
    228a:	06 c0       	rjmp	.+12     	; 0x2298 <xQueueGenericReset+0x66>
    228c:	ce 01       	movw	r24, r28
    228e:	08 96       	adiw	r24, 0x08	; 8
    2290:	81 de       	rcall	.-766    	; 0x1f94 <vListInitialise>
    2292:	ce 01       	movw	r24, r28
    2294:	41 96       	adiw	r24, 0x11	; 17
    2296:	7e de       	rcall	.-772    	; 0x1f94 <vListInitialise>
    2298:	0f 90       	pop	r0
    229a:	0f be       	out	0x3f, r0	; 63
    229c:	81 e0       	ldi	r24, 0x01	; 1
    229e:	df 91       	pop	r29
    22a0:	cf 91       	pop	r28
    22a2:	08 95       	ret

000022a4 <xQueueGenericCreate>:
    22a4:	ff 92       	push	r15
    22a6:	0f 93       	push	r16
    22a8:	1f 93       	push	r17
    22aa:	cf 93       	push	r28
    22ac:	df 93       	push	r29
    22ae:	08 2f       	mov	r16, r24
    22b0:	16 2f       	mov	r17, r22
    22b2:	f4 2e       	mov	r15, r20
    22b4:	66 23       	and	r22, r22
    22b6:	c1 f0       	breq	.+48     	; 0x22e8 <xQueueGenericCreate+0x44>
    22b8:	86 9f       	mul	r24, r22
    22ba:	c0 01       	movw	r24, r0
    22bc:	11 24       	eor	r1, r1
    22be:	82 96       	adiw	r24, 0x22	; 34
    22c0:	e0 dc       	rcall	.-1600   	; 0x1c82 <pvPortMalloc>
    22c2:	ec 01       	movw	r28, r24
    22c4:	00 97       	sbiw	r24, 0x00	; 0
    22c6:	21 f4       	brne	.+8      	; 0x22d0 <xQueueGenericCreate+0x2c>
    22c8:	15 c0       	rjmp	.+42     	; 0x22f4 <xQueueGenericCreate+0x50>
    22ca:	c8 83       	st	Y, r28
    22cc:	d9 83       	std	Y+1, r29	; 0x01
    22ce:	05 c0       	rjmp	.+10     	; 0x22da <xQueueGenericCreate+0x36>
    22d0:	9c 01       	movw	r18, r24
    22d2:	2f 5d       	subi	r18, 0xDF	; 223
    22d4:	3f 4f       	sbci	r19, 0xFF	; 255
    22d6:	28 83       	st	Y, r18
    22d8:	39 83       	std	Y+1, r19	; 0x01
    22da:	0b 8f       	std	Y+27, r16	; 0x1b
    22dc:	1c 8f       	std	Y+28, r17	; 0x1c
    22de:	61 e0       	ldi	r22, 0x01	; 1
    22e0:	ce 01       	movw	r24, r28
    22e2:	a7 df       	rcall	.-178    	; 0x2232 <xQueueGenericReset>
    22e4:	f8 a2       	std	Y+32, r15	; 0x20
    22e6:	06 c0       	rjmp	.+12     	; 0x22f4 <xQueueGenericCreate+0x50>
    22e8:	81 e2       	ldi	r24, 0x21	; 33
    22ea:	90 e0       	ldi	r25, 0x00	; 0
    22ec:	ca dc       	rcall	.-1644   	; 0x1c82 <pvPortMalloc>
    22ee:	ec 01       	movw	r28, r24
    22f0:	00 97       	sbiw	r24, 0x00	; 0
    22f2:	59 f7       	brne	.-42     	; 0x22ca <xQueueGenericCreate+0x26>
    22f4:	ce 01       	movw	r24, r28
    22f6:	df 91       	pop	r29
    22f8:	cf 91       	pop	r28
    22fa:	1f 91       	pop	r17
    22fc:	0f 91       	pop	r16
    22fe:	ff 90       	pop	r15
    2300:	08 95       	ret

00002302 <xQueueGenericSend>:
    2302:	af 92       	push	r10
    2304:	bf 92       	push	r11
    2306:	cf 92       	push	r12
    2308:	df 92       	push	r13
    230a:	ef 92       	push	r14
    230c:	ff 92       	push	r15
    230e:	0f 93       	push	r16
    2310:	1f 93       	push	r17
    2312:	cf 93       	push	r28
    2314:	df 93       	push	r29
    2316:	cd b7       	in	r28, 0x3d	; 61
    2318:	de b7       	in	r29, 0x3e	; 62
    231a:	25 97       	sbiw	r28, 0x05	; 5
    231c:	cd bf       	out	0x3d, r28	; 61
    231e:	de bf       	out	0x3e, r29	; 62
    2320:	8c 01       	movw	r16, r24
    2322:	6b 01       	movw	r12, r22
    2324:	4c 83       	std	Y+4, r20	; 0x04
    2326:	5d 83       	std	Y+5, r21	; 0x05
    2328:	a2 2e       	mov	r10, r18
    232a:	b1 2c       	mov	r11, r1
    232c:	7c 01       	movw	r14, r24
    232e:	88 e0       	ldi	r24, 0x08	; 8
    2330:	e8 0e       	add	r14, r24
    2332:	f1 1c       	adc	r15, r1
    2334:	0f b6       	in	r0, 0x3f	; 63
    2336:	f8 94       	cli
    2338:	0f 92       	push	r0
    233a:	f8 01       	movw	r30, r16
    233c:	92 8d       	ldd	r25, Z+26	; 0x1a
    233e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2340:	98 17       	cp	r25, r24
    2342:	18 f0       	brcs	.+6      	; 0x234a <xQueueGenericSend+0x48>
    2344:	f2 e0       	ldi	r31, 0x02	; 2
    2346:	af 12       	cpse	r10, r31
    2348:	15 c0       	rjmp	.+42     	; 0x2374 <xQueueGenericSend+0x72>
    234a:	4a 2d       	mov	r20, r10
    234c:	b6 01       	movw	r22, r12
    234e:	c8 01       	movw	r24, r16
    2350:	ab de       	rcall	.-682    	; 0x20a8 <prvCopyDataToQueue>
    2352:	f8 01       	movw	r30, r16
    2354:	91 89       	ldd	r25, Z+17	; 0x11
    2356:	99 23       	and	r25, r25
    2358:	39 f0       	breq	.+14     	; 0x2368 <xQueueGenericSend+0x66>
    235a:	c8 01       	movw	r24, r16
    235c:	41 96       	adiw	r24, 0x11	; 17
    235e:	3c d7       	rcall	.+3704   	; 0x31d8 <xTaskRemoveFromEventList>
    2360:	81 30       	cpi	r24, 0x01	; 1
    2362:	21 f4       	brne	.+8      	; 0x236c <xQueueGenericSend+0x6a>
    2364:	64 dd       	rcall	.-1336   	; 0x1e2e <vPortYield>
    2366:	02 c0       	rjmp	.+4      	; 0x236c <xQueueGenericSend+0x6a>
    2368:	81 11       	cpse	r24, r1
    236a:	61 dd       	rcall	.-1342   	; 0x1e2e <vPortYield>
    236c:	0f 90       	pop	r0
    236e:	0f be       	out	0x3f, r0	; 63
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	47 c0       	rjmp	.+142    	; 0x2402 <xQueueGenericSend+0x100>
    2374:	ec 81       	ldd	r30, Y+4	; 0x04
    2376:	fd 81       	ldd	r31, Y+5	; 0x05
    2378:	ef 2b       	or	r30, r31
    237a:	21 f4       	brne	.+8      	; 0x2384 <xQueueGenericSend+0x82>
    237c:	0f 90       	pop	r0
    237e:	0f be       	out	0x3f, r0	; 63
    2380:	80 e0       	ldi	r24, 0x00	; 0
    2382:	3f c0       	rjmp	.+126    	; 0x2402 <xQueueGenericSend+0x100>
    2384:	b1 10       	cpse	r11, r1
    2386:	05 c0       	rjmp	.+10     	; 0x2392 <xQueueGenericSend+0x90>
    2388:	ce 01       	movw	r24, r28
    238a:	01 96       	adiw	r24, 0x01	; 1
    238c:	6d d7       	rcall	.+3802   	; 0x3268 <vTaskSetTimeOutState>
    238e:	bb 24       	eor	r11, r11
    2390:	b3 94       	inc	r11
    2392:	0f 90       	pop	r0
    2394:	0f be       	out	0x3f, r0	; 63
    2396:	52 d4       	rcall	.+2212   	; 0x2c3c <vTaskSuspendAll>
    2398:	0f b6       	in	r0, 0x3f	; 63
    239a:	f8 94       	cli
    239c:	0f 92       	push	r0
    239e:	f8 01       	movw	r30, r16
    23a0:	85 8d       	ldd	r24, Z+29	; 0x1d
    23a2:	8f 3f       	cpi	r24, 0xFF	; 255
    23a4:	09 f4       	brne	.+2      	; 0x23a8 <xQueueGenericSend+0xa6>
    23a6:	15 8e       	std	Z+29, r1	; 0x1d
    23a8:	f8 01       	movw	r30, r16
    23aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    23ac:	8f 3f       	cpi	r24, 0xFF	; 255
    23ae:	09 f4       	brne	.+2      	; 0x23b2 <xQueueGenericSend+0xb0>
    23b0:	16 8e       	std	Z+30, r1	; 0x1e
    23b2:	0f 90       	pop	r0
    23b4:	0f be       	out	0x3f, r0	; 63
    23b6:	be 01       	movw	r22, r28
    23b8:	6c 5f       	subi	r22, 0xFC	; 252
    23ba:	7f 4f       	sbci	r23, 0xFF	; 255
    23bc:	ce 01       	movw	r24, r28
    23be:	01 96       	adiw	r24, 0x01	; 1
    23c0:	5e d7       	rcall	.+3772   	; 0x327e <xTaskCheckForTimeOut>
    23c2:	81 11       	cpse	r24, r1
    23c4:	1a c0       	rjmp	.+52     	; 0x23fa <xQueueGenericSend+0xf8>
    23c6:	0f b6       	in	r0, 0x3f	; 63
    23c8:	f8 94       	cli
    23ca:	0f 92       	push	r0
    23cc:	f8 01       	movw	r30, r16
    23ce:	92 8d       	ldd	r25, Z+26	; 0x1a
    23d0:	0f 90       	pop	r0
    23d2:	0f be       	out	0x3f, r0	; 63
    23d4:	f8 01       	movw	r30, r16
    23d6:	83 8d       	ldd	r24, Z+27	; 0x1b
    23d8:	98 13       	cpse	r25, r24
    23da:	0b c0       	rjmp	.+22     	; 0x23f2 <xQueueGenericSend+0xf0>
    23dc:	6c 81       	ldd	r22, Y+4	; 0x04
    23de:	7d 81       	ldd	r23, Y+5	; 0x05
    23e0:	c7 01       	movw	r24, r14
    23e2:	b3 d6       	rcall	.+3430   	; 0x314a <vTaskPlaceOnEventList>
    23e4:	c8 01       	movw	r24, r16
    23e6:	dc de       	rcall	.-584    	; 0x21a0 <prvUnlockQueue>
    23e8:	dc d4       	rcall	.+2488   	; 0x2da2 <xTaskResumeAll>
    23ea:	81 11       	cpse	r24, r1
    23ec:	a3 cf       	rjmp	.-186    	; 0x2334 <xQueueGenericSend+0x32>
    23ee:	1f dd       	rcall	.-1474   	; 0x1e2e <vPortYield>
    23f0:	a1 cf       	rjmp	.-190    	; 0x2334 <xQueueGenericSend+0x32>
    23f2:	c8 01       	movw	r24, r16
    23f4:	d5 de       	rcall	.-598    	; 0x21a0 <prvUnlockQueue>
    23f6:	d5 d4       	rcall	.+2474   	; 0x2da2 <xTaskResumeAll>
    23f8:	9d cf       	rjmp	.-198    	; 0x2334 <xQueueGenericSend+0x32>
    23fa:	c8 01       	movw	r24, r16
    23fc:	d1 de       	rcall	.-606    	; 0x21a0 <prvUnlockQueue>
    23fe:	d1 d4       	rcall	.+2466   	; 0x2da2 <xTaskResumeAll>
    2400:	80 e0       	ldi	r24, 0x00	; 0
    2402:	25 96       	adiw	r28, 0x05	; 5
    2404:	cd bf       	out	0x3d, r28	; 61
    2406:	de bf       	out	0x3e, r29	; 62
    2408:	df 91       	pop	r29
    240a:	cf 91       	pop	r28
    240c:	1f 91       	pop	r17
    240e:	0f 91       	pop	r16
    2410:	ff 90       	pop	r15
    2412:	ef 90       	pop	r14
    2414:	df 90       	pop	r13
    2416:	cf 90       	pop	r12
    2418:	bf 90       	pop	r11
    241a:	af 90       	pop	r10
    241c:	08 95       	ret

0000241e <xQueueCreateMutex>:
    241e:	1f 93       	push	r17
    2420:	cf 93       	push	r28
    2422:	df 93       	push	r29
    2424:	18 2f       	mov	r17, r24
    2426:	81 e2       	ldi	r24, 0x21	; 33
    2428:	90 e0       	ldi	r25, 0x00	; 0
    242a:	2b dc       	rcall	.-1962   	; 0x1c82 <pvPortMalloc>
    242c:	ec 01       	movw	r28, r24
    242e:	00 97       	sbiw	r24, 0x00	; 0
    2430:	e9 f0       	breq	.+58     	; 0x246c <xQueueCreateMutex+0x4e>
    2432:	1a 82       	std	Y+2, r1	; 0x02
    2434:	1b 82       	std	Y+3, r1	; 0x03
    2436:	18 82       	st	Y, r1
    2438:	19 82       	std	Y+1, r1	; 0x01
    243a:	1c 82       	std	Y+4, r1	; 0x04
    243c:	1d 82       	std	Y+5, r1	; 0x05
    243e:	1e 82       	std	Y+6, r1	; 0x06
    2440:	1f 82       	std	Y+7, r1	; 0x07
    2442:	1a 8e       	std	Y+26, r1	; 0x1a
    2444:	81 e0       	ldi	r24, 0x01	; 1
    2446:	8b 8f       	std	Y+27, r24	; 0x1b
    2448:	1c 8e       	std	Y+28, r1	; 0x1c
    244a:	9f ef       	ldi	r25, 0xFF	; 255
    244c:	9d 8f       	std	Y+29, r25	; 0x1d
    244e:	9e 8f       	std	Y+30, r25	; 0x1e
    2450:	18 a3       	std	Y+32, r17	; 0x20
    2452:	ce 01       	movw	r24, r28
    2454:	08 96       	adiw	r24, 0x08	; 8
    2456:	9e dd       	rcall	.-1220   	; 0x1f94 <vListInitialise>
    2458:	ce 01       	movw	r24, r28
    245a:	41 96       	adiw	r24, 0x11	; 17
    245c:	9b dd       	rcall	.-1226   	; 0x1f94 <vListInitialise>
    245e:	20 e0       	ldi	r18, 0x00	; 0
    2460:	40 e0       	ldi	r20, 0x00	; 0
    2462:	50 e0       	ldi	r21, 0x00	; 0
    2464:	60 e0       	ldi	r22, 0x00	; 0
    2466:	70 e0       	ldi	r23, 0x00	; 0
    2468:	ce 01       	movw	r24, r28
    246a:	4b df       	rcall	.-362    	; 0x2302 <xQueueGenericSend>
    246c:	ce 01       	movw	r24, r28
    246e:	df 91       	pop	r29
    2470:	cf 91       	pop	r28
    2472:	1f 91       	pop	r17
    2474:	08 95       	ret

00002476 <xQueueGenericSendFromISR>:
    2476:	0f 93       	push	r16
    2478:	1f 93       	push	r17
    247a:	cf 93       	push	r28
    247c:	df 93       	push	r29
    247e:	ec 01       	movw	r28, r24
    2480:	8a 01       	movw	r16, r20
    2482:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2484:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2486:	98 17       	cp	r25, r24
    2488:	10 f0       	brcs	.+4      	; 0x248e <xQueueGenericSendFromISR+0x18>
    248a:	22 30       	cpi	r18, 0x02	; 2
    248c:	d1 f4       	brne	.+52     	; 0x24c2 <xQueueGenericSendFromISR+0x4c>
    248e:	42 2f       	mov	r20, r18
    2490:	ce 01       	movw	r24, r28
    2492:	0a de       	rcall	.-1004   	; 0x20a8 <prvCopyDataToQueue>
    2494:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2496:	8f 3f       	cpi	r24, 0xFF	; 255
    2498:	79 f4       	brne	.+30     	; 0x24b8 <xQueueGenericSendFromISR+0x42>
    249a:	89 89       	ldd	r24, Y+17	; 0x11
    249c:	88 23       	and	r24, r24
    249e:	99 f0       	breq	.+38     	; 0x24c6 <xQueueGenericSendFromISR+0x50>
    24a0:	ce 01       	movw	r24, r28
    24a2:	41 96       	adiw	r24, 0x11	; 17
    24a4:	99 d6       	rcall	.+3378   	; 0x31d8 <xTaskRemoveFromEventList>
    24a6:	88 23       	and	r24, r24
    24a8:	81 f0       	breq	.+32     	; 0x24ca <xQueueGenericSendFromISR+0x54>
    24aa:	01 15       	cp	r16, r1
    24ac:	11 05       	cpc	r17, r1
    24ae:	79 f0       	breq	.+30     	; 0x24ce <xQueueGenericSendFromISR+0x58>
    24b0:	81 e0       	ldi	r24, 0x01	; 1
    24b2:	f8 01       	movw	r30, r16
    24b4:	80 83       	st	Z, r24
    24b6:	0c c0       	rjmp	.+24     	; 0x24d0 <xQueueGenericSendFromISR+0x5a>
    24b8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    24ba:	8f 5f       	subi	r24, 0xFF	; 255
    24bc:	8e 8f       	std	Y+30, r24	; 0x1e
    24be:	81 e0       	ldi	r24, 0x01	; 1
    24c0:	07 c0       	rjmp	.+14     	; 0x24d0 <xQueueGenericSendFromISR+0x5a>
    24c2:	80 e0       	ldi	r24, 0x00	; 0
    24c4:	05 c0       	rjmp	.+10     	; 0x24d0 <xQueueGenericSendFromISR+0x5a>
    24c6:	81 e0       	ldi	r24, 0x01	; 1
    24c8:	03 c0       	rjmp	.+6      	; 0x24d0 <xQueueGenericSendFromISR+0x5a>
    24ca:	81 e0       	ldi	r24, 0x01	; 1
    24cc:	01 c0       	rjmp	.+2      	; 0x24d0 <xQueueGenericSendFromISR+0x5a>
    24ce:	81 e0       	ldi	r24, 0x01	; 1
    24d0:	df 91       	pop	r29
    24d2:	cf 91       	pop	r28
    24d4:	1f 91       	pop	r17
    24d6:	0f 91       	pop	r16
    24d8:	08 95       	ret

000024da <xQueueGenericReceive>:
    24da:	af 92       	push	r10
    24dc:	bf 92       	push	r11
    24de:	cf 92       	push	r12
    24e0:	df 92       	push	r13
    24e2:	ef 92       	push	r14
    24e4:	ff 92       	push	r15
    24e6:	0f 93       	push	r16
    24e8:	1f 93       	push	r17
    24ea:	cf 93       	push	r28
    24ec:	df 93       	push	r29
    24ee:	cd b7       	in	r28, 0x3d	; 61
    24f0:	de b7       	in	r29, 0x3e	; 62
    24f2:	25 97       	sbiw	r28, 0x05	; 5
    24f4:	cd bf       	out	0x3d, r28	; 61
    24f6:	de bf       	out	0x3e, r29	; 62
    24f8:	8c 01       	movw	r16, r24
    24fa:	6b 01       	movw	r12, r22
    24fc:	4c 83       	std	Y+4, r20	; 0x04
    24fe:	5d 83       	std	Y+5, r21	; 0x05
    2500:	b2 2e       	mov	r11, r18
    2502:	a1 2c       	mov	r10, r1
    2504:	7c 01       	movw	r14, r24
    2506:	81 e1       	ldi	r24, 0x11	; 17
    2508:	e8 0e       	add	r14, r24
    250a:	f1 1c       	adc	r15, r1
    250c:	0f b6       	in	r0, 0x3f	; 63
    250e:	f8 94       	cli
    2510:	0f 92       	push	r0
    2512:	f8 01       	movw	r30, r16
    2514:	82 8d       	ldd	r24, Z+26	; 0x1a
    2516:	88 23       	and	r24, r24
    2518:	71 f1       	breq	.+92     	; 0x2576 <xQueueGenericReceive+0x9c>
    251a:	e6 80       	ldd	r14, Z+6	; 0x06
    251c:	f7 80       	ldd	r15, Z+7	; 0x07
    251e:	b6 01       	movw	r22, r12
    2520:	c8 01       	movw	r24, r16
    2522:	24 de       	rcall	.-952    	; 0x216c <prvCopyDataFromQueue>
    2524:	b1 10       	cpse	r11, r1
    2526:	18 c0       	rjmp	.+48     	; 0x2558 <xQueueGenericReceive+0x7e>
    2528:	f8 01       	movw	r30, r16
    252a:	82 8d       	ldd	r24, Z+26	; 0x1a
    252c:	81 50       	subi	r24, 0x01	; 1
    252e:	82 8f       	std	Z+26, r24	; 0x1a
    2530:	80 81       	ld	r24, Z
    2532:	91 81       	ldd	r25, Z+1	; 0x01
    2534:	89 2b       	or	r24, r25
    2536:	29 f4       	brne	.+10     	; 0x2542 <xQueueGenericReceive+0x68>
    2538:	0e 94 26 1b 	call	0x364c	; 0x364c <pvTaskIncrementMutexHeldCount>
    253c:	f8 01       	movw	r30, r16
    253e:	82 83       	std	Z+2, r24	; 0x02
    2540:	93 83       	std	Z+3, r25	; 0x03
    2542:	f8 01       	movw	r30, r16
    2544:	80 85       	ldd	r24, Z+8	; 0x08
    2546:	88 23       	and	r24, r24
    2548:	91 f0       	breq	.+36     	; 0x256e <xQueueGenericReceive+0x94>
    254a:	c8 01       	movw	r24, r16
    254c:	08 96       	adiw	r24, 0x08	; 8
    254e:	44 d6       	rcall	.+3208   	; 0x31d8 <xTaskRemoveFromEventList>
    2550:	81 30       	cpi	r24, 0x01	; 1
    2552:	69 f4       	brne	.+26     	; 0x256e <xQueueGenericReceive+0x94>
    2554:	6c dc       	rcall	.-1832   	; 0x1e2e <vPortYield>
    2556:	0b c0       	rjmp	.+22     	; 0x256e <xQueueGenericReceive+0x94>
    2558:	f8 01       	movw	r30, r16
    255a:	e6 82       	std	Z+6, r14	; 0x06
    255c:	f7 82       	std	Z+7, r15	; 0x07
    255e:	81 89       	ldd	r24, Z+17	; 0x11
    2560:	88 23       	and	r24, r24
    2562:	29 f0       	breq	.+10     	; 0x256e <xQueueGenericReceive+0x94>
    2564:	c8 01       	movw	r24, r16
    2566:	41 96       	adiw	r24, 0x11	; 17
    2568:	37 d6       	rcall	.+3182   	; 0x31d8 <xTaskRemoveFromEventList>
    256a:	81 11       	cpse	r24, r1
    256c:	60 dc       	rcall	.-1856   	; 0x1e2e <vPortYield>
    256e:	0f 90       	pop	r0
    2570:	0f be       	out	0x3f, r0	; 63
    2572:	81 e0       	ldi	r24, 0x01	; 1
    2574:	53 c0       	rjmp	.+166    	; 0x261c <xQueueGenericReceive+0x142>
    2576:	4c 81       	ldd	r20, Y+4	; 0x04
    2578:	5d 81       	ldd	r21, Y+5	; 0x05
    257a:	45 2b       	or	r20, r21
    257c:	21 f4       	brne	.+8      	; 0x2586 <xQueueGenericReceive+0xac>
    257e:	0f 90       	pop	r0
    2580:	0f be       	out	0x3f, r0	; 63
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	4b c0       	rjmp	.+150    	; 0x261c <xQueueGenericReceive+0x142>
    2586:	a1 10       	cpse	r10, r1
    2588:	05 c0       	rjmp	.+10     	; 0x2594 <xQueueGenericReceive+0xba>
    258a:	ce 01       	movw	r24, r28
    258c:	01 96       	adiw	r24, 0x01	; 1
    258e:	6c d6       	rcall	.+3288   	; 0x3268 <vTaskSetTimeOutState>
    2590:	aa 24       	eor	r10, r10
    2592:	a3 94       	inc	r10
    2594:	0f 90       	pop	r0
    2596:	0f be       	out	0x3f, r0	; 63
    2598:	51 d3       	rcall	.+1698   	; 0x2c3c <vTaskSuspendAll>
    259a:	0f b6       	in	r0, 0x3f	; 63
    259c:	f8 94       	cli
    259e:	0f 92       	push	r0
    25a0:	f8 01       	movw	r30, r16
    25a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    25a4:	8f 3f       	cpi	r24, 0xFF	; 255
    25a6:	09 f4       	brne	.+2      	; 0x25aa <xQueueGenericReceive+0xd0>
    25a8:	15 8e       	std	Z+29, r1	; 0x1d
    25aa:	f8 01       	movw	r30, r16
    25ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    25ae:	8f 3f       	cpi	r24, 0xFF	; 255
    25b0:	09 f4       	brne	.+2      	; 0x25b4 <xQueueGenericReceive+0xda>
    25b2:	16 8e       	std	Z+30, r1	; 0x1e
    25b4:	0f 90       	pop	r0
    25b6:	0f be       	out	0x3f, r0	; 63
    25b8:	be 01       	movw	r22, r28
    25ba:	6c 5f       	subi	r22, 0xFC	; 252
    25bc:	7f 4f       	sbci	r23, 0xFF	; 255
    25be:	ce 01       	movw	r24, r28
    25c0:	01 96       	adiw	r24, 0x01	; 1
    25c2:	5d d6       	rcall	.+3258   	; 0x327e <xTaskCheckForTimeOut>
    25c4:	81 11       	cpse	r24, r1
    25c6:	26 c0       	rjmp	.+76     	; 0x2614 <xQueueGenericReceive+0x13a>
    25c8:	0f b6       	in	r0, 0x3f	; 63
    25ca:	f8 94       	cli
    25cc:	0f 92       	push	r0
    25ce:	f8 01       	movw	r30, r16
    25d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    25d2:	0f 90       	pop	r0
    25d4:	0f be       	out	0x3f, r0	; 63
    25d6:	81 11       	cpse	r24, r1
    25d8:	19 c0       	rjmp	.+50     	; 0x260c <xQueueGenericReceive+0x132>
    25da:	f8 01       	movw	r30, r16
    25dc:	80 81       	ld	r24, Z
    25de:	91 81       	ldd	r25, Z+1	; 0x01
    25e0:	89 2b       	or	r24, r25
    25e2:	49 f4       	brne	.+18     	; 0x25f6 <xQueueGenericReceive+0x11c>
    25e4:	0f b6       	in	r0, 0x3f	; 63
    25e6:	f8 94       	cli
    25e8:	0f 92       	push	r0
    25ea:	f8 01       	movw	r30, r16
    25ec:	82 81       	ldd	r24, Z+2	; 0x02
    25ee:	93 81       	ldd	r25, Z+3	; 0x03
    25f0:	90 d6       	rcall	.+3360   	; 0x3312 <vTaskPriorityInherit>
    25f2:	0f 90       	pop	r0
    25f4:	0f be       	out	0x3f, r0	; 63
    25f6:	6c 81       	ldd	r22, Y+4	; 0x04
    25f8:	7d 81       	ldd	r23, Y+5	; 0x05
    25fa:	c7 01       	movw	r24, r14
    25fc:	a6 d5       	rcall	.+2892   	; 0x314a <vTaskPlaceOnEventList>
    25fe:	c8 01       	movw	r24, r16
    2600:	cf dd       	rcall	.-1122   	; 0x21a0 <prvUnlockQueue>
    2602:	cf d3       	rcall	.+1950   	; 0x2da2 <xTaskResumeAll>
    2604:	81 11       	cpse	r24, r1
    2606:	82 cf       	rjmp	.-252    	; 0x250c <xQueueGenericReceive+0x32>
    2608:	12 dc       	rcall	.-2012   	; 0x1e2e <vPortYield>
    260a:	80 cf       	rjmp	.-256    	; 0x250c <xQueueGenericReceive+0x32>
    260c:	c8 01       	movw	r24, r16
    260e:	c8 dd       	rcall	.-1136   	; 0x21a0 <prvUnlockQueue>
    2610:	c8 d3       	rcall	.+1936   	; 0x2da2 <xTaskResumeAll>
    2612:	7c cf       	rjmp	.-264    	; 0x250c <xQueueGenericReceive+0x32>
    2614:	c8 01       	movw	r24, r16
    2616:	c4 dd       	rcall	.-1144   	; 0x21a0 <prvUnlockQueue>
    2618:	c4 d3       	rcall	.+1928   	; 0x2da2 <xTaskResumeAll>
    261a:	80 e0       	ldi	r24, 0x00	; 0
    261c:	25 96       	adiw	r28, 0x05	; 5
    261e:	cd bf       	out	0x3d, r28	; 61
    2620:	de bf       	out	0x3e, r29	; 62
    2622:	df 91       	pop	r29
    2624:	cf 91       	pop	r28
    2626:	1f 91       	pop	r17
    2628:	0f 91       	pop	r16
    262a:	ff 90       	pop	r15
    262c:	ef 90       	pop	r14
    262e:	df 90       	pop	r13
    2630:	cf 90       	pop	r12
    2632:	bf 90       	pop	r11
    2634:	af 90       	pop	r10
    2636:	08 95       	ret

00002638 <xQueueReceiveFromISR>:
    2638:	0f 93       	push	r16
    263a:	1f 93       	push	r17
    263c:	cf 93       	push	r28
    263e:	df 93       	push	r29
    2640:	ec 01       	movw	r28, r24
    2642:	8a 01       	movw	r16, r20
    2644:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2646:	88 23       	and	r24, r24
    2648:	e1 f0       	breq	.+56     	; 0x2682 <xQueueReceiveFromISR+0x4a>
    264a:	ce 01       	movw	r24, r28
    264c:	8f dd       	rcall	.-1250   	; 0x216c <prvCopyDataFromQueue>
    264e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2650:	81 50       	subi	r24, 0x01	; 1
    2652:	8a 8f       	std	Y+26, r24	; 0x1a
    2654:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2656:	8f 3f       	cpi	r24, 0xFF	; 255
    2658:	79 f4       	brne	.+30     	; 0x2678 <xQueueReceiveFromISR+0x40>
    265a:	88 85       	ldd	r24, Y+8	; 0x08
    265c:	88 23       	and	r24, r24
    265e:	99 f0       	breq	.+38     	; 0x2686 <xQueueReceiveFromISR+0x4e>
    2660:	ce 01       	movw	r24, r28
    2662:	08 96       	adiw	r24, 0x08	; 8
    2664:	b9 d5       	rcall	.+2930   	; 0x31d8 <xTaskRemoveFromEventList>
    2666:	88 23       	and	r24, r24
    2668:	81 f0       	breq	.+32     	; 0x268a <xQueueReceiveFromISR+0x52>
    266a:	01 15       	cp	r16, r1
    266c:	11 05       	cpc	r17, r1
    266e:	79 f0       	breq	.+30     	; 0x268e <xQueueReceiveFromISR+0x56>
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	f8 01       	movw	r30, r16
    2674:	80 83       	st	Z, r24
    2676:	0c c0       	rjmp	.+24     	; 0x2690 <xQueueReceiveFromISR+0x58>
    2678:	8d 8d       	ldd	r24, Y+29	; 0x1d
    267a:	8f 5f       	subi	r24, 0xFF	; 255
    267c:	8d 8f       	std	Y+29, r24	; 0x1d
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	07 c0       	rjmp	.+14     	; 0x2690 <xQueueReceiveFromISR+0x58>
    2682:	80 e0       	ldi	r24, 0x00	; 0
    2684:	05 c0       	rjmp	.+10     	; 0x2690 <xQueueReceiveFromISR+0x58>
    2686:	81 e0       	ldi	r24, 0x01	; 1
    2688:	03 c0       	rjmp	.+6      	; 0x2690 <xQueueReceiveFromISR+0x58>
    268a:	81 e0       	ldi	r24, 0x01	; 1
    268c:	01 c0       	rjmp	.+2      	; 0x2690 <xQueueReceiveFromISR+0x58>
    268e:	81 e0       	ldi	r24, 0x01	; 1
    2690:	df 91       	pop	r29
    2692:	cf 91       	pop	r28
    2694:	1f 91       	pop	r17
    2696:	0f 91       	pop	r16
    2698:	08 95       	ret

0000269a <uxQueueMessagesWaiting>:
    269a:	0f b6       	in	r0, 0x3f	; 63
    269c:	f8 94       	cli
    269e:	0f 92       	push	r0
    26a0:	fc 01       	movw	r30, r24
    26a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    26a4:	0f 90       	pop	r0
    26a6:	0f be       	out	0x3f, r0	; 63
    26a8:	08 95       	ret

000026aa <vQueueAddToRegistry>:
    26aa:	20 91 74 3c 	lds	r18, 0x3C74
    26ae:	30 91 75 3c 	lds	r19, 0x3C75
    26b2:	23 2b       	or	r18, r19
    26b4:	51 f0       	breq	.+20     	; 0x26ca <vQueueAddToRegistry+0x20>
    26b6:	e8 e7       	ldi	r30, 0x78	; 120
    26b8:	fc e3       	ldi	r31, 0x3C	; 60
    26ba:	21 e0       	ldi	r18, 0x01	; 1
    26bc:	30 e0       	ldi	r19, 0x00	; 0
    26be:	d9 01       	movw	r26, r18
    26c0:	40 81       	ld	r20, Z
    26c2:	51 81       	ldd	r21, Z+1	; 0x01
    26c4:	45 2b       	or	r20, r21
    26c6:	89 f4       	brne	.+34     	; 0x26ea <vQueueAddToRegistry+0x40>
    26c8:	02 c0       	rjmp	.+4      	; 0x26ce <vQueueAddToRegistry+0x24>
    26ca:	a0 e0       	ldi	r26, 0x00	; 0
    26cc:	b0 e0       	ldi	r27, 0x00	; 0
    26ce:	aa 0f       	add	r26, r26
    26d0:	bb 1f       	adc	r27, r27
    26d2:	aa 0f       	add	r26, r26
    26d4:	bb 1f       	adc	r27, r27
    26d6:	ac 58       	subi	r26, 0x8C	; 140
    26d8:	b3 4c       	sbci	r27, 0xC3	; 195
    26da:	6d 93       	st	X+, r22
    26dc:	7c 93       	st	X, r23
    26de:	11 97       	sbiw	r26, 0x01	; 1
    26e0:	12 96       	adiw	r26, 0x02	; 2
    26e2:	8d 93       	st	X+, r24
    26e4:	9c 93       	st	X, r25
    26e6:	13 97       	sbiw	r26, 0x03	; 3
    26e8:	08 95       	ret
    26ea:	2f 5f       	subi	r18, 0xFF	; 255
    26ec:	3f 4f       	sbci	r19, 0xFF	; 255
    26ee:	34 96       	adiw	r30, 0x04	; 4
    26f0:	25 30       	cpi	r18, 0x05	; 5
    26f2:	31 05       	cpc	r19, r1
    26f4:	21 f7       	brne	.-56     	; 0x26be <vQueueAddToRegistry+0x14>
    26f6:	08 95       	ret

000026f8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, unsigned int xTicksToWait )
	{
    26f8:	cf 93       	push	r28
    26fa:	df 93       	push	r29
    26fc:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    26fe:	0f b6       	in	r0, 0x3f	; 63
    2700:	f8 94       	cli
    2702:	0f 92       	push	r0
    2704:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2706:	8f 3f       	cpi	r24, 0xFF	; 255
    2708:	09 f4       	brne	.+2      	; 0x270c <vQueueWaitForMessageRestricted+0x14>
    270a:	1d 8e       	std	Y+29, r1	; 0x1d
    270c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    270e:	8f 3f       	cpi	r24, 0xFF	; 255
    2710:	09 f4       	brne	.+2      	; 0x2714 <vQueueWaitForMessageRestricted+0x1c>
    2712:	1e 8e       	std	Y+30, r1	; 0x1e
    2714:	0f 90       	pop	r0
    2716:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( unsigned char ) 0U )
    2718:	8a 8d       	ldd	r24, Y+26	; 0x1a
    271a:	81 11       	cpse	r24, r1
    271c:	03 c0       	rjmp	.+6      	; 0x2724 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    271e:	ce 01       	movw	r24, r28
    2720:	41 96       	adiw	r24, 0x11	; 17
    2722:	3e d5       	rcall	.+2684   	; 0x31a0 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    2724:	ce 01       	movw	r24, r28
    2726:	3c dd       	rcall	.-1416   	; 0x21a0 <prvUnlockQueue>
	}
    2728:	df 91       	pop	r29
    272a:	cf 91       	pop	r28
    272c:	08 95       	ret

0000272e <prvListTaskWithinSingleList>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( unsigned int ) configMAX_PRIORITIES - ( unsigned int ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    272e:	af 92       	push	r10
    2730:	bf 92       	push	r11
    2732:	cf 92       	push	r12
    2734:	df 92       	push	r13
    2736:	ef 92       	push	r14
    2738:	ff 92       	push	r15
    273a:	0f 93       	push	r16
    273c:	1f 93       	push	r17
    273e:	cf 93       	push	r28
    2740:	df 93       	push	r29
    2742:	a4 2e       	mov	r10, r20
    2744:	db 01       	movw	r26, r22
    2746:	2c 91       	ld	r18, X
    2748:	22 23       	and	r18, r18
    274a:	09 f4       	brne	.+2      	; 0x274e <prvListTaskWithinSingleList+0x20>
    274c:	95 c0       	rjmp	.+298    	; 0x2878 <prvListTaskWithinSingleList+0x14a>
    274e:	11 96       	adiw	r26, 0x01	; 1
    2750:	ed 91       	ld	r30, X+
    2752:	fc 91       	ld	r31, X
    2754:	12 97       	sbiw	r26, 0x02	; 2
    2756:	02 80       	ldd	r0, Z+2	; 0x02
    2758:	f3 81       	ldd	r31, Z+3	; 0x03
    275a:	e0 2d       	mov	r30, r0
    275c:	11 96       	adiw	r26, 0x01	; 1
    275e:	ed 93       	st	X+, r30
    2760:	fc 93       	st	X, r31
    2762:	12 97       	sbiw	r26, 0x02	; 2
    2764:	7b 01       	movw	r14, r22
    2766:	b3 e0       	ldi	r27, 0x03	; 3
    2768:	eb 0e       	add	r14, r27
    276a:	f1 1c       	adc	r15, r1
    276c:	ee 15       	cp	r30, r14
    276e:	ff 05       	cpc	r31, r15
    2770:	29 f4       	brne	.+10     	; 0x277c <prvListTaskWithinSingleList+0x4e>
    2772:	22 81       	ldd	r18, Z+2	; 0x02
    2774:	33 81       	ldd	r19, Z+3	; 0x03
    2776:	fb 01       	movw	r30, r22
    2778:	21 83       	std	Z+1, r18	; 0x01
    277a:	32 83       	std	Z+2, r19	; 0x02
    277c:	db 01       	movw	r26, r22
    277e:	11 96       	adiw	r26, 0x01	; 1
    2780:	ed 91       	ld	r30, X+
    2782:	fc 91       	ld	r31, X
    2784:	12 97       	sbiw	r26, 0x02	; 2
    2786:	c6 80       	ldd	r12, Z+6	; 0x06
    2788:	d7 80       	ldd	r13, Z+7	; 0x07
    278a:	50 e0       	ldi	r21, 0x00	; 0
    278c:	68 94       	set
    278e:	bb 24       	eor	r11, r11
    2790:	b1 f8       	bld	r11, 1
    2792:	db 01       	movw	r26, r22
    2794:	11 96       	adiw	r26, 0x01	; 1
    2796:	ed 91       	ld	r30, X+
    2798:	fc 91       	ld	r31, X
    279a:	12 97       	sbiw	r26, 0x02	; 2
    279c:	22 81       	ldd	r18, Z+2	; 0x02
    279e:	33 81       	ldd	r19, Z+3	; 0x03
    27a0:	11 96       	adiw	r26, 0x01	; 1
    27a2:	2d 93       	st	X+, r18
    27a4:	3c 93       	st	X, r19
    27a6:	12 97       	sbiw	r26, 0x02	; 2
    27a8:	e2 16       	cp	r14, r18
    27aa:	f3 06       	cpc	r15, r19
    27ac:	41 f4       	brne	.+16     	; 0x27be <prvListTaskWithinSingleList+0x90>
    27ae:	15 96       	adiw	r26, 0x05	; 5
    27b0:	2d 91       	ld	r18, X+
    27b2:	3c 91       	ld	r19, X
    27b4:	16 97       	sbiw	r26, 0x06	; 6
    27b6:	11 96       	adiw	r26, 0x01	; 1
    27b8:	2d 93       	st	X+, r18
    27ba:	3c 93       	st	X, r19
    27bc:	12 97       	sbiw	r26, 0x02	; 2
    27be:	db 01       	movw	r26, r22
    27c0:	11 96       	adiw	r26, 0x01	; 1
    27c2:	ed 91       	ld	r30, X+
    27c4:	fc 91       	ld	r31, X
    27c6:	12 97       	sbiw	r26, 0x02	; 2
    27c8:	c6 81       	ldd	r28, Z+6	; 0x06
    27ca:	d7 81       	ldd	r29, Z+7	; 0x07
    27cc:	25 2f       	mov	r18, r21
    27ce:	30 e0       	ldi	r19, 0x00	; 0
    27d0:	22 0f       	add	r18, r18
    27d2:	33 1f       	adc	r19, r19
    27d4:	d9 01       	movw	r26, r18
    27d6:	aa 0f       	add	r26, r26
    27d8:	bb 1f       	adc	r27, r27
    27da:	aa 0f       	add	r26, r26
    27dc:	bb 1f       	adc	r27, r27
    27de:	aa 0f       	add	r26, r26
    27e0:	bb 1f       	adc	r27, r27
    27e2:	a2 1b       	sub	r26, r18
    27e4:	b3 0b       	sbc	r27, r19
    27e6:	a8 0f       	add	r26, r24
    27e8:	b9 1f       	adc	r27, r25
    27ea:	cd 93       	st	X+, r28
    27ec:	dc 93       	st	X, r29
    27ee:	11 97       	sbiw	r26, 0x01	; 1
    27f0:	9e 01       	movw	r18, r28
    27f2:	27 5e       	subi	r18, 0xE7	; 231
    27f4:	3f 4f       	sbci	r19, 0xFF	; 255
    27f6:	12 96       	adiw	r26, 0x02	; 2
    27f8:	2d 93       	st	X+, r18
    27fa:	3c 93       	st	X, r19
    27fc:	13 97       	sbiw	r26, 0x03	; 3
    27fe:	29 a1       	ldd	r18, Y+33	; 0x21
    2800:	14 96       	adiw	r26, 0x04	; 4
    2802:	2c 93       	st	X, r18
    2804:	14 97       	sbiw	r26, 0x04	; 4
    2806:	15 96       	adiw	r26, 0x05	; 5
    2808:	ac 92       	st	X, r10
    280a:	15 97       	sbiw	r26, 0x05	; 5
    280c:	2e 89       	ldd	r18, Y+22	; 0x16
    280e:	16 96       	adiw	r26, 0x06	; 6
    2810:	2c 93       	st	X, r18
    2812:	16 97       	sbiw	r26, 0x06	; 6
    2814:	e3 e0       	ldi	r30, 0x03	; 3
    2816:	ae 12       	cpse	r10, r30
    2818:	07 c0       	rjmp	.+14     	; 0x2828 <prvListTaskWithinSingleList+0xfa>
    281a:	2c 89       	ldd	r18, Y+20	; 0x14
    281c:	3d 89       	ldd	r19, Y+21	; 0x15
    281e:	23 2b       	or	r18, r19
    2820:	19 f0       	breq	.+6      	; 0x2828 <prvListTaskWithinSingleList+0xfa>
    2822:	15 96       	adiw	r26, 0x05	; 5
    2824:	bc 92       	st	X, r11
    2826:	15 97       	sbiw	r26, 0x05	; 5
    2828:	2b a1       	ldd	r18, Y+35	; 0x23
    282a:	17 96       	adiw	r26, 0x07	; 7
    282c:	2c 93       	st	X, r18
    282e:	17 97       	sbiw	r26, 0x07	; 7
    2830:	18 96       	adiw	r26, 0x08	; 8
    2832:	1d 92       	st	X+, r1
    2834:	1d 92       	st	X+, r1
    2836:	1d 92       	st	X+, r1
    2838:	1c 92       	st	X, r1
    283a:	1b 97       	sbiw	r26, 0x0b	; 11
    283c:	ef 89       	ldd	r30, Y+23	; 0x17
    283e:	f8 8d       	ldd	r31, Y+24	; 0x18
    2840:	20 81       	ld	r18, Z
    2842:	25 3a       	cpi	r18, 0xA5	; 165
    2844:	61 f4       	brne	.+24     	; 0x285e <prvListTaskWithinSingleList+0x130>
    2846:	31 96       	adiw	r30, 0x01	; 1
    2848:	00 e0       	ldi	r16, 0x00	; 0
    284a:	10 e0       	ldi	r17, 0x00	; 0
    284c:	98 01       	movw	r18, r16
    284e:	0f 5f       	subi	r16, 0xFF	; 255
    2850:	1f 4f       	sbci	r17, 0xFF	; 255
    2852:	2f 4f       	sbci	r18, 0xFF	; 255
    2854:	3f 4f       	sbci	r19, 0xFF	; 255
    2856:	41 91       	ld	r20, Z+
    2858:	45 3a       	cpi	r20, 0xA5	; 165
    285a:	c9 f3       	breq	.-14     	; 0x284e <prvListTaskWithinSingleList+0x120>
    285c:	03 c0       	rjmp	.+6      	; 0x2864 <prvListTaskWithinSingleList+0x136>
    285e:	00 e0       	ldi	r16, 0x00	; 0
    2860:	10 e0       	ldi	r17, 0x00	; 0
    2862:	98 01       	movw	r18, r16
    2864:	1c 96       	adiw	r26, 0x0c	; 12
    2866:	0d 93       	st	X+, r16
    2868:	1c 93       	st	X, r17
    286a:	1d 97       	sbiw	r26, 0x0d	; 13
    286c:	5f 5f       	subi	r21, 0xFF	; 255
    286e:	cc 15       	cp	r28, r12
    2870:	dd 05       	cpc	r29, r13
    2872:	09 f0       	breq	.+2      	; 0x2876 <prvListTaskWithinSingleList+0x148>
    2874:	8e cf       	rjmp	.-228    	; 0x2792 <prvListTaskWithinSingleList+0x64>
    2876:	01 c0       	rjmp	.+2      	; 0x287a <prvListTaskWithinSingleList+0x14c>
    2878:	50 e0       	ldi	r21, 0x00	; 0
    287a:	85 2f       	mov	r24, r21
    287c:	df 91       	pop	r29
    287e:	cf 91       	pop	r28
    2880:	1f 91       	pop	r17
    2882:	0f 91       	pop	r16
    2884:	ff 90       	pop	r15
    2886:	ef 90       	pop	r14
    2888:	df 90       	pop	r13
    288a:	cf 90       	pop	r12
    288c:	bf 90       	pop	r11
    288e:	af 90       	pop	r10
    2890:	08 95       	ret

00002892 <prvResetNextTaskUnblockTime>:
    2892:	e0 91 d4 38 	lds	r30, 0x38D4
    2896:	f0 91 d5 38 	lds	r31, 0x38D5
    289a:	80 81       	ld	r24, Z
    289c:	81 11       	cpse	r24, r1
    289e:	07 c0       	rjmp	.+14     	; 0x28ae <prvResetNextTaskUnblockTime+0x1c>
    28a0:	8f ef       	ldi	r24, 0xFF	; 255
    28a2:	9f ef       	ldi	r25, 0xFF	; 255
    28a4:	80 93 04 20 	sts	0x2004, r24
    28a8:	90 93 05 20 	sts	0x2005, r25
    28ac:	08 95       	ret
    28ae:	e0 91 d4 38 	lds	r30, 0x38D4
    28b2:	f0 91 d5 38 	lds	r31, 0x38D5
    28b6:	05 80       	ldd	r0, Z+5	; 0x05
    28b8:	f6 81       	ldd	r31, Z+6	; 0x06
    28ba:	e0 2d       	mov	r30, r0
    28bc:	06 80       	ldd	r0, Z+6	; 0x06
    28be:	f7 81       	ldd	r31, Z+7	; 0x07
    28c0:	e0 2d       	mov	r30, r0
    28c2:	82 81       	ldd	r24, Z+2	; 0x02
    28c4:	93 81       	ldd	r25, Z+3	; 0x03
    28c6:	80 93 04 20 	sts	0x2004, r24
    28ca:	90 93 05 20 	sts	0x2005, r25
    28ce:	08 95       	ret

000028d0 <prvAddCurrentTaskToDelayedList>:
    28d0:	cf 93       	push	r28
    28d2:	df 93       	push	r29
    28d4:	ec 01       	movw	r28, r24
    28d6:	e0 91 15 39 	lds	r30, 0x3915
    28da:	f0 91 16 39 	lds	r31, 0x3916
    28de:	82 83       	std	Z+2, r24	; 0x02
    28e0:	93 83       	std	Z+3, r25	; 0x03
    28e2:	80 91 b3 38 	lds	r24, 0x38B3
    28e6:	90 91 b4 38 	lds	r25, 0x38B4
    28ea:	c8 17       	cp	r28, r24
    28ec:	d9 07       	cpc	r29, r25
    28ee:	60 f4       	brcc	.+24     	; 0x2908 <prvAddCurrentTaskToDelayedList+0x38>
    28f0:	60 91 15 39 	lds	r22, 0x3915
    28f4:	70 91 16 39 	lds	r23, 0x3916
    28f8:	80 91 d2 38 	lds	r24, 0x38D2
    28fc:	90 91 d3 38 	lds	r25, 0x38D3
    2900:	6e 5f       	subi	r22, 0xFE	; 254
    2902:	7f 4f       	sbci	r23, 0xFF	; 255
    2904:	7a db       	rcall	.-2316   	; 0x1ffa <vListInsert>
    2906:	16 c0       	rjmp	.+44     	; 0x2934 <prvAddCurrentTaskToDelayedList+0x64>
    2908:	60 91 15 39 	lds	r22, 0x3915
    290c:	70 91 16 39 	lds	r23, 0x3916
    2910:	80 91 d4 38 	lds	r24, 0x38D4
    2914:	90 91 d5 38 	lds	r25, 0x38D5
    2918:	6e 5f       	subi	r22, 0xFE	; 254
    291a:	7f 4f       	sbci	r23, 0xFF	; 255
    291c:	6e db       	rcall	.-2340   	; 0x1ffa <vListInsert>
    291e:	80 91 04 20 	lds	r24, 0x2004
    2922:	90 91 05 20 	lds	r25, 0x2005
    2926:	c8 17       	cp	r28, r24
    2928:	d9 07       	cpc	r29, r25
    292a:	20 f4       	brcc	.+8      	; 0x2934 <prvAddCurrentTaskToDelayedList+0x64>
    292c:	c0 93 04 20 	sts	0x2004, r28
    2930:	d0 93 05 20 	sts	0x2005, r29
    2934:	df 91       	pop	r29
    2936:	cf 91       	pop	r28
    2938:	08 95       	ret

0000293a <xTaskGenericCreate>:
    293a:	2f 92       	push	r2
    293c:	3f 92       	push	r3
    293e:	4f 92       	push	r4
    2940:	5f 92       	push	r5
    2942:	6f 92       	push	r6
    2944:	7f 92       	push	r7
    2946:	8f 92       	push	r8
    2948:	9f 92       	push	r9
    294a:	af 92       	push	r10
    294c:	bf 92       	push	r11
    294e:	cf 92       	push	r12
    2950:	df 92       	push	r13
    2952:	ef 92       	push	r14
    2954:	ff 92       	push	r15
    2956:	0f 93       	push	r16
    2958:	1f 93       	push	r17
    295a:	cf 93       	push	r28
    295c:	df 93       	push	r29
    295e:	3c 01       	movw	r6, r24
    2960:	5b 01       	movw	r10, r22
    2962:	4a 01       	movw	r8, r20
    2964:	29 01       	movw	r4, r18
    2966:	c1 14       	cp	r12, r1
    2968:	d1 04       	cpc	r13, r1
    296a:	31 f4       	brne	.+12     	; 0x2978 <xTaskGenericCreate+0x3e>
    296c:	ca 01       	movw	r24, r20
    296e:	89 d9       	rcall	.-3310   	; 0x1c82 <pvPortMalloc>
    2970:	6c 01       	movw	r12, r24
    2972:	00 97       	sbiw	r24, 0x00	; 0
    2974:	09 f4       	brne	.+2      	; 0x2978 <xTaskGenericCreate+0x3e>
    2976:	e0 c0       	rjmp	.+448    	; 0x2b38 <xTaskGenericCreate+0x1fe>
    2978:	8a e2       	ldi	r24, 0x2A	; 42
    297a:	90 e0       	ldi	r25, 0x00	; 0
    297c:	82 d9       	rcall	.-3324   	; 0x1c82 <pvPortMalloc>
    297e:	ec 01       	movw	r28, r24
    2980:	00 97       	sbiw	r24, 0x00	; 0
    2982:	89 f0       	breq	.+34     	; 0x29a6 <xTaskGenericCreate+0x6c>
    2984:	cf 8a       	std	Y+23, r12	; 0x17
    2986:	d8 8e       	std	Y+24, r13	; 0x18
    2988:	a4 01       	movw	r20, r8
    298a:	65 ea       	ldi	r22, 0xA5	; 165
    298c:	70 e0       	ldi	r23, 0x00	; 0
    298e:	c6 01       	movw	r24, r12
    2990:	0e 94 69 41 	call	0x82d2	; 0x82d2 <memset>
    2994:	2f 88       	ldd	r2, Y+23	; 0x17
    2996:	38 8c       	ldd	r3, Y+24	; 0x18
    2998:	d5 01       	movw	r26, r10
    299a:	8c 91       	ld	r24, X
    299c:	89 8f       	std	Y+25, r24	; 0x19
    299e:	8c 91       	ld	r24, X
    29a0:	81 11       	cpse	r24, r1
    29a2:	04 c0       	rjmp	.+8      	; 0x29ac <xTaskGenericCreate+0x72>
    29a4:	14 c0       	rjmp	.+40     	; 0x29ce <xTaskGenericCreate+0x94>
    29a6:	c6 01       	movw	r24, r12
    29a8:	91 d9       	rcall	.-3294   	; 0x1ccc <vPortFree>
    29aa:	c6 c0       	rjmp	.+396    	; 0x2b38 <xTaskGenericCreate+0x1fe>
    29ac:	ae 01       	movw	r20, r28
    29ae:	46 5e       	subi	r20, 0xE6	; 230
    29b0:	5f 4f       	sbci	r21, 0xFF	; 255
    29b2:	f5 01       	movw	r30, r10
    29b4:	31 96       	adiw	r30, 0x01	; 1
    29b6:	27 e0       	ldi	r18, 0x07	; 7
    29b8:	cf 01       	movw	r24, r30
    29ba:	31 91       	ld	r19, Z+
    29bc:	da 01       	movw	r26, r20
    29be:	3d 93       	st	X+, r19
    29c0:	ad 01       	movw	r20, r26
    29c2:	dc 01       	movw	r26, r24
    29c4:	8c 91       	ld	r24, X
    29c6:	88 23       	and	r24, r24
    29c8:	11 f0       	breq	.+4      	; 0x29ce <xTaskGenericCreate+0x94>
    29ca:	21 50       	subi	r18, 0x01	; 1
    29cc:	a9 f7       	brne	.-22     	; 0x29b8 <xTaskGenericCreate+0x7e>
    29ce:	18 a2       	std	Y+32, r1	; 0x20
    29d0:	10 2f       	mov	r17, r16
    29d2:	05 30       	cpi	r16, 0x05	; 5
    29d4:	08 f0       	brcs	.+2      	; 0x29d8 <xTaskGenericCreate+0x9e>
    29d6:	14 e0       	ldi	r17, 0x04	; 4
    29d8:	1e 8b       	std	Y+22, r17	; 0x16
    29da:	1b a3       	std	Y+35, r17	; 0x23
    29dc:	1c a2       	std	Y+36, r1	; 0x24
    29de:	6e 01       	movw	r12, r28
    29e0:	b2 e0       	ldi	r27, 0x02	; 2
    29e2:	cb 0e       	add	r12, r27
    29e4:	d1 1c       	adc	r13, r1
    29e6:	c6 01       	movw	r24, r12
    29e8:	e3 da       	rcall	.-2618   	; 0x1fb0 <vListInitialiseItem>
    29ea:	ce 01       	movw	r24, r28
    29ec:	0c 96       	adiw	r24, 0x0c	; 12
    29ee:	e0 da       	rcall	.-2624   	; 0x1fb0 <vListInitialiseItem>
    29f0:	c8 87       	std	Y+8, r28	; 0x08
    29f2:	d9 87       	std	Y+9, r29	; 0x09
    29f4:	85 e0       	ldi	r24, 0x05	; 5
    29f6:	90 e0       	ldi	r25, 0x00	; 0
    29f8:	81 1b       	sub	r24, r17
    29fa:	91 09       	sbc	r25, r1
    29fc:	8c 87       	std	Y+12, r24	; 0x0c
    29fe:	9d 87       	std	Y+13, r25	; 0x0d
    2a00:	ca 8b       	std	Y+18, r28	; 0x12
    2a02:	db 8b       	std	Y+19, r29	; 0x13
    2a04:	1d a2       	std	Y+37, r1	; 0x25
    2a06:	1e a2       	std	Y+38, r1	; 0x26
    2a08:	1f a2       	std	Y+39, r1	; 0x27
    2a0a:	18 a6       	std	Y+40, r1	; 0x28
    2a0c:	19 a6       	std	Y+41, r1	; 0x29
    2a0e:	c4 01       	movw	r24, r8
    2a10:	01 97       	sbiw	r24, 0x01	; 1
    2a12:	a2 01       	movw	r20, r4
    2a14:	b3 01       	movw	r22, r6
    2a16:	82 0d       	add	r24, r2
    2a18:	93 1d       	adc	r25, r3
    2a1a:	59 d9       	rcall	.-3406   	; 0x1cce <pxPortInitialiseStack>
    2a1c:	88 83       	st	Y, r24
    2a1e:	99 83       	std	Y+1, r25	; 0x01
    2a20:	e1 14       	cp	r14, r1
    2a22:	f1 04       	cpc	r15, r1
    2a24:	19 f0       	breq	.+6      	; 0x2a2c <xTaskGenericCreate+0xf2>
    2a26:	f7 01       	movw	r30, r14
    2a28:	c0 83       	st	Z, r28
    2a2a:	d1 83       	std	Z+1, r29	; 0x01
    2a2c:	0f b6       	in	r0, 0x3f	; 63
    2a2e:	f8 94       	cli
    2a30:	0f 92       	push	r0
    2a32:	80 91 b5 38 	lds	r24, 0x38B5
    2a36:	8f 5f       	subi	r24, 0xFF	; 255
    2a38:	80 93 b5 38 	sts	0x38B5, r24
    2a3c:	80 91 15 39 	lds	r24, 0x3915
    2a40:	90 91 16 39 	lds	r25, 0x3916
    2a44:	89 2b       	or	r24, r25
    2a46:	09 f0       	breq	.+2      	; 0x2a4a <xTaskGenericCreate+0x110>
    2a48:	39 c0       	rjmp	.+114    	; 0x2abc <xTaskGenericCreate+0x182>
    2a4a:	c0 93 15 39 	sts	0x3915, r28
    2a4e:	d0 93 16 39 	sts	0x3916, r29
    2a52:	80 91 b5 38 	lds	r24, 0x38B5
    2a56:	81 30       	cpi	r24, 0x01	; 1
    2a58:	09 f0       	breq	.+2      	; 0x2a5c <xTaskGenericCreate+0x122>
    2a5a:	3f c0       	rjmp	.+126    	; 0x2ada <xTaskGenericCreate+0x1a0>
    2a5c:	0f 2e       	mov	r0, r31
    2a5e:	f8 ee       	ldi	r31, 0xE8	; 232
    2a60:	ef 2e       	mov	r14, r31
    2a62:	f8 e3       	ldi	r31, 0x38	; 56
    2a64:	ff 2e       	mov	r15, r31
    2a66:	f0 2d       	mov	r31, r0
    2a68:	0f 2e       	mov	r0, r31
    2a6a:	f5 e1       	ldi	r31, 0x15	; 21
    2a6c:	af 2e       	mov	r10, r31
    2a6e:	f9 e3       	ldi	r31, 0x39	; 57
    2a70:	bf 2e       	mov	r11, r31
    2a72:	f0 2d       	mov	r31, r0
    2a74:	c7 01       	movw	r24, r14
    2a76:	8e da       	rcall	.-2788   	; 0x1f94 <vListInitialise>
    2a78:	f9 e0       	ldi	r31, 0x09	; 9
    2a7a:	ef 0e       	add	r14, r31
    2a7c:	f1 1c       	adc	r15, r1
    2a7e:	ea 14       	cp	r14, r10
    2a80:	fb 04       	cpc	r15, r11
    2a82:	c1 f7       	brne	.-16     	; 0x2a74 <xTaskGenericCreate+0x13a>
    2a84:	8f ed       	ldi	r24, 0xDF	; 223
    2a86:	98 e3       	ldi	r25, 0x38	; 56
    2a88:	85 da       	rcall	.-2806   	; 0x1f94 <vListInitialise>
    2a8a:	86 ed       	ldi	r24, 0xD6	; 214
    2a8c:	98 e3       	ldi	r25, 0x38	; 56
    2a8e:	82 da       	rcall	.-2812   	; 0x1f94 <vListInitialise>
    2a90:	89 ec       	ldi	r24, 0xC9	; 201
    2a92:	98 e3       	ldi	r25, 0x38	; 56
    2a94:	7f da       	rcall	.-2818   	; 0x1f94 <vListInitialise>
    2a96:	80 ec       	ldi	r24, 0xC0	; 192
    2a98:	98 e3       	ldi	r25, 0x38	; 56
    2a9a:	7c da       	rcall	.-2824   	; 0x1f94 <vListInitialise>
    2a9c:	86 eb       	ldi	r24, 0xB6	; 182
    2a9e:	98 e3       	ldi	r25, 0x38	; 56
    2aa0:	79 da       	rcall	.-2830   	; 0x1f94 <vListInitialise>
    2aa2:	8f ed       	ldi	r24, 0xDF	; 223
    2aa4:	98 e3       	ldi	r25, 0x38	; 56
    2aa6:	80 93 d4 38 	sts	0x38D4, r24
    2aaa:	90 93 d5 38 	sts	0x38D5, r25
    2aae:	86 ed       	ldi	r24, 0xD6	; 214
    2ab0:	98 e3       	ldi	r25, 0x38	; 56
    2ab2:	80 93 d2 38 	sts	0x38D2, r24
    2ab6:	90 93 d3 38 	sts	0x38D3, r25
    2aba:	0f c0       	rjmp	.+30     	; 0x2ada <xTaskGenericCreate+0x1a0>
    2abc:	80 91 b1 38 	lds	r24, 0x38B1
    2ac0:	81 11       	cpse	r24, r1
    2ac2:	0b c0       	rjmp	.+22     	; 0x2ada <xTaskGenericCreate+0x1a0>
    2ac4:	e0 91 15 39 	lds	r30, 0x3915
    2ac8:	f0 91 16 39 	lds	r31, 0x3916
    2acc:	86 89       	ldd	r24, Z+22	; 0x16
    2ace:	08 17       	cp	r16, r24
    2ad0:	20 f0       	brcs	.+8      	; 0x2ada <xTaskGenericCreate+0x1a0>
    2ad2:	c0 93 15 39 	sts	0x3915, r28
    2ad6:	d0 93 16 39 	sts	0x3916, r29
    2ada:	80 91 ad 38 	lds	r24, 0x38AD
    2ade:	8f 5f       	subi	r24, 0xFF	; 255
    2ae0:	80 93 ad 38 	sts	0x38AD, r24
    2ae4:	89 a3       	std	Y+33, r24	; 0x21
    2ae6:	8e 89       	ldd	r24, Y+22	; 0x16
    2ae8:	90 91 b2 38 	lds	r25, 0x38B2
    2aec:	98 17       	cp	r25, r24
    2aee:	10 f4       	brcc	.+4      	; 0x2af4 <xTaskGenericCreate+0x1ba>
    2af0:	80 93 b2 38 	sts	0x38B2, r24
    2af4:	90 e0       	ldi	r25, 0x00	; 0
    2af6:	9c 01       	movw	r18, r24
    2af8:	22 0f       	add	r18, r18
    2afa:	33 1f       	adc	r19, r19
    2afc:	22 0f       	add	r18, r18
    2afe:	33 1f       	adc	r19, r19
    2b00:	22 0f       	add	r18, r18
    2b02:	33 1f       	adc	r19, r19
    2b04:	82 0f       	add	r24, r18
    2b06:	93 1f       	adc	r25, r19
    2b08:	b6 01       	movw	r22, r12
    2b0a:	88 51       	subi	r24, 0x18	; 24
    2b0c:	97 4c       	sbci	r25, 0xC7	; 199
    2b0e:	54 da       	rcall	.-2904   	; 0x1fb8 <vListInsertEnd>
    2b10:	0f 90       	pop	r0
    2b12:	0f be       	out	0x3f, r0	; 63
    2b14:	80 91 b1 38 	lds	r24, 0x38B1
    2b18:	88 23       	and	r24, r24
    2b1a:	51 f0       	breq	.+20     	; 0x2b30 <xTaskGenericCreate+0x1f6>
    2b1c:	e0 91 15 39 	lds	r30, 0x3915
    2b20:	f0 91 16 39 	lds	r31, 0x3916
    2b24:	86 89       	ldd	r24, Z+22	; 0x16
    2b26:	80 17       	cp	r24, r16
    2b28:	28 f4       	brcc	.+10     	; 0x2b34 <xTaskGenericCreate+0x1fa>
    2b2a:	81 d9       	rcall	.-3326   	; 0x1e2e <vPortYield>
    2b2c:	81 e0       	ldi	r24, 0x01	; 1
    2b2e:	05 c0       	rjmp	.+10     	; 0x2b3a <xTaskGenericCreate+0x200>
    2b30:	81 e0       	ldi	r24, 0x01	; 1
    2b32:	03 c0       	rjmp	.+6      	; 0x2b3a <xTaskGenericCreate+0x200>
    2b34:	81 e0       	ldi	r24, 0x01	; 1
    2b36:	01 c0       	rjmp	.+2      	; 0x2b3a <xTaskGenericCreate+0x200>
    2b38:	8f ef       	ldi	r24, 0xFF	; 255
    2b3a:	df 91       	pop	r29
    2b3c:	cf 91       	pop	r28
    2b3e:	1f 91       	pop	r17
    2b40:	0f 91       	pop	r16
    2b42:	ff 90       	pop	r15
    2b44:	ef 90       	pop	r14
    2b46:	df 90       	pop	r13
    2b48:	cf 90       	pop	r12
    2b4a:	bf 90       	pop	r11
    2b4c:	af 90       	pop	r10
    2b4e:	9f 90       	pop	r9
    2b50:	8f 90       	pop	r8
    2b52:	7f 90       	pop	r7
    2b54:	6f 90       	pop	r6
    2b56:	5f 90       	pop	r5
    2b58:	4f 90       	pop	r4
    2b5a:	3f 90       	pop	r3
    2b5c:	2f 90       	pop	r2
    2b5e:	08 95       	ret

00002b60 <vTaskDelete>:
    2b60:	0f 93       	push	r16
    2b62:	1f 93       	push	r17
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    2b68:	ec 01       	movw	r28, r24
    2b6a:	0f b6       	in	r0, 0x3f	; 63
    2b6c:	f8 94       	cli
    2b6e:	0f 92       	push	r0
    2b70:	00 97       	sbiw	r24, 0x00	; 0
    2b72:	21 f4       	brne	.+8      	; 0x2b7c <vTaskDelete+0x1c>
    2b74:	c0 91 15 39 	lds	r28, 0x3915
    2b78:	d0 91 16 39 	lds	r29, 0x3916
    2b7c:	8e 01       	movw	r16, r28
    2b7e:	0e 5f       	subi	r16, 0xFE	; 254
    2b80:	1f 4f       	sbci	r17, 0xFF	; 255
    2b82:	c8 01       	movw	r24, r16
    2b84:	6b da       	rcall	.-2858   	; 0x205c <uxListRemove>
    2b86:	8c 89       	ldd	r24, Y+20	; 0x14
    2b88:	9d 89       	ldd	r25, Y+21	; 0x15
    2b8a:	89 2b       	or	r24, r25
    2b8c:	19 f0       	breq	.+6      	; 0x2b94 <vTaskDelete+0x34>
    2b8e:	ce 01       	movw	r24, r28
    2b90:	0c 96       	adiw	r24, 0x0c	; 12
    2b92:	64 da       	rcall	.-2872   	; 0x205c <uxListRemove>
    2b94:	b8 01       	movw	r22, r16
    2b96:	80 ec       	ldi	r24, 0xC0	; 192
    2b98:	98 e3       	ldi	r25, 0x38	; 56
    2b9a:	0e da       	rcall	.-3044   	; 0x1fb8 <vListInsertEnd>
    2b9c:	80 91 bf 38 	lds	r24, 0x38BF
    2ba0:	8f 5f       	subi	r24, 0xFF	; 255
    2ba2:	80 93 bf 38 	sts	0x38BF, r24
    2ba6:	80 91 ad 38 	lds	r24, 0x38AD
    2baa:	8f 5f       	subi	r24, 0xFF	; 255
    2bac:	80 93 ad 38 	sts	0x38AD, r24
    2bb0:	0f 90       	pop	r0
    2bb2:	0f be       	out	0x3f, r0	; 63
    2bb4:	80 91 b1 38 	lds	r24, 0x38B1
    2bb8:	88 23       	and	r24, r24
    2bba:	79 f0       	breq	.+30     	; 0x2bda <vTaskDelete+0x7a>
    2bbc:	80 91 15 39 	lds	r24, 0x3915
    2bc0:	90 91 16 39 	lds	r25, 0x3916
    2bc4:	c8 17       	cp	r28, r24
    2bc6:	d9 07       	cpc	r29, r25
    2bc8:	11 f4       	brne	.+4      	; 0x2bce <vTaskDelete+0x6e>
    2bca:	31 d9       	rcall	.-3486   	; 0x1e2e <vPortYield>
    2bcc:	06 c0       	rjmp	.+12     	; 0x2bda <vTaskDelete+0x7a>
    2bce:	0f b6       	in	r0, 0x3f	; 63
    2bd0:	f8 94       	cli
    2bd2:	0f 92       	push	r0
    2bd4:	5e de       	rcall	.-836    	; 0x2892 <prvResetNextTaskUnblockTime>
    2bd6:	0f 90       	pop	r0
    2bd8:	0f be       	out	0x3f, r0	; 63
    2bda:	df 91       	pop	r29
    2bdc:	cf 91       	pop	r28
    2bde:	1f 91       	pop	r17
    2be0:	0f 91       	pop	r16
    2be2:	08 95       	ret

00002be4 <vTaskStartScheduler>:
    2be4:	af 92       	push	r10
    2be6:	bf 92       	push	r11
    2be8:	cf 92       	push	r12
    2bea:	df 92       	push	r13
    2bec:	ef 92       	push	r14
    2bee:	ff 92       	push	r15
    2bf0:	0f 93       	push	r16
    2bf2:	a1 2c       	mov	r10, r1
    2bf4:	b1 2c       	mov	r11, r1
    2bf6:	c1 2c       	mov	r12, r1
    2bf8:	d1 2c       	mov	r13, r1
    2bfa:	e1 2c       	mov	r14, r1
    2bfc:	f1 2c       	mov	r15, r1
    2bfe:	00 e0       	ldi	r16, 0x00	; 0
    2c00:	20 e0       	ldi	r18, 0x00	; 0
    2c02:	30 e0       	ldi	r19, 0x00	; 0
    2c04:	40 e4       	ldi	r20, 0x40	; 64
    2c06:	50 e0       	ldi	r21, 0x00	; 0
    2c08:	6f e6       	ldi	r22, 0x6F	; 111
    2c0a:	70 e2       	ldi	r23, 0x20	; 32
    2c0c:	8c e6       	ldi	r24, 0x6C	; 108
    2c0e:	97 e1       	ldi	r25, 0x17	; 23
    2c10:	94 de       	rcall	.-728    	; 0x293a <xTaskGenericCreate>
    2c12:	81 30       	cpi	r24, 0x01	; 1
    2c14:	59 f4       	brne	.+22     	; 0x2c2c <vTaskStartScheduler+0x48>
    2c16:	8a d5       	rcall	.+2836   	; 0x372c <xTimerCreateTimerTask>
    2c18:	81 30       	cpi	r24, 0x01	; 1
    2c1a:	41 f4       	brne	.+16     	; 0x2c2c <vTaskStartScheduler+0x48>
    2c1c:	f8 94       	cli
    2c1e:	80 93 b1 38 	sts	0x38B1, r24
    2c22:	10 92 b3 38 	sts	0x38B3, r1
    2c26:	10 92 b4 38 	sts	0x38B4, r1
    2c2a:	bf d8       	rcall	.-3714   	; 0x1daa <xPortStartScheduler>
    2c2c:	0f 91       	pop	r16
    2c2e:	ff 90       	pop	r15
    2c30:	ef 90       	pop	r14
    2c32:	df 90       	pop	r13
    2c34:	cf 90       	pop	r12
    2c36:	bf 90       	pop	r11
    2c38:	af 90       	pop	r10
    2c3a:	08 95       	ret

00002c3c <vTaskSuspendAll>:
    2c3c:	80 91 ac 38 	lds	r24, 0x38AC
    2c40:	8f 5f       	subi	r24, 0xFF	; 255
    2c42:	80 93 ac 38 	sts	0x38AC, r24
    2c46:	08 95       	ret

00002c48 <xTaskGetTickCount>:
    2c48:	0f b6       	in	r0, 0x3f	; 63
    2c4a:	f8 94       	cli
    2c4c:	0f 92       	push	r0
    2c4e:	80 91 b3 38 	lds	r24, 0x38B3
    2c52:	90 91 b4 38 	lds	r25, 0x38B4
    2c56:	0f 90       	pop	r0
    2c58:	0f be       	out	0x3f, r0	; 63
    2c5a:	08 95       	ret

00002c5c <uxTaskGetNumberOfTasks>:
    2c5c:	80 91 b5 38 	lds	r24, 0x38B5
    2c60:	08 95       	ret

00002c62 <xTaskIncrementTick>:
    2c62:	df 92       	push	r13
    2c64:	ef 92       	push	r14
    2c66:	ff 92       	push	r15
    2c68:	0f 93       	push	r16
    2c6a:	1f 93       	push	r17
    2c6c:	cf 93       	push	r28
    2c6e:	df 93       	push	r29
    2c70:	80 91 ac 38 	lds	r24, 0x38AC
    2c74:	81 11       	cpse	r24, r1
    2c76:	7e c0       	rjmp	.+252    	; 0x2d74 <xTaskIncrementTick+0x112>
    2c78:	80 91 b3 38 	lds	r24, 0x38B3
    2c7c:	90 91 b4 38 	lds	r25, 0x38B4
    2c80:	01 96       	adiw	r24, 0x01	; 1
    2c82:	80 93 b3 38 	sts	0x38B3, r24
    2c86:	90 93 b4 38 	sts	0x38B4, r25
    2c8a:	e0 90 b3 38 	lds	r14, 0x38B3
    2c8e:	f0 90 b4 38 	lds	r15, 0x38B4
    2c92:	e1 14       	cp	r14, r1
    2c94:	f1 04       	cpc	r15, r1
    2c96:	b1 f4       	brne	.+44     	; 0x2cc4 <xTaskIncrementTick+0x62>
    2c98:	80 91 d4 38 	lds	r24, 0x38D4
    2c9c:	90 91 d5 38 	lds	r25, 0x38D5
    2ca0:	20 91 d2 38 	lds	r18, 0x38D2
    2ca4:	30 91 d3 38 	lds	r19, 0x38D3
    2ca8:	20 93 d4 38 	sts	0x38D4, r18
    2cac:	30 93 d5 38 	sts	0x38D5, r19
    2cb0:	80 93 d2 38 	sts	0x38D2, r24
    2cb4:	90 93 d3 38 	sts	0x38D3, r25
    2cb8:	80 91 ae 38 	lds	r24, 0x38AE
    2cbc:	8f 5f       	subi	r24, 0xFF	; 255
    2cbe:	80 93 ae 38 	sts	0x38AE, r24
    2cc2:	e7 dd       	rcall	.-1074   	; 0x2892 <prvResetNextTaskUnblockTime>
    2cc4:	80 91 04 20 	lds	r24, 0x2004
    2cc8:	90 91 05 20 	lds	r25, 0x2005
    2ccc:	e8 16       	cp	r14, r24
    2cce:	f9 06       	cpc	r15, r25
    2cd0:	08 f4       	brcc	.+2      	; 0x2cd4 <xTaskIncrementTick+0x72>
    2cd2:	57 c0       	rjmp	.+174    	; 0x2d82 <xTaskIncrementTick+0x120>
    2cd4:	d1 2c       	mov	r13, r1
    2cd6:	02 c0       	rjmp	.+4      	; 0x2cdc <xTaskIncrementTick+0x7a>
    2cd8:	dd 24       	eor	r13, r13
    2cda:	d3 94       	inc	r13
    2cdc:	e0 91 d4 38 	lds	r30, 0x38D4
    2ce0:	f0 91 d5 38 	lds	r31, 0x38D5
    2ce4:	80 81       	ld	r24, Z
    2ce6:	81 11       	cpse	r24, r1
    2ce8:	07 c0       	rjmp	.+14     	; 0x2cf8 <xTaskIncrementTick+0x96>
    2cea:	8f ef       	ldi	r24, 0xFF	; 255
    2cec:	9f ef       	ldi	r25, 0xFF	; 255
    2cee:	80 93 04 20 	sts	0x2004, r24
    2cf2:	90 93 05 20 	sts	0x2005, r25
    2cf6:	46 c0       	rjmp	.+140    	; 0x2d84 <xTaskIncrementTick+0x122>
    2cf8:	e0 91 d4 38 	lds	r30, 0x38D4
    2cfc:	f0 91 d5 38 	lds	r31, 0x38D5
    2d00:	05 80       	ldd	r0, Z+5	; 0x05
    2d02:	f6 81       	ldd	r31, Z+6	; 0x06
    2d04:	e0 2d       	mov	r30, r0
    2d06:	c6 81       	ldd	r28, Z+6	; 0x06
    2d08:	d7 81       	ldd	r29, Z+7	; 0x07
    2d0a:	2a 81       	ldd	r18, Y+2	; 0x02
    2d0c:	3b 81       	ldd	r19, Y+3	; 0x03
    2d0e:	e2 16       	cp	r14, r18
    2d10:	f3 06       	cpc	r15, r19
    2d12:	28 f4       	brcc	.+10     	; 0x2d1e <xTaskIncrementTick+0xbc>
    2d14:	20 93 04 20 	sts	0x2004, r18
    2d18:	30 93 05 20 	sts	0x2005, r19
    2d1c:	33 c0       	rjmp	.+102    	; 0x2d84 <xTaskIncrementTick+0x122>
    2d1e:	8e 01       	movw	r16, r28
    2d20:	0e 5f       	subi	r16, 0xFE	; 254
    2d22:	1f 4f       	sbci	r17, 0xFF	; 255
    2d24:	c8 01       	movw	r24, r16
    2d26:	9a d9       	rcall	.-3276   	; 0x205c <uxListRemove>
    2d28:	8c 89       	ldd	r24, Y+20	; 0x14
    2d2a:	9d 89       	ldd	r25, Y+21	; 0x15
    2d2c:	89 2b       	or	r24, r25
    2d2e:	19 f0       	breq	.+6      	; 0x2d36 <xTaskIncrementTick+0xd4>
    2d30:	ce 01       	movw	r24, r28
    2d32:	0c 96       	adiw	r24, 0x0c	; 12
    2d34:	93 d9       	rcall	.-3290   	; 0x205c <uxListRemove>
    2d36:	2e 89       	ldd	r18, Y+22	; 0x16
    2d38:	80 91 b2 38 	lds	r24, 0x38B2
    2d3c:	82 17       	cp	r24, r18
    2d3e:	10 f4       	brcc	.+4      	; 0x2d44 <xTaskIncrementTick+0xe2>
    2d40:	20 93 b2 38 	sts	0x38B2, r18
    2d44:	30 e0       	ldi	r19, 0x00	; 0
    2d46:	c9 01       	movw	r24, r18
    2d48:	88 0f       	add	r24, r24
    2d4a:	99 1f       	adc	r25, r25
    2d4c:	88 0f       	add	r24, r24
    2d4e:	99 1f       	adc	r25, r25
    2d50:	88 0f       	add	r24, r24
    2d52:	99 1f       	adc	r25, r25
    2d54:	82 0f       	add	r24, r18
    2d56:	93 1f       	adc	r25, r19
    2d58:	b8 01       	movw	r22, r16
    2d5a:	88 51       	subi	r24, 0x18	; 24
    2d5c:	97 4c       	sbci	r25, 0xC7	; 199
    2d5e:	2c d9       	rcall	.-3496   	; 0x1fb8 <vListInsertEnd>
    2d60:	e0 91 15 39 	lds	r30, 0x3915
    2d64:	f0 91 16 39 	lds	r31, 0x3916
    2d68:	9e 89       	ldd	r25, Y+22	; 0x16
    2d6a:	86 89       	ldd	r24, Z+22	; 0x16
    2d6c:	98 17       	cp	r25, r24
    2d6e:	08 f0       	brcs	.+2      	; 0x2d72 <xTaskIncrementTick+0x110>
    2d70:	b3 cf       	rjmp	.-154    	; 0x2cd8 <xTaskIncrementTick+0x76>
    2d72:	b4 cf       	rjmp	.-152    	; 0x2cdc <xTaskIncrementTick+0x7a>
    2d74:	80 91 b0 38 	lds	r24, 0x38B0
    2d78:	8f 5f       	subi	r24, 0xFF	; 255
    2d7a:	80 93 b0 38 	sts	0x38B0, r24
    2d7e:	d1 2c       	mov	r13, r1
    2d80:	01 c0       	rjmp	.+2      	; 0x2d84 <xTaskIncrementTick+0x122>
    2d82:	d1 2c       	mov	r13, r1
    2d84:	80 91 af 38 	lds	r24, 0x38AF
    2d88:	88 23       	and	r24, r24
    2d8a:	11 f0       	breq	.+4      	; 0x2d90 <xTaskIncrementTick+0x12e>
    2d8c:	dd 24       	eor	r13, r13
    2d8e:	d3 94       	inc	r13
    2d90:	8d 2d       	mov	r24, r13
    2d92:	df 91       	pop	r29
    2d94:	cf 91       	pop	r28
    2d96:	1f 91       	pop	r17
    2d98:	0f 91       	pop	r16
    2d9a:	ff 90       	pop	r15
    2d9c:	ef 90       	pop	r14
    2d9e:	df 90       	pop	r13
    2da0:	08 95       	ret

00002da2 <xTaskResumeAll>:
    2da2:	df 92       	push	r13
    2da4:	ef 92       	push	r14
    2da6:	ff 92       	push	r15
    2da8:	0f 93       	push	r16
    2daa:	1f 93       	push	r17
    2dac:	cf 93       	push	r28
    2dae:	df 93       	push	r29
    2db0:	0f b6       	in	r0, 0x3f	; 63
    2db2:	f8 94       	cli
    2db4:	0f 92       	push	r0
    2db6:	80 91 ac 38 	lds	r24, 0x38AC
    2dba:	81 50       	subi	r24, 0x01	; 1
    2dbc:	80 93 ac 38 	sts	0x38AC, r24
    2dc0:	80 91 ac 38 	lds	r24, 0x38AC
    2dc4:	81 11       	cpse	r24, r1
    2dc6:	5d c0       	rjmp	.+186    	; 0x2e82 <xTaskResumeAll+0xe0>
    2dc8:	80 91 b5 38 	lds	r24, 0x38B5
    2dcc:	88 23       	and	r24, r24
    2dce:	09 f4       	brne	.+2      	; 0x2dd2 <xTaskResumeAll+0x30>
    2dd0:	5a c0       	rjmp	.+180    	; 0x2e86 <xTaskResumeAll+0xe4>
    2dd2:	0f 2e       	mov	r0, r31
    2dd4:	f9 ec       	ldi	r31, 0xC9	; 201
    2dd6:	ef 2e       	mov	r14, r31
    2dd8:	f8 e3       	ldi	r31, 0x38	; 56
    2dda:	ff 2e       	mov	r15, r31
    2ddc:	f0 2d       	mov	r31, r0
    2dde:	dd 24       	eor	r13, r13
    2de0:	d3 94       	inc	r13
    2de2:	2d c0       	rjmp	.+90     	; 0x2e3e <xTaskResumeAll+0x9c>
    2de4:	e0 91 ce 38 	lds	r30, 0x38CE
    2de8:	f0 91 cf 38 	lds	r31, 0x38CF
    2dec:	c6 81       	ldd	r28, Z+6	; 0x06
    2dee:	d7 81       	ldd	r29, Z+7	; 0x07
    2df0:	ce 01       	movw	r24, r28
    2df2:	0c 96       	adiw	r24, 0x0c	; 12
    2df4:	33 d9       	rcall	.-3482   	; 0x205c <uxListRemove>
    2df6:	8e 01       	movw	r16, r28
    2df8:	0e 5f       	subi	r16, 0xFE	; 254
    2dfa:	1f 4f       	sbci	r17, 0xFF	; 255
    2dfc:	c8 01       	movw	r24, r16
    2dfe:	2e d9       	rcall	.-3492   	; 0x205c <uxListRemove>
    2e00:	8e 89       	ldd	r24, Y+22	; 0x16
    2e02:	90 91 b2 38 	lds	r25, 0x38B2
    2e06:	98 17       	cp	r25, r24
    2e08:	10 f4       	brcc	.+4      	; 0x2e0e <xTaskResumeAll+0x6c>
    2e0a:	80 93 b2 38 	sts	0x38B2, r24
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
    2e10:	9c 01       	movw	r18, r24
    2e12:	22 0f       	add	r18, r18
    2e14:	33 1f       	adc	r19, r19
    2e16:	22 0f       	add	r18, r18
    2e18:	33 1f       	adc	r19, r19
    2e1a:	22 0f       	add	r18, r18
    2e1c:	33 1f       	adc	r19, r19
    2e1e:	82 0f       	add	r24, r18
    2e20:	93 1f       	adc	r25, r19
    2e22:	b8 01       	movw	r22, r16
    2e24:	88 51       	subi	r24, 0x18	; 24
    2e26:	97 4c       	sbci	r25, 0xC7	; 199
    2e28:	c7 d8       	rcall	.-3698   	; 0x1fb8 <vListInsertEnd>
    2e2a:	e0 91 15 39 	lds	r30, 0x3915
    2e2e:	f0 91 16 39 	lds	r31, 0x3916
    2e32:	9e 89       	ldd	r25, Y+22	; 0x16
    2e34:	86 89       	ldd	r24, Z+22	; 0x16
    2e36:	98 17       	cp	r25, r24
    2e38:	10 f0       	brcs	.+4      	; 0x2e3e <xTaskResumeAll+0x9c>
    2e3a:	d0 92 af 38 	sts	0x38AF, r13
    2e3e:	f7 01       	movw	r30, r14
    2e40:	80 81       	ld	r24, Z
    2e42:	81 11       	cpse	r24, r1
    2e44:	cf cf       	rjmp	.-98     	; 0x2de4 <xTaskResumeAll+0x42>
    2e46:	80 91 b0 38 	lds	r24, 0x38B0
    2e4a:	88 23       	and	r24, r24
    2e4c:	91 f0       	breq	.+36     	; 0x2e72 <xTaskResumeAll+0xd0>
    2e4e:	80 91 b0 38 	lds	r24, 0x38B0
    2e52:	88 23       	and	r24, r24
    2e54:	71 f0       	breq	.+28     	; 0x2e72 <xTaskResumeAll+0xd0>
    2e56:	c1 e0       	ldi	r28, 0x01	; 1
    2e58:	04 df       	rcall	.-504    	; 0x2c62 <xTaskIncrementTick>
    2e5a:	81 11       	cpse	r24, r1
    2e5c:	c0 93 af 38 	sts	0x38AF, r28
    2e60:	80 91 b0 38 	lds	r24, 0x38B0
    2e64:	81 50       	subi	r24, 0x01	; 1
    2e66:	80 93 b0 38 	sts	0x38B0, r24
    2e6a:	80 91 b0 38 	lds	r24, 0x38B0
    2e6e:	81 11       	cpse	r24, r1
    2e70:	f3 cf       	rjmp	.-26     	; 0x2e58 <xTaskResumeAll+0xb6>
    2e72:	80 91 af 38 	lds	r24, 0x38AF
    2e76:	81 30       	cpi	r24, 0x01	; 1
    2e78:	41 f4       	brne	.+16     	; 0x2e8a <xTaskResumeAll+0xe8>
    2e7a:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vPortYield>
    2e7e:	81 e0       	ldi	r24, 0x01	; 1
    2e80:	05 c0       	rjmp	.+10     	; 0x2e8c <xTaskResumeAll+0xea>
    2e82:	80 e0       	ldi	r24, 0x00	; 0
    2e84:	03 c0       	rjmp	.+6      	; 0x2e8c <xTaskResumeAll+0xea>
    2e86:	80 e0       	ldi	r24, 0x00	; 0
    2e88:	01 c0       	rjmp	.+2      	; 0x2e8c <xTaskResumeAll+0xea>
    2e8a:	80 e0       	ldi	r24, 0x00	; 0
    2e8c:	0f 90       	pop	r0
    2e8e:	0f be       	out	0x3f, r0	; 63
    2e90:	df 91       	pop	r29
    2e92:	cf 91       	pop	r28
    2e94:	1f 91       	pop	r17
    2e96:	0f 91       	pop	r16
    2e98:	ff 90       	pop	r15
    2e9a:	ef 90       	pop	r14
    2e9c:	df 90       	pop	r13
    2e9e:	08 95       	ret

00002ea0 <vTaskDelay>:
    2ea0:	cf 93       	push	r28
    2ea2:	df 93       	push	r29
    2ea4:	ec 01       	movw	r28, r24
    2ea6:	00 97       	sbiw	r24, 0x00	; 0
    2ea8:	91 f0       	breq	.+36     	; 0x2ece <vTaskDelay+0x2e>
    2eaa:	c8 de       	rcall	.-624    	; 0x2c3c <vTaskSuspendAll>
    2eac:	80 91 b3 38 	lds	r24, 0x38B3
    2eb0:	90 91 b4 38 	lds	r25, 0x38B4
    2eb4:	c8 0f       	add	r28, r24
    2eb6:	d9 1f       	adc	r29, r25
    2eb8:	80 91 15 39 	lds	r24, 0x3915
    2ebc:	90 91 16 39 	lds	r25, 0x3916
    2ec0:	02 96       	adiw	r24, 0x02	; 2
    2ec2:	cc d8       	rcall	.-3688   	; 0x205c <uxListRemove>
    2ec4:	ce 01       	movw	r24, r28
    2ec6:	04 dd       	rcall	.-1528   	; 0x28d0 <prvAddCurrentTaskToDelayedList>
    2ec8:	6c df       	rcall	.-296    	; 0x2da2 <xTaskResumeAll>
    2eca:	81 11       	cpse	r24, r1
    2ecc:	02 c0       	rjmp	.+4      	; 0x2ed2 <vTaskDelay+0x32>
    2ece:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vPortYield>
    2ed2:	df 91       	pop	r29
    2ed4:	cf 91       	pop	r28
    2ed6:	08 95       	ret

00002ed8 <prvIdleTask>:
    2ed8:	0f 2e       	mov	r0, r31
    2eda:	f8 ee       	ldi	r31, 0xE8	; 232
    2edc:	ef 2e       	mov	r14, r31
    2ede:	f8 e3       	ldi	r31, 0x38	; 56
    2ee0:	ff 2e       	mov	r15, r31
    2ee2:	f0 2d       	mov	r31, r0
    2ee4:	c0 ec       	ldi	r28, 0xC0	; 192
    2ee6:	d8 e3       	ldi	r29, 0x38	; 56
    2ee8:	25 c0       	rjmp	.+74     	; 0x2f34 <prvIdleTask+0x5c>
    2eea:	a8 de       	rcall	.-688    	; 0x2c3c <vTaskSuspendAll>
    2eec:	18 81       	ld	r17, Y
    2eee:	59 df       	rcall	.-334    	; 0x2da2 <xTaskResumeAll>
    2ef0:	11 23       	and	r17, r17
    2ef2:	01 f1       	breq	.+64     	; 0x2f34 <prvIdleTask+0x5c>
    2ef4:	0f b6       	in	r0, 0x3f	; 63
    2ef6:	f8 94       	cli
    2ef8:	0f 92       	push	r0
    2efa:	e0 91 c5 38 	lds	r30, 0x38C5
    2efe:	f0 91 c6 38 	lds	r31, 0x38C6
    2f02:	06 81       	ldd	r16, Z+6	; 0x06
    2f04:	17 81       	ldd	r17, Z+7	; 0x07
    2f06:	c8 01       	movw	r24, r16
    2f08:	02 96       	adiw	r24, 0x02	; 2
    2f0a:	a8 d8       	rcall	.-3760   	; 0x205c <uxListRemove>
    2f0c:	80 91 b5 38 	lds	r24, 0x38B5
    2f10:	81 50       	subi	r24, 0x01	; 1
    2f12:	80 93 b5 38 	sts	0x38B5, r24
    2f16:	80 91 bf 38 	lds	r24, 0x38BF
    2f1a:	81 50       	subi	r24, 0x01	; 1
    2f1c:	80 93 bf 38 	sts	0x38BF, r24
    2f20:	0f 90       	pop	r0
    2f22:	0f be       	out	0x3f, r0	; 63
    2f24:	f8 01       	movw	r30, r16
    2f26:	87 89       	ldd	r24, Z+23	; 0x17
    2f28:	90 8d       	ldd	r25, Z+24	; 0x18
    2f2a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <vPortFree>
    2f2e:	c8 01       	movw	r24, r16
    2f30:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <vPortFree>
    2f34:	80 91 bf 38 	lds	r24, 0x38BF
    2f38:	81 11       	cpse	r24, r1
    2f3a:	d7 cf       	rjmp	.-82     	; 0x2eea <prvIdleTask+0x12>
    2f3c:	f7 01       	movw	r30, r14
    2f3e:	80 81       	ld	r24, Z
    2f40:	82 30       	cpi	r24, 0x02	; 2
    2f42:	c0 f3       	brcs	.-16     	; 0x2f34 <prvIdleTask+0x5c>
    2f44:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vPortYield>
    2f48:	f5 cf       	rjmp	.-22     	; 0x2f34 <prvIdleTask+0x5c>

00002f4a <uxTaskGetSystemState>:
    2f4a:	ef 92       	push	r14
    2f4c:	ff 92       	push	r15
    2f4e:	0f 93       	push	r16
    2f50:	1f 93       	push	r17
    2f52:	cf 93       	push	r28
    2f54:	df 93       	push	r29
    2f56:	ec 01       	movw	r28, r24
    2f58:	f6 2e       	mov	r15, r22
    2f5a:	8a 01       	movw	r16, r20
    2f5c:	6f de       	rcall	.-802    	; 0x2c3c <vTaskSuspendAll>
    2f5e:	80 91 b5 38 	lds	r24, 0x38B5
    2f62:	f8 16       	cp	r15, r24
    2f64:	08 f4       	brcc	.+2      	; 0x2f68 <uxTaskGetSystemState+0x1e>
    2f66:	89 c0       	rjmp	.+274    	; 0x307a <uxTaskGetSystemState+0x130>
    2f68:	0f 2e       	mov	r0, r31
    2f6a:	f5 e0       	ldi	r31, 0x05	; 5
    2f6c:	ff 2e       	mov	r15, r31
    2f6e:	f0 2d       	mov	r31, r0
    2f70:	e1 2c       	mov	r14, r1
    2f72:	fa 94       	dec	r15
    2f74:	2f 2d       	mov	r18, r15
    2f76:	30 e0       	ldi	r19, 0x00	; 0
    2f78:	b9 01       	movw	r22, r18
    2f7a:	66 0f       	add	r22, r22
    2f7c:	77 1f       	adc	r23, r23
    2f7e:	66 0f       	add	r22, r22
    2f80:	77 1f       	adc	r23, r23
    2f82:	66 0f       	add	r22, r22
    2f84:	77 1f       	adc	r23, r23
    2f86:	26 0f       	add	r18, r22
    2f88:	37 1f       	adc	r19, r23
    2f8a:	b9 01       	movw	r22, r18
    2f8c:	68 51       	subi	r22, 0x18	; 24
    2f8e:	77 4c       	sbci	r23, 0xC7	; 199
    2f90:	2e 2d       	mov	r18, r14
    2f92:	30 e0       	ldi	r19, 0x00	; 0
    2f94:	22 0f       	add	r18, r18
    2f96:	33 1f       	adc	r19, r19
    2f98:	a9 01       	movw	r20, r18
    2f9a:	44 0f       	add	r20, r20
    2f9c:	55 1f       	adc	r21, r21
    2f9e:	44 0f       	add	r20, r20
    2fa0:	55 1f       	adc	r21, r21
    2fa2:	44 0f       	add	r20, r20
    2fa4:	55 1f       	adc	r21, r21
    2fa6:	ca 01       	movw	r24, r20
    2fa8:	82 1b       	sub	r24, r18
    2faa:	93 0b       	sbc	r25, r19
    2fac:	41 e0       	ldi	r20, 0x01	; 1
    2fae:	8c 0f       	add	r24, r28
    2fb0:	9d 1f       	adc	r25, r29
    2fb2:	bd db       	rcall	.-2182   	; 0x272e <prvListTaskWithinSingleList>
    2fb4:	e8 0e       	add	r14, r24
    2fb6:	f1 10       	cpse	r15, r1
    2fb8:	dc cf       	rjmp	.-72     	; 0x2f72 <uxTaskGetSystemState+0x28>
    2fba:	60 91 d4 38 	lds	r22, 0x38D4
    2fbe:	70 91 d5 38 	lds	r23, 0x38D5
    2fc2:	2e 2d       	mov	r18, r14
    2fc4:	30 e0       	ldi	r19, 0x00	; 0
    2fc6:	22 0f       	add	r18, r18
    2fc8:	33 1f       	adc	r19, r19
    2fca:	c9 01       	movw	r24, r18
    2fcc:	88 0f       	add	r24, r24
    2fce:	99 1f       	adc	r25, r25
    2fd0:	88 0f       	add	r24, r24
    2fd2:	99 1f       	adc	r25, r25
    2fd4:	88 0f       	add	r24, r24
    2fd6:	99 1f       	adc	r25, r25
    2fd8:	82 1b       	sub	r24, r18
    2fda:	93 0b       	sbc	r25, r19
    2fdc:	42 e0       	ldi	r20, 0x02	; 2
    2fde:	8c 0f       	add	r24, r28
    2fe0:	9d 1f       	adc	r25, r29
    2fe2:	a5 db       	rcall	.-2230   	; 0x272e <prvListTaskWithinSingleList>
    2fe4:	e8 0e       	add	r14, r24
    2fe6:	60 91 d2 38 	lds	r22, 0x38D2
    2fea:	70 91 d3 38 	lds	r23, 0x38D3
    2fee:	2e 2d       	mov	r18, r14
    2ff0:	30 e0       	ldi	r19, 0x00	; 0
    2ff2:	22 0f       	add	r18, r18
    2ff4:	33 1f       	adc	r19, r19
    2ff6:	a9 01       	movw	r20, r18
    2ff8:	44 0f       	add	r20, r20
    2ffa:	55 1f       	adc	r21, r21
    2ffc:	44 0f       	add	r20, r20
    2ffe:	55 1f       	adc	r21, r21
    3000:	44 0f       	add	r20, r20
    3002:	55 1f       	adc	r21, r21
    3004:	ca 01       	movw	r24, r20
    3006:	82 1b       	sub	r24, r18
    3008:	93 0b       	sbc	r25, r19
    300a:	42 e0       	ldi	r20, 0x02	; 2
    300c:	8c 0f       	add	r24, r28
    300e:	9d 1f       	adc	r25, r29
    3010:	8e db       	rcall	.-2276   	; 0x272e <prvListTaskWithinSingleList>
    3012:	e8 0e       	add	r14, r24
    3014:	2e 2d       	mov	r18, r14
    3016:	30 e0       	ldi	r19, 0x00	; 0
    3018:	22 0f       	add	r18, r18
    301a:	33 1f       	adc	r19, r19
    301c:	a9 01       	movw	r20, r18
    301e:	44 0f       	add	r20, r20
    3020:	55 1f       	adc	r21, r21
    3022:	44 0f       	add	r20, r20
    3024:	55 1f       	adc	r21, r21
    3026:	44 0f       	add	r20, r20
    3028:	55 1f       	adc	r21, r21
    302a:	ca 01       	movw	r24, r20
    302c:	82 1b       	sub	r24, r18
    302e:	93 0b       	sbc	r25, r19
    3030:	44 e0       	ldi	r20, 0x04	; 4
    3032:	60 ec       	ldi	r22, 0xC0	; 192
    3034:	78 e3       	ldi	r23, 0x38	; 56
    3036:	8c 0f       	add	r24, r28
    3038:	9d 1f       	adc	r25, r29
    303a:	79 db       	rcall	.-2318   	; 0x272e <prvListTaskWithinSingleList>
    303c:	e8 0e       	add	r14, r24
    303e:	2e 2d       	mov	r18, r14
    3040:	30 e0       	ldi	r19, 0x00	; 0
    3042:	22 0f       	add	r18, r18
    3044:	33 1f       	adc	r19, r19
    3046:	a9 01       	movw	r20, r18
    3048:	44 0f       	add	r20, r20
    304a:	55 1f       	adc	r21, r21
    304c:	44 0f       	add	r20, r20
    304e:	55 1f       	adc	r21, r21
    3050:	44 0f       	add	r20, r20
    3052:	55 1f       	adc	r21, r21
    3054:	ca 01       	movw	r24, r20
    3056:	82 1b       	sub	r24, r18
    3058:	93 0b       	sbc	r25, r19
    305a:	43 e0       	ldi	r20, 0x03	; 3
    305c:	66 eb       	ldi	r22, 0xB6	; 182
    305e:	78 e3       	ldi	r23, 0x38	; 56
    3060:	8c 0f       	add	r24, r28
    3062:	9d 1f       	adc	r25, r29
    3064:	64 db       	rcall	.-2360   	; 0x272e <prvListTaskWithinSingleList>
    3066:	e8 0e       	add	r14, r24
    3068:	01 15       	cp	r16, r1
    306a:	11 05       	cpc	r17, r1
    306c:	39 f0       	breq	.+14     	; 0x307c <uxTaskGetSystemState+0x132>
    306e:	f8 01       	movw	r30, r16
    3070:	10 82       	st	Z, r1
    3072:	11 82       	std	Z+1, r1	; 0x01
    3074:	12 82       	std	Z+2, r1	; 0x02
    3076:	13 82       	std	Z+3, r1	; 0x03
    3078:	01 c0       	rjmp	.+2      	; 0x307c <uxTaskGetSystemState+0x132>
    307a:	e1 2c       	mov	r14, r1
    307c:	92 de       	rcall	.-732    	; 0x2da2 <xTaskResumeAll>
    307e:	8e 2d       	mov	r24, r14
    3080:	df 91       	pop	r29
    3082:	cf 91       	pop	r28
    3084:	1f 91       	pop	r17
    3086:	0f 91       	pop	r16
    3088:	ff 90       	pop	r15
    308a:	ef 90       	pop	r14
    308c:	08 95       	ret

0000308e <vTaskSwitchContext>:
    308e:	80 91 ac 38 	lds	r24, 0x38AC
    3092:	88 23       	and	r24, r24
    3094:	21 f0       	breq	.+8      	; 0x309e <vTaskSwitchContext+0x10>
    3096:	81 e0       	ldi	r24, 0x01	; 1
    3098:	80 93 af 38 	sts	0x38AF, r24
    309c:	08 95       	ret
    309e:	10 92 af 38 	sts	0x38AF, r1
    30a2:	80 91 b2 38 	lds	r24, 0x38B2
    30a6:	90 e0       	ldi	r25, 0x00	; 0
    30a8:	fc 01       	movw	r30, r24
    30aa:	ee 0f       	add	r30, r30
    30ac:	ff 1f       	adc	r31, r31
    30ae:	ee 0f       	add	r30, r30
    30b0:	ff 1f       	adc	r31, r31
    30b2:	ee 0f       	add	r30, r30
    30b4:	ff 1f       	adc	r31, r31
    30b6:	8e 0f       	add	r24, r30
    30b8:	9f 1f       	adc	r25, r31
    30ba:	fc 01       	movw	r30, r24
    30bc:	e8 51       	subi	r30, 0x18	; 24
    30be:	f7 4c       	sbci	r31, 0xC7	; 199
    30c0:	80 81       	ld	r24, Z
    30c2:	81 11       	cpse	r24, r1
    30c4:	17 c0       	rjmp	.+46     	; 0x30f4 <vTaskSwitchContext+0x66>
    30c6:	80 91 b2 38 	lds	r24, 0x38B2
    30ca:	81 50       	subi	r24, 0x01	; 1
    30cc:	80 93 b2 38 	sts	0x38B2, r24
    30d0:	80 91 b2 38 	lds	r24, 0x38B2
    30d4:	90 e0       	ldi	r25, 0x00	; 0
    30d6:	fc 01       	movw	r30, r24
    30d8:	ee 0f       	add	r30, r30
    30da:	ff 1f       	adc	r31, r31
    30dc:	ee 0f       	add	r30, r30
    30de:	ff 1f       	adc	r31, r31
    30e0:	ee 0f       	add	r30, r30
    30e2:	ff 1f       	adc	r31, r31
    30e4:	8e 0f       	add	r24, r30
    30e6:	9f 1f       	adc	r25, r31
    30e8:	fc 01       	movw	r30, r24
    30ea:	e8 51       	subi	r30, 0x18	; 24
    30ec:	f7 4c       	sbci	r31, 0xC7	; 199
    30ee:	80 81       	ld	r24, Z
    30f0:	88 23       	and	r24, r24
    30f2:	49 f3       	breq	.-46     	; 0x30c6 <vTaskSwitchContext+0x38>
    30f4:	e0 91 b2 38 	lds	r30, 0x38B2
    30f8:	f0 e0       	ldi	r31, 0x00	; 0
    30fa:	cf 01       	movw	r24, r30
    30fc:	88 0f       	add	r24, r24
    30fe:	99 1f       	adc	r25, r25
    3100:	88 0f       	add	r24, r24
    3102:	99 1f       	adc	r25, r25
    3104:	88 0f       	add	r24, r24
    3106:	99 1f       	adc	r25, r25
    3108:	e8 0f       	add	r30, r24
    310a:	f9 1f       	adc	r31, r25
    310c:	e8 51       	subi	r30, 0x18	; 24
    310e:	f7 4c       	sbci	r31, 0xC7	; 199
    3110:	a1 81       	ldd	r26, Z+1	; 0x01
    3112:	b2 81       	ldd	r27, Z+2	; 0x02
    3114:	12 96       	adiw	r26, 0x02	; 2
    3116:	0d 90       	ld	r0, X+
    3118:	bc 91       	ld	r27, X
    311a:	a0 2d       	mov	r26, r0
    311c:	a1 83       	std	Z+1, r26	; 0x01
    311e:	b2 83       	std	Z+2, r27	; 0x02
    3120:	cf 01       	movw	r24, r30
    3122:	03 96       	adiw	r24, 0x03	; 3
    3124:	a8 17       	cp	r26, r24
    3126:	b9 07       	cpc	r27, r25
    3128:	31 f4       	brne	.+12     	; 0x3136 <vTaskSwitchContext+0xa8>
    312a:	12 96       	adiw	r26, 0x02	; 2
    312c:	8d 91       	ld	r24, X+
    312e:	9c 91       	ld	r25, X
    3130:	13 97       	sbiw	r26, 0x03	; 3
    3132:	81 83       	std	Z+1, r24	; 0x01
    3134:	92 83       	std	Z+2, r25	; 0x02
    3136:	01 80       	ldd	r0, Z+1	; 0x01
    3138:	f2 81       	ldd	r31, Z+2	; 0x02
    313a:	e0 2d       	mov	r30, r0
    313c:	86 81       	ldd	r24, Z+6	; 0x06
    313e:	97 81       	ldd	r25, Z+7	; 0x07
    3140:	80 93 15 39 	sts	0x3915, r24
    3144:	90 93 16 39 	sts	0x3916, r25
    3148:	08 95       	ret

0000314a <vTaskPlaceOnEventList>:
    314a:	cf 93       	push	r28
    314c:	df 93       	push	r29
    314e:	eb 01       	movw	r28, r22
    3150:	60 91 15 39 	lds	r22, 0x3915
    3154:	70 91 16 39 	lds	r23, 0x3916
    3158:	64 5f       	subi	r22, 0xF4	; 244
    315a:	7f 4f       	sbci	r23, 0xFF	; 255
    315c:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <vListInsert>
    3160:	80 91 15 39 	lds	r24, 0x3915
    3164:	90 91 16 39 	lds	r25, 0x3916
    3168:	02 96       	adiw	r24, 0x02	; 2
    316a:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
    316e:	cf 3f       	cpi	r28, 0xFF	; 255
    3170:	8f ef       	ldi	r24, 0xFF	; 255
    3172:	d8 07       	cpc	r29, r24
    3174:	59 f4       	brne	.+22     	; 0x318c <vTaskPlaceOnEventList+0x42>
    3176:	60 91 15 39 	lds	r22, 0x3915
    317a:	70 91 16 39 	lds	r23, 0x3916
    317e:	6e 5f       	subi	r22, 0xFE	; 254
    3180:	7f 4f       	sbci	r23, 0xFF	; 255
    3182:	86 eb       	ldi	r24, 0xB6	; 182
    3184:	98 e3       	ldi	r25, 0x38	; 56
    3186:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListInsertEnd>
    318a:	07 c0       	rjmp	.+14     	; 0x319a <vTaskPlaceOnEventList+0x50>
    318c:	80 91 b3 38 	lds	r24, 0x38B3
    3190:	90 91 b4 38 	lds	r25, 0x38B4
    3194:	8c 0f       	add	r24, r28
    3196:	9d 1f       	adc	r25, r29
    3198:	9b db       	rcall	.-2250   	; 0x28d0 <prvAddCurrentTaskToDelayedList>
    319a:	df 91       	pop	r29
    319c:	cf 91       	pop	r28
    319e:	08 95       	ret

000031a0 <vTaskPlaceOnEventListRestricted>:
    31a0:	cf 93       	push	r28
    31a2:	df 93       	push	r29
    31a4:	eb 01       	movw	r28, r22
    31a6:	60 91 15 39 	lds	r22, 0x3915
    31aa:	70 91 16 39 	lds	r23, 0x3916
    31ae:	64 5f       	subi	r22, 0xF4	; 244
    31b0:	7f 4f       	sbci	r23, 0xFF	; 255
    31b2:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListInsertEnd>
    31b6:	80 91 15 39 	lds	r24, 0x3915
    31ba:	90 91 16 39 	lds	r25, 0x3916
    31be:	02 96       	adiw	r24, 0x02	; 2
    31c0:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
    31c4:	80 91 b3 38 	lds	r24, 0x38B3
    31c8:	90 91 b4 38 	lds	r25, 0x38B4
    31cc:	8c 0f       	add	r24, r28
    31ce:	9d 1f       	adc	r25, r29
    31d0:	7f db       	rcall	.-2306   	; 0x28d0 <prvAddCurrentTaskToDelayedList>
    31d2:	df 91       	pop	r29
    31d4:	cf 91       	pop	r28
    31d6:	08 95       	ret

000031d8 <xTaskRemoveFromEventList>:
    31d8:	0f 93       	push	r16
    31da:	1f 93       	push	r17
    31dc:	cf 93       	push	r28
    31de:	df 93       	push	r29
    31e0:	dc 01       	movw	r26, r24
    31e2:	15 96       	adiw	r26, 0x05	; 5
    31e4:	ed 91       	ld	r30, X+
    31e6:	fc 91       	ld	r31, X
    31e8:	16 97       	sbiw	r26, 0x06	; 6
    31ea:	c6 81       	ldd	r28, Z+6	; 0x06
    31ec:	d7 81       	ldd	r29, Z+7	; 0x07
    31ee:	8e 01       	movw	r16, r28
    31f0:	04 5f       	subi	r16, 0xF4	; 244
    31f2:	1f 4f       	sbci	r17, 0xFF	; 255
    31f4:	c8 01       	movw	r24, r16
    31f6:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
    31fa:	80 91 ac 38 	lds	r24, 0x38AC
    31fe:	81 11       	cpse	r24, r1
    3200:	1c c0       	rjmp	.+56     	; 0x323a <xTaskRemoveFromEventList+0x62>
    3202:	0a 50       	subi	r16, 0x0A	; 10
    3204:	11 09       	sbc	r17, r1
    3206:	c8 01       	movw	r24, r16
    3208:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
    320c:	8e 89       	ldd	r24, Y+22	; 0x16
    320e:	90 91 b2 38 	lds	r25, 0x38B2
    3212:	98 17       	cp	r25, r24
    3214:	10 f4       	brcc	.+4      	; 0x321a <xTaskRemoveFromEventList+0x42>
    3216:	80 93 b2 38 	sts	0x38B2, r24
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	9c 01       	movw	r18, r24
    321e:	22 0f       	add	r18, r18
    3220:	33 1f       	adc	r19, r19
    3222:	22 0f       	add	r18, r18
    3224:	33 1f       	adc	r19, r19
    3226:	22 0f       	add	r18, r18
    3228:	33 1f       	adc	r19, r19
    322a:	82 0f       	add	r24, r18
    322c:	93 1f       	adc	r25, r19
    322e:	b8 01       	movw	r22, r16
    3230:	88 51       	subi	r24, 0x18	; 24
    3232:	97 4c       	sbci	r25, 0xC7	; 199
    3234:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListInsertEnd>
    3238:	05 c0       	rjmp	.+10     	; 0x3244 <xTaskRemoveFromEventList+0x6c>
    323a:	b8 01       	movw	r22, r16
    323c:	89 ec       	ldi	r24, 0xC9	; 201
    323e:	98 e3       	ldi	r25, 0x38	; 56
    3240:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListInsertEnd>
    3244:	e0 91 15 39 	lds	r30, 0x3915
    3248:	f0 91 16 39 	lds	r31, 0x3916
    324c:	9e 89       	ldd	r25, Y+22	; 0x16
    324e:	86 89       	ldd	r24, Z+22	; 0x16
    3250:	89 17       	cp	r24, r25
    3252:	20 f4       	brcc	.+8      	; 0x325c <xTaskRemoveFromEventList+0x84>
    3254:	81 e0       	ldi	r24, 0x01	; 1
    3256:	80 93 af 38 	sts	0x38AF, r24
    325a:	01 c0       	rjmp	.+2      	; 0x325e <xTaskRemoveFromEventList+0x86>
    325c:	80 e0       	ldi	r24, 0x00	; 0
    325e:	df 91       	pop	r29
    3260:	cf 91       	pop	r28
    3262:	1f 91       	pop	r17
    3264:	0f 91       	pop	r16
    3266:	08 95       	ret

00003268 <vTaskSetTimeOutState>:
    3268:	20 91 ae 38 	lds	r18, 0x38AE
    326c:	fc 01       	movw	r30, r24
    326e:	20 83       	st	Z, r18
    3270:	20 91 b3 38 	lds	r18, 0x38B3
    3274:	30 91 b4 38 	lds	r19, 0x38B4
    3278:	21 83       	std	Z+1, r18	; 0x01
    327a:	32 83       	std	Z+2, r19	; 0x02
    327c:	08 95       	ret

0000327e <xTaskCheckForTimeOut>:
    327e:	0f b6       	in	r0, 0x3f	; 63
    3280:	f8 94       	cli
    3282:	0f 92       	push	r0
    3284:	40 91 b3 38 	lds	r20, 0x38B3
    3288:	50 91 b4 38 	lds	r21, 0x38B4
    328c:	db 01       	movw	r26, r22
    328e:	2d 91       	ld	r18, X+
    3290:	3c 91       	ld	r19, X
    3292:	2f 3f       	cpi	r18, 0xFF	; 255
    3294:	bf ef       	ldi	r27, 0xFF	; 255
    3296:	3b 07       	cpc	r19, r27
    3298:	11 f1       	breq	.+68     	; 0x32de <xTaskCheckForTimeOut+0x60>
    329a:	e0 91 ae 38 	lds	r30, 0x38AE
    329e:	dc 01       	movw	r26, r24
    32a0:	fc 91       	ld	r31, X
    32a2:	fe 17       	cp	r31, r30
    32a4:	39 f0       	breq	.+14     	; 0x32b4 <xTaskCheckForTimeOut+0x36>
    32a6:	11 96       	adiw	r26, 0x01	; 1
    32a8:	ed 91       	ld	r30, X+
    32aa:	fc 91       	ld	r31, X
    32ac:	12 97       	sbiw	r26, 0x02	; 2
    32ae:	4e 17       	cp	r20, r30
    32b0:	5f 07       	cpc	r21, r31
    32b2:	b8 f4       	brcc	.+46     	; 0x32e2 <xTaskCheckForTimeOut+0x64>
    32b4:	dc 01       	movw	r26, r24
    32b6:	11 96       	adiw	r26, 0x01	; 1
    32b8:	ed 91       	ld	r30, X+
    32ba:	fc 91       	ld	r31, X
    32bc:	12 97       	sbiw	r26, 0x02	; 2
    32be:	da 01       	movw	r26, r20
    32c0:	ae 1b       	sub	r26, r30
    32c2:	bf 0b       	sbc	r27, r31
    32c4:	a2 17       	cp	r26, r18
    32c6:	b3 07       	cpc	r27, r19
    32c8:	70 f4       	brcc	.+28     	; 0x32e6 <xTaskCheckForTimeOut+0x68>
    32ca:	e4 1b       	sub	r30, r20
    32cc:	f5 0b       	sbc	r31, r21
    32ce:	2e 0f       	add	r18, r30
    32d0:	3f 1f       	adc	r19, r31
    32d2:	fb 01       	movw	r30, r22
    32d4:	20 83       	st	Z, r18
    32d6:	31 83       	std	Z+1, r19	; 0x01
    32d8:	c7 df       	rcall	.-114    	; 0x3268 <vTaskSetTimeOutState>
    32da:	80 e0       	ldi	r24, 0x00	; 0
    32dc:	05 c0       	rjmp	.+10     	; 0x32e8 <xTaskCheckForTimeOut+0x6a>
    32de:	80 e0       	ldi	r24, 0x00	; 0
    32e0:	03 c0       	rjmp	.+6      	; 0x32e8 <xTaskCheckForTimeOut+0x6a>
    32e2:	81 e0       	ldi	r24, 0x01	; 1
    32e4:	01 c0       	rjmp	.+2      	; 0x32e8 <xTaskCheckForTimeOut+0x6a>
    32e6:	81 e0       	ldi	r24, 0x01	; 1
    32e8:	0f 90       	pop	r0
    32ea:	0f be       	out	0x3f, r0	; 63
    32ec:	08 95       	ret

000032ee <vTaskMissedYield>:
    32ee:	81 e0       	ldi	r24, 0x01	; 1
    32f0:	80 93 af 38 	sts	0x38AF, r24
    32f4:	08 95       	ret

000032f6 <xTaskGetSchedulerState>:
    32f6:	80 91 b1 38 	lds	r24, 0x38B1
    32fa:	88 23       	and	r24, r24
    32fc:	31 f0       	breq	.+12     	; 0x330a <xTaskGetSchedulerState+0x14>
    32fe:	80 91 ac 38 	lds	r24, 0x38AC
    3302:	81 11       	cpse	r24, r1
    3304:	04 c0       	rjmp	.+8      	; 0x330e <xTaskGetSchedulerState+0x18>
    3306:	82 e0       	ldi	r24, 0x02	; 2
    3308:	08 95       	ret
    330a:	81 e0       	ldi	r24, 0x01	; 1
    330c:	08 95       	ret
    330e:	80 e0       	ldi	r24, 0x00	; 0
    3310:	08 95       	ret

00003312 <vTaskPriorityInherit>:
    3312:	0f 93       	push	r16
    3314:	1f 93       	push	r17
    3316:	cf 93       	push	r28
    3318:	df 93       	push	r29
    331a:	ec 01       	movw	r28, r24
    331c:	00 97       	sbiw	r24, 0x00	; 0
    331e:	09 f4       	brne	.+2      	; 0x3322 <vTaskPriorityInherit+0x10>
    3320:	51 c0       	rjmp	.+162    	; 0x33c4 <vTaskPriorityInherit+0xb2>
    3322:	8e 89       	ldd	r24, Y+22	; 0x16
    3324:	e0 91 15 39 	lds	r30, 0x3915
    3328:	f0 91 16 39 	lds	r31, 0x3916
    332c:	96 89       	ldd	r25, Z+22	; 0x16
    332e:	89 17       	cp	r24, r25
    3330:	08 f0       	brcs	.+2      	; 0x3334 <vTaskPriorityInherit+0x22>
    3332:	48 c0       	rjmp	.+144    	; 0x33c4 <vTaskPriorityInherit+0xb2>
    3334:	2c 85       	ldd	r18, Y+12	; 0x0c
    3336:	3d 85       	ldd	r19, Y+13	; 0x0d
    3338:	33 23       	and	r19, r19
    333a:	5c f0       	brlt	.+22     	; 0x3352 <vTaskPriorityInherit+0x40>
    333c:	e0 91 15 39 	lds	r30, 0x3915
    3340:	f0 91 16 39 	lds	r31, 0x3916
    3344:	96 89       	ldd	r25, Z+22	; 0x16
    3346:	25 e0       	ldi	r18, 0x05	; 5
    3348:	30 e0       	ldi	r19, 0x00	; 0
    334a:	29 1b       	sub	r18, r25
    334c:	31 09       	sbc	r19, r1
    334e:	2c 87       	std	Y+12, r18	; 0x0c
    3350:	3d 87       	std	Y+13, r19	; 0x0d
    3352:	90 e0       	ldi	r25, 0x00	; 0
    3354:	9c 01       	movw	r18, r24
    3356:	22 0f       	add	r18, r18
    3358:	33 1f       	adc	r19, r19
    335a:	22 0f       	add	r18, r18
    335c:	33 1f       	adc	r19, r19
    335e:	22 0f       	add	r18, r18
    3360:	33 1f       	adc	r19, r19
    3362:	82 0f       	add	r24, r18
    3364:	93 1f       	adc	r25, r19
    3366:	88 51       	subi	r24, 0x18	; 24
    3368:	97 4c       	sbci	r25, 0xC7	; 199
    336a:	2a 85       	ldd	r18, Y+10	; 0x0a
    336c:	3b 85       	ldd	r19, Y+11	; 0x0b
    336e:	28 17       	cp	r18, r24
    3370:	39 07       	cpc	r19, r25
    3372:	11 f5       	brne	.+68     	; 0x33b8 <vTaskPriorityInherit+0xa6>
    3374:	8e 01       	movw	r16, r28
    3376:	0e 5f       	subi	r16, 0xFE	; 254
    3378:	1f 4f       	sbci	r17, 0xFF	; 255
    337a:	c8 01       	movw	r24, r16
    337c:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
    3380:	e0 91 15 39 	lds	r30, 0x3915
    3384:	f0 91 16 39 	lds	r31, 0x3916
    3388:	86 89       	ldd	r24, Z+22	; 0x16
    338a:	8e 8b       	std	Y+22, r24	; 0x16
    338c:	90 91 b2 38 	lds	r25, 0x38B2
    3390:	98 17       	cp	r25, r24
    3392:	10 f4       	brcc	.+4      	; 0x3398 <vTaskPriorityInherit+0x86>
    3394:	80 93 b2 38 	sts	0x38B2, r24
    3398:	90 e0       	ldi	r25, 0x00	; 0
    339a:	9c 01       	movw	r18, r24
    339c:	22 0f       	add	r18, r18
    339e:	33 1f       	adc	r19, r19
    33a0:	22 0f       	add	r18, r18
    33a2:	33 1f       	adc	r19, r19
    33a4:	22 0f       	add	r18, r18
    33a6:	33 1f       	adc	r19, r19
    33a8:	82 0f       	add	r24, r18
    33aa:	93 1f       	adc	r25, r19
    33ac:	b8 01       	movw	r22, r16
    33ae:	88 51       	subi	r24, 0x18	; 24
    33b0:	97 4c       	sbci	r25, 0xC7	; 199
    33b2:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListInsertEnd>
    33b6:	06 c0       	rjmp	.+12     	; 0x33c4 <vTaskPriorityInherit+0xb2>
    33b8:	e0 91 15 39 	lds	r30, 0x3915
    33bc:	f0 91 16 39 	lds	r31, 0x3916
    33c0:	86 89       	ldd	r24, Z+22	; 0x16
    33c2:	8e 8b       	std	Y+22, r24	; 0x16
    33c4:	df 91       	pop	r29
    33c6:	cf 91       	pop	r28
    33c8:	1f 91       	pop	r17
    33ca:	0f 91       	pop	r16
    33cc:	08 95       	ret

000033ce <xTaskPriorityDisinherit>:
    33ce:	0f 93       	push	r16
    33d0:	1f 93       	push	r17
    33d2:	cf 93       	push	r28
    33d4:	df 93       	push	r29
    33d6:	ec 01       	movw	r28, r24
    33d8:	00 97       	sbiw	r24, 0x00	; 0
    33da:	71 f1       	breq	.+92     	; 0x3438 <xTaskPriorityDisinherit+0x6a>
    33dc:	8c a1       	ldd	r24, Y+36	; 0x24
    33de:	81 50       	subi	r24, 0x01	; 1
    33e0:	8c a3       	std	Y+36, r24	; 0x24
    33e2:	2e 89       	ldd	r18, Y+22	; 0x16
    33e4:	9b a1       	ldd	r25, Y+35	; 0x23
    33e6:	29 17       	cp	r18, r25
    33e8:	49 f1       	breq	.+82     	; 0x343c <xTaskPriorityDisinherit+0x6e>
    33ea:	81 11       	cpse	r24, r1
    33ec:	29 c0       	rjmp	.+82     	; 0x3440 <xTaskPriorityDisinherit+0x72>
    33ee:	8e 01       	movw	r16, r28
    33f0:	0e 5f       	subi	r16, 0xFE	; 254
    33f2:	1f 4f       	sbci	r17, 0xFF	; 255
    33f4:	c8 01       	movw	r24, r16
    33f6:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
    33fa:	8b a1       	ldd	r24, Y+35	; 0x23
    33fc:	8e 8b       	std	Y+22, r24	; 0x16
    33fe:	25 e0       	ldi	r18, 0x05	; 5
    3400:	30 e0       	ldi	r19, 0x00	; 0
    3402:	28 1b       	sub	r18, r24
    3404:	31 09       	sbc	r19, r1
    3406:	2c 87       	std	Y+12, r18	; 0x0c
    3408:	3d 87       	std	Y+13, r19	; 0x0d
    340a:	90 91 b2 38 	lds	r25, 0x38B2
    340e:	98 17       	cp	r25, r24
    3410:	10 f4       	brcc	.+4      	; 0x3416 <xTaskPriorityDisinherit+0x48>
    3412:	80 93 b2 38 	sts	0x38B2, r24
    3416:	90 e0       	ldi	r25, 0x00	; 0
    3418:	9c 01       	movw	r18, r24
    341a:	22 0f       	add	r18, r18
    341c:	33 1f       	adc	r19, r19
    341e:	22 0f       	add	r18, r18
    3420:	33 1f       	adc	r19, r19
    3422:	22 0f       	add	r18, r18
    3424:	33 1f       	adc	r19, r19
    3426:	82 0f       	add	r24, r18
    3428:	93 1f       	adc	r25, r19
    342a:	b8 01       	movw	r22, r16
    342c:	88 51       	subi	r24, 0x18	; 24
    342e:	97 4c       	sbci	r25, 0xC7	; 199
    3430:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <vListInsertEnd>
    3434:	81 e0       	ldi	r24, 0x01	; 1
    3436:	05 c0       	rjmp	.+10     	; 0x3442 <xTaskPriorityDisinherit+0x74>
    3438:	80 e0       	ldi	r24, 0x00	; 0
    343a:	03 c0       	rjmp	.+6      	; 0x3442 <xTaskPriorityDisinherit+0x74>
    343c:	80 e0       	ldi	r24, 0x00	; 0
    343e:	01 c0       	rjmp	.+2      	; 0x3442 <xTaskPriorityDisinherit+0x74>
    3440:	80 e0       	ldi	r24, 0x00	; 0
    3442:	df 91       	pop	r29
    3444:	cf 91       	pop	r28
    3446:	1f 91       	pop	r17
    3448:	0f 91       	pop	r16
    344a:	08 95       	ret

0000344c <vTaskList>:
    344c:	6f 92       	push	r6
    344e:	7f 92       	push	r7
    3450:	8f 92       	push	r8
    3452:	9f 92       	push	r9
    3454:	af 92       	push	r10
    3456:	bf 92       	push	r11
    3458:	cf 92       	push	r12
    345a:	df 92       	push	r13
    345c:	ef 92       	push	r14
    345e:	ff 92       	push	r15
    3460:	0f 93       	push	r16
    3462:	1f 93       	push	r17
    3464:	cf 93       	push	r28
    3466:	df 93       	push	r29
    3468:	1f 92       	push	r1
    346a:	1f 92       	push	r1
    346c:	cd b7       	in	r28, 0x3d	; 61
    346e:	de b7       	in	r29, 0x3e	; 62
    3470:	8c 01       	movw	r16, r24
    3472:	fc 01       	movw	r30, r24
    3474:	10 82       	st	Z, r1
    3476:	80 91 b5 38 	lds	r24, 0x38B5
    347a:	89 83       	std	Y+1, r24	; 0x01
    347c:	20 91 b5 38 	lds	r18, 0x38B5
    3480:	30 e0       	ldi	r19, 0x00	; 0
    3482:	22 0f       	add	r18, r18
    3484:	33 1f       	adc	r19, r19
    3486:	c9 01       	movw	r24, r18
    3488:	88 0f       	add	r24, r24
    348a:	99 1f       	adc	r25, r25
    348c:	88 0f       	add	r24, r24
    348e:	99 1f       	adc	r25, r25
    3490:	88 0f       	add	r24, r24
    3492:	99 1f       	adc	r25, r25
    3494:	82 1b       	sub	r24, r18
    3496:	93 0b       	sbc	r25, r19
    3498:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <pvPortMalloc>
    349c:	7c 01       	movw	r14, r24
    349e:	00 97       	sbiw	r24, 0x00	; 0
    34a0:	09 f4       	brne	.+2      	; 0x34a4 <vTaskList+0x58>
    34a2:	c3 c0       	rjmp	.+390    	; 0x362a <vTaskList+0x1de>
    34a4:	69 81       	ldd	r22, Y+1	; 0x01
    34a6:	40 e0       	ldi	r20, 0x00	; 0
    34a8:	50 e0       	ldi	r21, 0x00	; 0
    34aa:	4f dd       	rcall	.-1378   	; 0x2f4a <uxTaskGetSystemState>
    34ac:	89 83       	std	Y+1, r24	; 0x01
    34ae:	1a 82       	std	Y+2, r1	; 0x02
    34b0:	9a 81       	ldd	r25, Y+2	; 0x02
    34b2:	89 81       	ldd	r24, Y+1	; 0x01
    34b4:	98 17       	cp	r25, r24
    34b6:	08 f0       	brcs	.+2      	; 0x34ba <vTaskList+0x6e>
    34b8:	b5 c0       	rjmp	.+362    	; 0x3624 <vTaskList+0x1d8>
    34ba:	0f 2e       	mov	r0, r31
    34bc:	f2 e4       	ldi	r31, 0x42	; 66
    34be:	6f 2e       	mov	r6, r31
    34c0:	f0 2d       	mov	r31, r0
    34c2:	0f 2e       	mov	r0, r31
    34c4:	f3 e5       	ldi	r31, 0x53	; 83
    34c6:	7f 2e       	mov	r7, r31
    34c8:	f0 2d       	mov	r31, r0
    34ca:	0f 2e       	mov	r0, r31
    34cc:	f4 e4       	ldi	r31, 0x44	; 68
    34ce:	8f 2e       	mov	r8, r31
    34d0:	f0 2d       	mov	r31, r0
    34d2:	0f 2e       	mov	r0, r31
    34d4:	f2 e5       	ldi	r31, 0x52	; 82
    34d6:	9f 2e       	mov	r9, r31
    34d8:	f0 2d       	mov	r31, r0
    34da:	68 94       	set
    34dc:	bb 24       	eor	r11, r11
    34de:	b5 f8       	bld	r11, 5
    34e0:	0f 2e       	mov	r0, r31
    34e2:	f4 e7       	ldi	r31, 0x74	; 116
    34e4:	cf 2e       	mov	r12, r31
    34e6:	f0 e2       	ldi	r31, 0x20	; 32
    34e8:	df 2e       	mov	r13, r31
    34ea:	f0 2d       	mov	r31, r0
    34ec:	8a 81       	ldd	r24, Y+2	; 0x02
    34ee:	90 e0       	ldi	r25, 0x00	; 0
    34f0:	88 0f       	add	r24, r24
    34f2:	99 1f       	adc	r25, r25
    34f4:	fc 01       	movw	r30, r24
    34f6:	ee 0f       	add	r30, r30
    34f8:	ff 1f       	adc	r31, r31
    34fa:	ee 0f       	add	r30, r30
    34fc:	ff 1f       	adc	r31, r31
    34fe:	ee 0f       	add	r30, r30
    3500:	ff 1f       	adc	r31, r31
    3502:	e8 1b       	sub	r30, r24
    3504:	f9 0b       	sbc	r31, r25
    3506:	ee 0d       	add	r30, r14
    3508:	ff 1d       	adc	r31, r15
    350a:	85 81       	ldd	r24, Z+5	; 0x05
    350c:	82 30       	cpi	r24, 0x02	; 2
    350e:	89 f0       	breq	.+34     	; 0x3532 <vTaskList+0xe6>
    3510:	18 f4       	brcc	.+6      	; 0x3518 <vTaskList+0xcc>
    3512:	81 30       	cpi	r24, 0x01	; 1
    3514:	31 f0       	breq	.+12     	; 0x3522 <vTaskList+0xd6>
    3516:	0b c0       	rjmp	.+22     	; 0x352e <vTaskList+0xe2>
    3518:	83 30       	cpi	r24, 0x03	; 3
    351a:	29 f0       	breq	.+10     	; 0x3526 <vTaskList+0xda>
    351c:	84 30       	cpi	r24, 0x04	; 4
    351e:	29 f0       	breq	.+10     	; 0x352a <vTaskList+0xde>
    3520:	06 c0       	rjmp	.+12     	; 0x352e <vTaskList+0xe2>
    3522:	a9 2c       	mov	r10, r9
    3524:	07 c0       	rjmp	.+14     	; 0x3534 <vTaskList+0xe8>
    3526:	a7 2c       	mov	r10, r7
    3528:	05 c0       	rjmp	.+10     	; 0x3534 <vTaskList+0xe8>
    352a:	a8 2c       	mov	r10, r8
    352c:	03 c0       	rjmp	.+6      	; 0x3534 <vTaskList+0xe8>
    352e:	a1 2c       	mov	r10, r1
    3530:	01 c0       	rjmp	.+2      	; 0x3534 <vTaskList+0xe8>
    3532:	a6 2c       	mov	r10, r6
    3534:	8a 81       	ldd	r24, Y+2	; 0x02
    3536:	90 e0       	ldi	r25, 0x00	; 0
    3538:	88 0f       	add	r24, r24
    353a:	99 1f       	adc	r25, r25
    353c:	fc 01       	movw	r30, r24
    353e:	ee 0f       	add	r30, r30
    3540:	ff 1f       	adc	r31, r31
    3542:	ee 0f       	add	r30, r30
    3544:	ff 1f       	adc	r31, r31
    3546:	ee 0f       	add	r30, r30
    3548:	ff 1f       	adc	r31, r31
    354a:	e8 1b       	sub	r30, r24
    354c:	f9 0b       	sbc	r31, r25
    354e:	ee 0d       	add	r30, r14
    3550:	ff 1d       	adc	r31, r15
    3552:	62 81       	ldd	r22, Z+2	; 0x02
    3554:	73 81       	ldd	r23, Z+3	; 0x03
    3556:	c8 01       	movw	r24, r16
    3558:	0e 94 70 41 	call	0x82e0	; 0x82e0 <strcpy>
    355c:	f8 01       	movw	r30, r16
    355e:	01 90       	ld	r0, Z+
    3560:	00 20       	and	r0, r0
    3562:	e9 f7       	brne	.-6      	; 0x355e <vTaskList+0x112>
    3564:	31 97       	sbiw	r30, 0x01	; 1
    3566:	8e 2f       	mov	r24, r30
    3568:	80 1b       	sub	r24, r16
    356a:	87 30       	cpi	r24, 0x07	; 7
    356c:	38 f4       	brcc	.+14     	; 0x357c <vTaskList+0x130>
    356e:	f8 01       	movw	r30, r16
    3570:	e8 0f       	add	r30, r24
    3572:	f1 1d       	adc	r31, r1
    3574:	b0 82       	st	Z, r11
    3576:	8f 5f       	subi	r24, 0xFF	; 255
    3578:	87 30       	cpi	r24, 0x07	; 7
    357a:	c9 f7       	brne	.-14     	; 0x356e <vTaskList+0x122>
    357c:	08 0f       	add	r16, r24
    357e:	11 1d       	adc	r17, r1
    3580:	f8 01       	movw	r30, r16
    3582:	10 82       	st	Z, r1
    3584:	4a 81       	ldd	r20, Y+2	; 0x02
    3586:	2a 81       	ldd	r18, Y+2	; 0x02
    3588:	8a 81       	ldd	r24, Y+2	; 0x02
    358a:	50 e0       	ldi	r21, 0x00	; 0
    358c:	44 0f       	add	r20, r20
    358e:	55 1f       	adc	r21, r21
    3590:	fa 01       	movw	r30, r20
    3592:	ee 0f       	add	r30, r30
    3594:	ff 1f       	adc	r31, r31
    3596:	ee 0f       	add	r30, r30
    3598:	ff 1f       	adc	r31, r31
    359a:	ee 0f       	add	r30, r30
    359c:	ff 1f       	adc	r31, r31
    359e:	e4 1b       	sub	r30, r20
    35a0:	f5 0b       	sbc	r31, r21
    35a2:	ee 0d       	add	r30, r14
    35a4:	ff 1d       	adc	r31, r15
    35a6:	94 81       	ldd	r25, Z+4	; 0x04
    35a8:	1f 92       	push	r1
    35aa:	9f 93       	push	r25
    35ac:	30 e0       	ldi	r19, 0x00	; 0
    35ae:	22 0f       	add	r18, r18
    35b0:	33 1f       	adc	r19, r19
    35b2:	f9 01       	movw	r30, r18
    35b4:	ee 0f       	add	r30, r30
    35b6:	ff 1f       	adc	r31, r31
    35b8:	ee 0f       	add	r30, r30
    35ba:	ff 1f       	adc	r31, r31
    35bc:	ee 0f       	add	r30, r30
    35be:	ff 1f       	adc	r31, r31
    35c0:	e2 1b       	sub	r30, r18
    35c2:	f3 0b       	sbc	r31, r19
    35c4:	ee 0d       	add	r30, r14
    35c6:	ff 1d       	adc	r31, r15
    35c8:	95 85       	ldd	r25, Z+13	; 0x0d
    35ca:	9f 93       	push	r25
    35cc:	94 85       	ldd	r25, Z+12	; 0x0c
    35ce:	9f 93       	push	r25
    35d0:	90 e0       	ldi	r25, 0x00	; 0
    35d2:	88 0f       	add	r24, r24
    35d4:	99 1f       	adc	r25, r25
    35d6:	fc 01       	movw	r30, r24
    35d8:	ee 0f       	add	r30, r30
    35da:	ff 1f       	adc	r31, r31
    35dc:	ee 0f       	add	r30, r30
    35de:	ff 1f       	adc	r31, r31
    35e0:	ee 0f       	add	r30, r30
    35e2:	ff 1f       	adc	r31, r31
    35e4:	e8 1b       	sub	r30, r24
    35e6:	f9 0b       	sbc	r31, r25
    35e8:	ee 0d       	add	r30, r14
    35ea:	ff 1d       	adc	r31, r15
    35ec:	86 81       	ldd	r24, Z+6	; 0x06
    35ee:	1f 92       	push	r1
    35f0:	8f 93       	push	r24
    35f2:	1f 92       	push	r1
    35f4:	af 92       	push	r10
    35f6:	df 92       	push	r13
    35f8:	cf 92       	push	r12
    35fa:	1f 93       	push	r17
    35fc:	0f 93       	push	r16
    35fe:	0e 94 d1 41 	call	0x83a2	; 0x83a2 <sprintf>
    3602:	f8 01       	movw	r30, r16
    3604:	01 90       	ld	r0, Z+
    3606:	00 20       	and	r0, r0
    3608:	e9 f7       	brne	.-6      	; 0x3604 <vTaskList+0x1b8>
    360a:	8f 01       	movw	r16, r30
    360c:	01 50       	subi	r16, 0x01	; 1
    360e:	11 09       	sbc	r17, r1
    3610:	8a 81       	ldd	r24, Y+2	; 0x02
    3612:	8f 5f       	subi	r24, 0xFF	; 255
    3614:	8a 83       	std	Y+2, r24	; 0x02
    3616:	9a 81       	ldd	r25, Y+2	; 0x02
    3618:	89 81       	ldd	r24, Y+1	; 0x01
    361a:	cd bf       	out	0x3d, r28	; 61
    361c:	de bf       	out	0x3e, r29	; 62
    361e:	98 17       	cp	r25, r24
    3620:	08 f4       	brcc	.+2      	; 0x3624 <vTaskList+0x1d8>
    3622:	64 cf       	rjmp	.-312    	; 0x34ec <vTaskList+0xa0>
    3624:	c7 01       	movw	r24, r14
    3626:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <vPortFree>
    362a:	0f 90       	pop	r0
    362c:	0f 90       	pop	r0
    362e:	df 91       	pop	r29
    3630:	cf 91       	pop	r28
    3632:	1f 91       	pop	r17
    3634:	0f 91       	pop	r16
    3636:	ff 90       	pop	r15
    3638:	ef 90       	pop	r14
    363a:	df 90       	pop	r13
    363c:	cf 90       	pop	r12
    363e:	bf 90       	pop	r11
    3640:	af 90       	pop	r10
    3642:	9f 90       	pop	r9
    3644:	8f 90       	pop	r8
    3646:	7f 90       	pop	r7
    3648:	6f 90       	pop	r6
    364a:	08 95       	ret

0000364c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    364c:	80 91 15 39 	lds	r24, 0x3915
    3650:	90 91 16 39 	lds	r25, 0x3916
    3654:	89 2b       	or	r24, r25
    3656:	39 f0       	breq	.+14     	; 0x3666 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    3658:	e0 91 15 39 	lds	r30, 0x3915
    365c:	f0 91 16 39 	lds	r31, 0x3916
    3660:	84 a1       	ldd	r24, Z+36	; 0x24
    3662:	8f 5f       	subi	r24, 0xFF	; 255
    3664:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    3666:	80 91 15 39 	lds	r24, 0x3915
    366a:	90 91 16 39 	lds	r25, 0x3916
	}
    366e:	08 95       	ret

00003670 <prvInsertTimerInActiveList>:

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    3670:	fc 01       	movw	r30, r24
    3672:	62 83       	std	Z+2, r22	; 0x02
    3674:	73 83       	std	Z+3, r23	; 0x03
    3676:	80 87       	std	Z+8, r24	; 0x08
    3678:	91 87       	std	Z+9, r25	; 0x09
    367a:	46 17       	cp	r20, r22
    367c:	57 07       	cpc	r21, r23
    367e:	90 f0       	brcs	.+36     	; 0x36a4 <prvInsertTimerInActiveList+0x34>
    3680:	42 1b       	sub	r20, r18
    3682:	53 0b       	sbc	r21, r19
    3684:	84 85       	ldd	r24, Z+12	; 0x0c
    3686:	95 85       	ldd	r25, Z+13	; 0x0d
    3688:	48 17       	cp	r20, r24
    368a:	59 07       	cpc	r21, r25
    368c:	e0 f4       	brcc	.+56     	; 0x36c6 <prvInsertTimerInActiveList+0x56>
    368e:	bf 01       	movw	r22, r30
    3690:	6e 5f       	subi	r22, 0xFE	; 254
    3692:	7f 4f       	sbci	r23, 0xFF	; 255
    3694:	80 91 1b 39 	lds	r24, 0x391B
    3698:	90 91 1c 39 	lds	r25, 0x391C
    369c:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <vListInsert>
    36a0:	80 e0       	ldi	r24, 0x00	; 0
    36a2:	08 95       	ret
    36a4:	42 17       	cp	r20, r18
    36a6:	53 07       	cpc	r21, r19
    36a8:	18 f4       	brcc	.+6      	; 0x36b0 <prvInsertTimerInActiveList+0x40>
    36aa:	62 17       	cp	r22, r18
    36ac:	73 07       	cpc	r23, r19
    36ae:	68 f4       	brcc	.+26     	; 0x36ca <prvInsertTimerInActiveList+0x5a>
    36b0:	bf 01       	movw	r22, r30
    36b2:	6e 5f       	subi	r22, 0xFE	; 254
    36b4:	7f 4f       	sbci	r23, 0xFF	; 255
    36b6:	80 91 1d 39 	lds	r24, 0x391D
    36ba:	90 91 1e 39 	lds	r25, 0x391E
    36be:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <vListInsert>
    36c2:	80 e0       	ldi	r24, 0x00	; 0
    36c4:	08 95       	ret
    36c6:	81 e0       	ldi	r24, 0x01	; 1
    36c8:	08 95       	ret
    36ca:	81 e0       	ldi	r24, 0x01	; 1
    36cc:	08 95       	ret

000036ce <prvCheckForValidListAndQueue>:
    36ce:	0f b6       	in	r0, 0x3f	; 63
    36d0:	f8 94       	cli
    36d2:	0f 92       	push	r0
    36d4:	80 91 19 39 	lds	r24, 0x3919
    36d8:	90 91 1a 39 	lds	r25, 0x391A
    36dc:	89 2b       	or	r24, r25
    36de:	19 f5       	brne	.+70     	; 0x3726 <prvCheckForValidListAndQueue+0x58>
    36e0:	88 e2       	ldi	r24, 0x28	; 40
    36e2:	99 e3       	ldi	r25, 0x39	; 57
    36e4:	0e 94 ca 0f 	call	0x1f94	; 0x1f94 <vListInitialise>
    36e8:	8f e1       	ldi	r24, 0x1F	; 31
    36ea:	99 e3       	ldi	r25, 0x39	; 57
    36ec:	0e 94 ca 0f 	call	0x1f94	; 0x1f94 <vListInitialise>
    36f0:	88 e2       	ldi	r24, 0x28	; 40
    36f2:	99 e3       	ldi	r25, 0x39	; 57
    36f4:	80 93 1d 39 	sts	0x391D, r24
    36f8:	90 93 1e 39 	sts	0x391E, r25
    36fc:	8f e1       	ldi	r24, 0x1F	; 31
    36fe:	99 e3       	ldi	r25, 0x39	; 57
    3700:	80 93 1b 39 	sts	0x391B, r24
    3704:	90 93 1c 39 	sts	0x391C, r25
    3708:	40 e0       	ldi	r20, 0x00	; 0
    370a:	69 e0       	ldi	r22, 0x09	; 9
    370c:	8a e0       	ldi	r24, 0x0A	; 10
    370e:	0e 94 52 11 	call	0x22a4	; 0x22a4 <xQueueGenericCreate>
    3712:	80 93 19 39 	sts	0x3919, r24
    3716:	90 93 1a 39 	sts	0x391A, r25
    371a:	00 97       	sbiw	r24, 0x00	; 0
    371c:	21 f0       	breq	.+8      	; 0x3726 <prvCheckForValidListAndQueue+0x58>
    371e:	63 e8       	ldi	r22, 0x83	; 131
    3720:	70 e2       	ldi	r23, 0x20	; 32
    3722:	0e 94 55 13 	call	0x26aa	; 0x26aa <vQueueAddToRegistry>
    3726:	0f 90       	pop	r0
    3728:	0f be       	out	0x3f, r0	; 63
    372a:	08 95       	ret

0000372c <xTimerCreateTimerTask>:
    372c:	af 92       	push	r10
    372e:	bf 92       	push	r11
    3730:	cf 92       	push	r12
    3732:	df 92       	push	r13
    3734:	ef 92       	push	r14
    3736:	ff 92       	push	r15
    3738:	0f 93       	push	r16
    373a:	c9 df       	rcall	.-110    	; 0x36ce <prvCheckForValidListAndQueue>
    373c:	80 91 19 39 	lds	r24, 0x3919
    3740:	90 91 1a 39 	lds	r25, 0x391A
    3744:	89 2b       	or	r24, r25
    3746:	89 f0       	breq	.+34     	; 0x376a <xTimerCreateTimerTask+0x3e>
    3748:	a1 2c       	mov	r10, r1
    374a:	b1 2c       	mov	r11, r1
    374c:	c1 2c       	mov	r12, r1
    374e:	d1 2c       	mov	r13, r1
    3750:	e1 2c       	mov	r14, r1
    3752:	f1 2c       	mov	r15, r1
    3754:	03 e0       	ldi	r16, 0x03	; 3
    3756:	20 e0       	ldi	r18, 0x00	; 0
    3758:	30 e0       	ldi	r19, 0x00	; 0
    375a:	40 e4       	ldi	r20, 0x40	; 64
    375c:	50 e0       	ldi	r21, 0x00	; 0
    375e:	68 e8       	ldi	r22, 0x88	; 136
    3760:	70 e2       	ldi	r23, 0x20	; 32
    3762:	81 e7       	ldi	r24, 0x71	; 113
    3764:	9c e1       	ldi	r25, 0x1C	; 28
    3766:	e9 d8       	rcall	.-3630   	; 0x293a <xTaskGenericCreate>
    3768:	01 c0       	rjmp	.+2      	; 0x376c <xTimerCreateTimerTask+0x40>
    376a:	80 e0       	ldi	r24, 0x00	; 0
    376c:	0f 91       	pop	r16
    376e:	ff 90       	pop	r15
    3770:	ef 90       	pop	r14
    3772:	df 90       	pop	r13
    3774:	cf 90       	pop	r12
    3776:	bf 90       	pop	r11
    3778:	af 90       	pop	r10
    377a:	08 95       	ret

0000377c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

char xTimerGenericCommand( TimerHandle_t xTimer, const char xCommandID, const unsigned int xOptionalValue, char * const pxHigherPriorityTaskWoken, const unsigned int xTicksToWait )
{
    377c:	0f 93       	push	r16
    377e:	1f 93       	push	r17
    3780:	cf 93       	push	r28
    3782:	df 93       	push	r29
    3784:	cd b7       	in	r28, 0x3d	; 61
    3786:	de b7       	in	r29, 0x3e	; 62
    3788:	29 97       	sbiw	r28, 0x09	; 9
    378a:	cd bf       	out	0x3d, r28	; 61
    378c:	de bf       	out	0x3e, r29	; 62
    378e:	d9 01       	movw	r26, r18
char xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    3790:	e0 91 19 39 	lds	r30, 0x3919
    3794:	f0 91 1a 39 	lds	r31, 0x391A
    3798:	30 97       	sbiw	r30, 0x00	; 0
    379a:	61 f1       	breq	.+88     	; 0x37f4 <xTimerGenericCommand+0x78>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    379c:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    379e:	4a 83       	std	Y+2, r20	; 0x02
    37a0:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    37a2:	8c 83       	std	Y+4, r24	; 0x04
    37a4:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    37a6:	66 30       	cpi	r22, 0x06	; 6
    37a8:	e0 f4       	brcc	.+56     	; 0x37e2 <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    37aa:	a5 dd       	rcall	.-1206   	; 0x32f6 <xTaskGetSchedulerState>
    37ac:	82 30       	cpi	r24, 0x02	; 2
    37ae:	61 f4       	brne	.+24     	; 0x37c8 <xTimerGenericCommand+0x4c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    37b0:	20 e0       	ldi	r18, 0x00	; 0
    37b2:	a8 01       	movw	r20, r16
    37b4:	be 01       	movw	r22, r28
    37b6:	6f 5f       	subi	r22, 0xFF	; 255
    37b8:	7f 4f       	sbci	r23, 0xFF	; 255
    37ba:	80 91 19 39 	lds	r24, 0x3919
    37be:	90 91 1a 39 	lds	r25, 0x391A
    37c2:	0e 94 81 11 	call	0x2302	; 0x2302 <xQueueGenericSend>
    37c6:	17 c0       	rjmp	.+46     	; 0x37f6 <xTimerGenericCommand+0x7a>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    37c8:	20 e0       	ldi	r18, 0x00	; 0
    37ca:	40 e0       	ldi	r20, 0x00	; 0
    37cc:	50 e0       	ldi	r21, 0x00	; 0
    37ce:	be 01       	movw	r22, r28
    37d0:	6f 5f       	subi	r22, 0xFF	; 255
    37d2:	7f 4f       	sbci	r23, 0xFF	; 255
    37d4:	80 91 19 39 	lds	r24, 0x3919
    37d8:	90 91 1a 39 	lds	r25, 0x391A
    37dc:	0e 94 81 11 	call	0x2302	; 0x2302 <xQueueGenericSend>
    37e0:	0a c0       	rjmp	.+20     	; 0x37f6 <xTimerGenericCommand+0x7a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    37e2:	20 e0       	ldi	r18, 0x00	; 0
    37e4:	ad 01       	movw	r20, r26
    37e6:	be 01       	movw	r22, r28
    37e8:	6f 5f       	subi	r22, 0xFF	; 255
    37ea:	7f 4f       	sbci	r23, 0xFF	; 255
    37ec:	cf 01       	movw	r24, r30
    37ee:	0e 94 3b 12 	call	0x2476	; 0x2476 <xQueueGenericSendFromISR>
    37f2:	01 c0       	rjmp	.+2      	; 0x37f6 <xTimerGenericCommand+0x7a>
}
/*-----------------------------------------------------------*/

char xTimerGenericCommand( TimerHandle_t xTimer, const char xCommandID, const unsigned int xOptionalValue, char * const pxHigherPriorityTaskWoken, const unsigned int xTicksToWait )
{
char xReturn = pdFAIL;
    37f4:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    37f6:	29 96       	adiw	r28, 0x09	; 9
    37f8:	cd bf       	out	0x3d, r28	; 61
    37fa:	de bf       	out	0x3e, r29	; 62
    37fc:	df 91       	pop	r29
    37fe:	cf 91       	pop	r28
    3800:	1f 91       	pop	r17
    3802:	0f 91       	pop	r16
    3804:	08 95       	ret

00003806 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static unsigned int prvSampleTimeNow( char * const pxTimerListsWereSwitched )
{
    3806:	af 92       	push	r10
    3808:	bf 92       	push	r11
    380a:	cf 92       	push	r12
    380c:	df 92       	push	r13
    380e:	ef 92       	push	r14
    3810:	ff 92       	push	r15
    3812:	0f 93       	push	r16
    3814:	1f 93       	push	r17
    3816:	cf 93       	push	r28
    3818:	df 93       	push	r29
    381a:	6c 01       	movw	r12, r24
unsigned int xTimeNow;
PRIVILEGED_DATA static unsigned int xLastTime = ( unsigned int ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    381c:	15 da       	rcall	.-3030   	; 0x2c48 <xTaskGetTickCount>
    381e:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    3820:	80 91 17 39 	lds	r24, 0x3917
    3824:	90 91 18 39 	lds	r25, 0x3918
    3828:	e8 16       	cp	r14, r24
    382a:	f9 06       	cpc	r15, r25
    382c:	08 f0       	brcs	.+2      	; 0x3830 <prvSampleTimeNow+0x2a>
    382e:	47 c0       	rjmp	.+142    	; 0x38be <prvSampleTimeNow+0xb8>
    3830:	2f c0       	rjmp	.+94     	; 0x3890 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3832:	05 80       	ldd	r0, Z+5	; 0x05
    3834:	f6 81       	ldd	r31, Z+6	; 0x06
    3836:	e0 2d       	mov	r30, r0
    3838:	a0 80       	ld	r10, Z
    383a:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    383c:	c6 81       	ldd	r28, Z+6	; 0x06
    383e:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3840:	8e 01       	movw	r16, r28
    3842:	0e 5f       	subi	r16, 0xFE	; 254
    3844:	1f 4f       	sbci	r17, 0xFF	; 255
    3846:	c8 01       	movw	r24, r16
    3848:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    384c:	e9 89       	ldd	r30, Y+17	; 0x11
    384e:	fa 89       	ldd	r31, Y+18	; 0x12
    3850:	ce 01       	movw	r24, r28
    3852:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( unsigned char ) pdTRUE )
    3854:	8e 85       	ldd	r24, Y+14	; 0x0e
    3856:	81 30       	cpi	r24, 0x01	; 1
    3858:	d9 f4       	brne	.+54     	; 0x3890 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    385a:	8c 85       	ldd	r24, Y+12	; 0x0c
    385c:	9d 85       	ldd	r25, Y+13	; 0x0d
    385e:	8a 0d       	add	r24, r10
    3860:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    3862:	a8 16       	cp	r10, r24
    3864:	b9 06       	cpc	r11, r25
    3866:	60 f4       	brcc	.+24     	; 0x3880 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3868:	8a 83       	std	Y+2, r24	; 0x02
    386a:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    386c:	c8 87       	std	Y+8, r28	; 0x08
    386e:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3870:	b8 01       	movw	r22, r16
    3872:	80 91 1d 39 	lds	r24, 0x391D
    3876:	90 91 1e 39 	lds	r25, 0x391E
    387a:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <vListInsert>
    387e:	08 c0       	rjmp	.+16     	; 0x3890 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3880:	00 e0       	ldi	r16, 0x00	; 0
    3882:	10 e0       	ldi	r17, 0x00	; 0
    3884:	20 e0       	ldi	r18, 0x00	; 0
    3886:	30 e0       	ldi	r19, 0x00	; 0
    3888:	a5 01       	movw	r20, r10
    388a:	60 e0       	ldi	r22, 0x00	; 0
    388c:	ce 01       	movw	r24, r28
    388e:	76 df       	rcall	.-276    	; 0x377c <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3890:	e0 91 1d 39 	lds	r30, 0x391D
    3894:	f0 91 1e 39 	lds	r31, 0x391E
    3898:	80 81       	ld	r24, Z
    389a:	81 11       	cpse	r24, r1
    389c:	ca cf       	rjmp	.-108    	; 0x3832 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    389e:	80 91 1b 39 	lds	r24, 0x391B
    38a2:	90 91 1c 39 	lds	r25, 0x391C
    38a6:	80 93 1d 39 	sts	0x391D, r24
    38aa:	90 93 1e 39 	sts	0x391E, r25
	pxOverflowTimerList = pxTemp;
    38ae:	e0 93 1b 39 	sts	0x391B, r30
    38b2:	f0 93 1c 39 	sts	0x391C, r31
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    38b6:	81 e0       	ldi	r24, 0x01	; 1
    38b8:	f6 01       	movw	r30, r12
    38ba:	80 83       	st	Z, r24
    38bc:	02 c0       	rjmp	.+4      	; 0x38c2 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    38be:	f6 01       	movw	r30, r12
    38c0:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    38c2:	e0 92 17 39 	sts	0x3917, r14
    38c6:	f0 92 18 39 	sts	0x3918, r15

	return xTimeNow;
}
    38ca:	c7 01       	movw	r24, r14
    38cc:	df 91       	pop	r29
    38ce:	cf 91       	pop	r28
    38d0:	1f 91       	pop	r17
    38d2:	0f 91       	pop	r16
    38d4:	ff 90       	pop	r15
    38d6:	ef 90       	pop	r14
    38d8:	df 90       	pop	r13
    38da:	cf 90       	pop	r12
    38dc:	bf 90       	pop	r11
    38de:	af 90       	pop	r10
    38e0:	08 95       	ret

000038e2 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    38e2:	cf 93       	push	r28
    38e4:	df 93       	push	r29
    38e6:	cd b7       	in	r28, 0x3d	; 61
    38e8:	de b7       	in	r29, 0x3e	; 62
    38ea:	2a 97       	sbiw	r28, 0x0a	; 10
    38ec:	cd bf       	out	0x3d, r28	; 61
    38ee:	de bf       	out	0x3e, r29	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    38f0:	ce 01       	movw	r24, r28
    38f2:	01 96       	adiw	r24, 0x01	; 1
    38f4:	6c 01       	movw	r12, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
char xTimerListsWereSwitched, xResult;
unsigned int xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    38f6:	a8 2e       	mov	r10, r24
    38f8:	bd 2c       	mov	r11, r13
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    38fa:	e0 91 1d 39 	lds	r30, 0x391D
    38fe:	f0 91 1e 39 	lds	r31, 0x391E
	if( *pxListWasEmpty == pdFALSE )
    3902:	80 81       	ld	r24, Z
    3904:	88 23       	and	r24, r24
    3906:	09 f4       	brne	.+2      	; 0x390a <prvTimerTask+0x28>
    3908:	b1 c0       	rjmp	.+354    	; 0x3a6c <prvTimerTask+0x18a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    390a:	05 80       	ldd	r0, Z+5	; 0x05
    390c:	f6 81       	ldd	r31, Z+6	; 0x06
    390e:	e0 2d       	mov	r30, r0
    3910:	e0 80       	ld	r14, Z
    3912:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const unsigned int xNextExpireTime, const char xListWasEmpty )
{
unsigned int xTimeNow;
char xTimerListsWereSwitched;

	vTaskSuspendAll();
    3914:	93 d9       	rcall	.-3290   	; 0x2c3c <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3916:	c6 01       	movw	r24, r12
    3918:	76 df       	rcall	.-276    	; 0x3806 <prvSampleTimeNow>
    391a:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    391c:	89 81       	ldd	r24, Y+1	; 0x01
    391e:	81 11       	cpse	r24, r1
    3920:	44 c0       	rjmp	.+136    	; 0x39aa <prvTimerTask+0xc8>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3922:	0e 15       	cp	r16, r14
    3924:	1f 05       	cpc	r17, r15
    3926:	90 f1       	brcs	.+100    	; 0x398c <prvTimerTask+0xaa>
			{
				( void ) xTaskResumeAll();
    3928:	3c da       	rcall	.-2952   	; 0x2da2 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const unsigned int xNextExpireTime, const unsigned int xTimeNow )
{
char xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    392a:	e0 91 1d 39 	lds	r30, 0x391D
    392e:	f0 91 1e 39 	lds	r31, 0x391E
    3932:	05 80       	ldd	r0, Z+5	; 0x05
    3934:	f6 81       	ldd	r31, Z+6	; 0x06
    3936:	e0 2d       	mov	r30, r0
    3938:	86 80       	ldd	r8, Z+6	; 0x06
    393a:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    393c:	c4 01       	movw	r24, r8
    393e:	02 96       	adiw	r24, 0x02	; 2
    3940:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned char ) pdTRUE )
    3944:	d4 01       	movw	r26, r8
    3946:	1e 96       	adiw	r26, 0x0e	; 14
    3948:	8c 91       	ld	r24, X
    394a:	1e 97       	sbiw	r26, 0x0e	; 14
    394c:	81 30       	cpi	r24, 0x01	; 1
    394e:	a1 f4       	brne	.+40     	; 0x3978 <prvTimerTask+0x96>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    3950:	1c 96       	adiw	r26, 0x0c	; 12
    3952:	6d 91       	ld	r22, X+
    3954:	7c 91       	ld	r23, X
    3956:	1d 97       	sbiw	r26, 0x0d	; 13
    3958:	6e 0d       	add	r22, r14
    395a:	7f 1d       	adc	r23, r15
    395c:	97 01       	movw	r18, r14
    395e:	a8 01       	movw	r20, r16
    3960:	c4 01       	movw	r24, r8
    3962:	86 de       	rcall	.-756    	; 0x3670 <prvInsertTimerInActiveList>
    3964:	81 30       	cpi	r24, 0x01	; 1
    3966:	41 f4       	brne	.+16     	; 0x3978 <prvTimerTask+0x96>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3968:	00 e0       	ldi	r16, 0x00	; 0
    396a:	10 e0       	ldi	r17, 0x00	; 0
    396c:	20 e0       	ldi	r18, 0x00	; 0
    396e:	30 e0       	ldi	r19, 0x00	; 0
    3970:	a7 01       	movw	r20, r14
    3972:	60 e0       	ldi	r22, 0x00	; 0
    3974:	c4 01       	movw	r24, r8
    3976:	02 df       	rcall	.-508    	; 0x377c <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3978:	d4 01       	movw	r26, r8
    397a:	51 96       	adiw	r26, 0x11	; 17
    397c:	ed 91       	ld	r30, X+
    397e:	fc 91       	ld	r31, X
    3980:	52 97       	sbiw	r26, 0x12	; 18
    3982:	c4 01       	movw	r24, r8
    3984:	19 95       	eicall
    3986:	64 c0       	rjmp	.+200    	; 0x3a50 <prvTimerTask+0x16e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( unsigned int ) 0U;
    3988:	e1 2c       	mov	r14, r1
    398a:	f1 2c       	mov	r15, r1
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    398c:	b7 01       	movw	r22, r14
    398e:	60 1b       	sub	r22, r16
    3990:	71 0b       	sbc	r23, r17
    3992:	80 91 19 39 	lds	r24, 0x3919
    3996:	90 91 1a 39 	lds	r25, 0x391A
    399a:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    399e:	01 da       	rcall	.-3070   	; 0x2da2 <xTaskResumeAll>
    39a0:	81 11       	cpse	r24, r1
    39a2:	56 c0       	rjmp	.+172    	; 0x3a50 <prvTimerTask+0x16e>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    39a4:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vPortYield>
    39a8:	53 c0       	rjmp	.+166    	; 0x3a50 <prvTimerTask+0x16e>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    39aa:	fb d9       	rcall	.-3082   	; 0x2da2 <xTaskResumeAll>
    39ac:	51 c0       	rjmp	.+162    	; 0x3a50 <prvTimerTask+0x16e>
		function calls. */
		if( xMessage.xMessageID >= ( char ) 0 )
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    39ae:	ec 80       	ldd	r14, Y+4	; 0x04
    39b0:	fd 80       	ldd	r15, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    39b2:	f7 01       	movw	r30, r14
    39b4:	82 85       	ldd	r24, Z+10	; 0x0a
    39b6:	93 85       	ldd	r25, Z+11	; 0x0b
    39b8:	89 2b       	or	r24, r25
    39ba:	21 f0       	breq	.+8      	; 0x39c4 <prvTimerTask+0xe2>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    39bc:	c7 01       	movw	r24, r14
    39be:	02 96       	adiw	r24, 0x02	; 2
    39c0:	0e 94 2e 10 	call	0x205c	; 0x205c <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    39c4:	ce 01       	movw	r24, r28
    39c6:	0a 96       	adiw	r24, 0x0a	; 10
    39c8:	1e df       	rcall	.-452    	; 0x3806 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    39ca:	09 81       	ldd	r16, Y+1	; 0x01
    39cc:	10 e0       	ldi	r17, 0x00	; 0
    39ce:	0a 30       	cpi	r16, 0x0A	; 10
    39d0:	11 05       	cpc	r17, r1
    39d2:	08 f0       	brcs	.+2      	; 0x39d6 <prvTimerTask+0xf4>
    39d4:	3d c0       	rjmp	.+122    	; 0x3a50 <prvTimerTask+0x16e>
    39d6:	f8 01       	movw	r30, r16
    39d8:	ea 5f       	subi	r30, 0xFA	; 250
    39da:	fe 4f       	sbci	r31, 0xFE	; 254
    39dc:	0c 94 e0 3f 	jmp	0x7fc0	; 0x7fc0 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    39e0:	2a 81       	ldd	r18, Y+2	; 0x02
    39e2:	3b 81       	ldd	r19, Y+3	; 0x03
    39e4:	d7 01       	movw	r26, r14
    39e6:	1c 96       	adiw	r26, 0x0c	; 12
    39e8:	6d 91       	ld	r22, X+
    39ea:	7c 91       	ld	r23, X
    39ec:	1d 97       	sbiw	r26, 0x0d	; 13
    39ee:	62 0f       	add	r22, r18
    39f0:	73 1f       	adc	r23, r19
    39f2:	ac 01       	movw	r20, r24
    39f4:	c7 01       	movw	r24, r14
    39f6:	3c de       	rcall	.-904    	; 0x3670 <prvInsertTimerInActiveList>
    39f8:	81 30       	cpi	r24, 0x01	; 1
    39fa:	51 f5       	brne	.+84     	; 0x3a50 <prvTimerTask+0x16e>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    39fc:	d7 01       	movw	r26, r14
    39fe:	51 96       	adiw	r26, 0x11	; 17
    3a00:	ed 91       	ld	r30, X+
    3a02:	fc 91       	ld	r31, X
    3a04:	52 97       	sbiw	r26, 0x12	; 18
    3a06:	c7 01       	movw	r24, r14
    3a08:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( unsigned char ) pdTRUE )
    3a0a:	f7 01       	movw	r30, r14
    3a0c:	86 85       	ldd	r24, Z+14	; 0x0e
    3a0e:	81 30       	cpi	r24, 0x01	; 1
    3a10:	f9 f4       	brne	.+62     	; 0x3a50 <prvTimerTask+0x16e>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3a12:	44 85       	ldd	r20, Z+12	; 0x0c
    3a14:	55 85       	ldd	r21, Z+13	; 0x0d
    3a16:	8a 81       	ldd	r24, Y+2	; 0x02
    3a18:	9b 81       	ldd	r25, Y+3	; 0x03
    3a1a:	48 0f       	add	r20, r24
    3a1c:	59 1f       	adc	r21, r25
    3a1e:	00 e0       	ldi	r16, 0x00	; 0
    3a20:	10 e0       	ldi	r17, 0x00	; 0
    3a22:	20 e0       	ldi	r18, 0x00	; 0
    3a24:	30 e0       	ldi	r19, 0x00	; 0
    3a26:	60 e0       	ldi	r22, 0x00	; 0
    3a28:	c7 01       	movw	r24, r14
    3a2a:	a8 de       	rcall	.-688    	; 0x377c <xTimerGenericCommand>
    3a2c:	11 c0       	rjmp	.+34     	; 0x3a50 <prvTimerTask+0x16e>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3a2e:	6a 81       	ldd	r22, Y+2	; 0x02
    3a30:	7b 81       	ldd	r23, Y+3	; 0x03
    3a32:	d7 01       	movw	r26, r14
    3a34:	1c 96       	adiw	r26, 0x0c	; 12
    3a36:	6d 93       	st	X+, r22
    3a38:	7c 93       	st	X, r23
    3a3a:	1d 97       	sbiw	r26, 0x0d	; 13
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3a3c:	68 0f       	add	r22, r24
    3a3e:	79 1f       	adc	r23, r25
    3a40:	9c 01       	movw	r18, r24
    3a42:	ac 01       	movw	r20, r24
    3a44:	c7 01       	movw	r24, r14
    3a46:	14 de       	rcall	.-984    	; 0x3670 <prvInsertTimerInActiveList>
    3a48:	03 c0       	rjmp	.+6      	; 0x3a50 <prvTimerTask+0x16e>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    3a4a:	c7 01       	movw	r24, r14
    3a4c:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
char xTimerListsWereSwitched, xResult;
unsigned int xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3a50:	20 e0       	ldi	r18, 0x00	; 0
    3a52:	40 e0       	ldi	r20, 0x00	; 0
    3a54:	50 e0       	ldi	r21, 0x00	; 0
    3a56:	6a 2d       	mov	r22, r10
    3a58:	7b 2d       	mov	r23, r11
    3a5a:	80 91 19 39 	lds	r24, 0x3919
    3a5e:	90 91 1a 39 	lds	r25, 0x391A
    3a62:	0e 94 6d 12 	call	0x24da	; 0x24da <xQueueGenericReceive>
    3a66:	81 11       	cpse	r24, r1
    3a68:	a2 cf       	rjmp	.-188    	; 0x39ae <prvTimerTask+0xcc>
    3a6a:	47 cf       	rjmp	.-370    	; 0x38fa <prvTimerTask+0x18>
static void prvProcessTimerOrBlockTask( const unsigned int xNextExpireTime, const char xListWasEmpty )
{
unsigned int xTimeNow;
char xTimerListsWereSwitched;

	vTaskSuspendAll();
    3a6c:	e7 d8       	rcall	.-3634   	; 0x2c3c <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3a6e:	c6 01       	movw	r24, r12
    3a70:	ca de       	rcall	.-620    	; 0x3806 <prvSampleTimeNow>
    3a72:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    3a74:	89 81       	ldd	r24, Y+1	; 0x01
    3a76:	88 23       	and	r24, r24
    3a78:	09 f4       	brne	.+2      	; 0x3a7c <prvTimerTask+0x19a>
    3a7a:	86 cf       	rjmp	.-244    	; 0x3988 <prvTimerTask+0xa6>
    3a7c:	96 cf       	rjmp	.-212    	; 0x39aa <prvTimerTask+0xc8>

00003a7e <csp_malloc>:

/* FreeRTOS includes */
#include <FreeRTOS.h>

void * csp_malloc(size_t size) {
	return pvPortMalloc(size);
    3a7e:	0c 94 41 0e 	jmp	0x1c82	; 0x1c82 <pvPortMalloc>
}
    3a82:	08 95       	ret

00003a84 <csp_free>:

void csp_free(void *ptr) {
	vPortFree(ptr);
    3a84:	0c 94 66 0e 	jmp	0x1ccc	; 0x1ccc <vPortFree>
    3a88:	08 95       	ret

00003a8a <csp_queue_create>:
	return xQueueReceive(handle, buf, timeout);
}

int csp_queue_dequeue_isr(csp_queue_handle_t handle, void * buf, CSP_BASE_TYPE * task_woken) {
	return xQueueReceiveFromISR(handle, buf, (signed CSP_BASE_TYPE *)task_woken);
}
    3a8a:	40 e0       	ldi	r20, 0x00	; 0
    3a8c:	0c 94 52 11 	jmp	0x22a4	; 0x22a4 <xQueueGenericCreate>
    3a90:	08 95       	ret

00003a92 <csp_queue_enqueue>:
    3a92:	fb 01       	movw	r30, r22
    3a94:	ba 01       	movw	r22, r20
    3a96:	a9 01       	movw	r20, r18
    3a98:	4f 3f       	cpi	r20, 0xFF	; 255
    3a9a:	2f ef       	ldi	r18, 0xFF	; 255
    3a9c:	52 07       	cpc	r21, r18
    3a9e:	61 05       	cpc	r22, r1
    3aa0:	71 05       	cpc	r23, r1
    3aa2:	21 f0       	breq	.+8      	; 0x3aac <csp_queue_enqueue+0x1a>
    3aa4:	76 95       	lsr	r23
    3aa6:	67 95       	ror	r22
    3aa8:	57 95       	ror	r21
    3aaa:	47 95       	ror	r20
    3aac:	20 e0       	ldi	r18, 0x00	; 0
    3aae:	bf 01       	movw	r22, r30
    3ab0:	0e 94 81 11 	call	0x2302	; 0x2302 <xQueueGenericSend>
    3ab4:	90 e0       	ldi	r25, 0x00	; 0
    3ab6:	08 95       	ret

00003ab8 <csp_queue_enqueue_isr>:
    3ab8:	20 e0       	ldi	r18, 0x00	; 0
    3aba:	0e 94 3b 12 	call	0x2476	; 0x2476 <xQueueGenericSendFromISR>
    3abe:	90 e0       	ldi	r25, 0x00	; 0
    3ac0:	08 95       	ret

00003ac2 <csp_queue_dequeue>:
    3ac2:	fb 01       	movw	r30, r22
    3ac4:	ba 01       	movw	r22, r20
    3ac6:	a9 01       	movw	r20, r18
    3ac8:	4f 3f       	cpi	r20, 0xFF	; 255
    3aca:	2f ef       	ldi	r18, 0xFF	; 255
    3acc:	52 07       	cpc	r21, r18
    3ace:	61 05       	cpc	r22, r1
    3ad0:	71 05       	cpc	r23, r1
    3ad2:	21 f0       	breq	.+8      	; 0x3adc <csp_queue_dequeue+0x1a>
    3ad4:	76 95       	lsr	r23
    3ad6:	67 95       	ror	r22
    3ad8:	57 95       	ror	r21
    3ada:	47 95       	ror	r20
    3adc:	20 e0       	ldi	r18, 0x00	; 0
    3ade:	bf 01       	movw	r22, r30
    3ae0:	0e 94 6d 12 	call	0x24da	; 0x24da <xQueueGenericReceive>
    3ae4:	90 e0       	ldi	r25, 0x00	; 0
    3ae6:	08 95       	ret

00003ae8 <csp_queue_size>:

int csp_queue_size(csp_queue_handle_t handle) {
	return uxQueueMessagesWaiting(handle);
    3ae8:	0e 94 4d 13 	call	0x269a	; 0x269a <uxQueueMessagesWaiting>
}
    3aec:	90 e0       	ldi	r25, 0x00	; 0
    3aee:	08 95       	ret

00003af0 <csp_mutex_create>:
	return csp_bin_sem_remove(mutex);
}

int csp_mutex_lock(csp_mutex_t * mutex, uint32_t timeout) {
	return csp_bin_sem_wait(mutex, timeout);
}
    3af0:	cf 93       	push	r28
    3af2:	df 93       	push	r29
    3af4:	ec 01       	movw	r28, r24
    3af6:	81 e0       	ldi	r24, 0x01	; 1
    3af8:	0e 94 0f 12 	call	0x241e	; 0x241e <xQueueCreateMutex>
    3afc:	9c 01       	movw	r18, r24
    3afe:	88 83       	st	Y, r24
    3b00:	99 83       	std	Y+1, r25	; 0x01
    3b02:	81 e0       	ldi	r24, 0x01	; 1
    3b04:	90 e0       	ldi	r25, 0x00	; 0
    3b06:	23 2b       	or	r18, r19
    3b08:	11 f4       	brne	.+4      	; 0x3b0e <csp_mutex_create+0x1e>
    3b0a:	80 e0       	ldi	r24, 0x00	; 0
    3b0c:	90 e0       	ldi	r25, 0x00	; 0
    3b0e:	df 91       	pop	r29
    3b10:	cf 91       	pop	r28
    3b12:	08 95       	ret

00003b14 <csp_bin_sem_create>:
    3b14:	cf 93       	push	r28
    3b16:	df 93       	push	r29
    3b18:	ec 01       	movw	r28, r24
    3b1a:	43 e0       	ldi	r20, 0x03	; 3
    3b1c:	60 e0       	ldi	r22, 0x00	; 0
    3b1e:	81 e0       	ldi	r24, 0x01	; 1
    3b20:	0e 94 52 11 	call	0x22a4	; 0x22a4 <xQueueGenericCreate>
    3b24:	88 83       	st	Y, r24
    3b26:	99 83       	std	Y+1, r25	; 0x01
    3b28:	00 97       	sbiw	r24, 0x00	; 0
    3b2a:	39 f0       	breq	.+14     	; 0x3b3a <csp_bin_sem_create+0x26>
    3b2c:	20 e0       	ldi	r18, 0x00	; 0
    3b2e:	40 e0       	ldi	r20, 0x00	; 0
    3b30:	50 e0       	ldi	r21, 0x00	; 0
    3b32:	60 e0       	ldi	r22, 0x00	; 0
    3b34:	70 e0       	ldi	r23, 0x00	; 0
    3b36:	0e 94 81 11 	call	0x2302	; 0x2302 <xQueueGenericSend>
    3b3a:	81 e0       	ldi	r24, 0x01	; 1
    3b3c:	90 e0       	ldi	r25, 0x00	; 0
    3b3e:	df 91       	pop	r29
    3b40:	cf 91       	pop	r28
    3b42:	08 95       	ret

00003b44 <csp_bin_sem_wait>:
    3b44:	4f 3f       	cpi	r20, 0xFF	; 255
    3b46:	2f ef       	ldi	r18, 0xFF	; 255
    3b48:	52 07       	cpc	r21, r18
    3b4a:	61 05       	cpc	r22, r1
    3b4c:	71 05       	cpc	r23, r1
    3b4e:	21 f0       	breq	.+8      	; 0x3b58 <csp_bin_sem_wait+0x14>
    3b50:	76 95       	lsr	r23
    3b52:	67 95       	ror	r22
    3b54:	57 95       	ror	r21
    3b56:	47 95       	ror	r20
    3b58:	20 e0       	ldi	r18, 0x00	; 0
    3b5a:	60 e0       	ldi	r22, 0x00	; 0
    3b5c:	70 e0       	ldi	r23, 0x00	; 0
    3b5e:	fc 01       	movw	r30, r24
    3b60:	80 81       	ld	r24, Z
    3b62:	91 81       	ldd	r25, Z+1	; 0x01
    3b64:	0e 94 6d 12 	call	0x24da	; 0x24da <xQueueGenericReceive>
    3b68:	21 e0       	ldi	r18, 0x01	; 1
    3b6a:	30 e0       	ldi	r19, 0x00	; 0
    3b6c:	81 30       	cpi	r24, 0x01	; 1
    3b6e:	11 f0       	breq	.+4      	; 0x3b74 <csp_bin_sem_wait+0x30>
    3b70:	20 e0       	ldi	r18, 0x00	; 0
    3b72:	30 e0       	ldi	r19, 0x00	; 0
    3b74:	c9 01       	movw	r24, r18
    3b76:	08 95       	ret

00003b78 <csp_bin_sem_post>:
	}
}

int csp_bin_sem_post(csp_bin_sem_handle_t * sem) {
	csp_log_lock("Post: %p\r\n", sem);
	if (xSemaphoreGive(*sem) == pdPASS) {
    3b78:	20 e0       	ldi	r18, 0x00	; 0
    3b7a:	40 e0       	ldi	r20, 0x00	; 0
    3b7c:	50 e0       	ldi	r21, 0x00	; 0
    3b7e:	60 e0       	ldi	r22, 0x00	; 0
    3b80:	70 e0       	ldi	r23, 0x00	; 0
    3b82:	fc 01       	movw	r30, r24
    3b84:	80 81       	ld	r24, Z
    3b86:	91 81       	ldd	r25, Z+1	; 0x01
    3b88:	0e 94 81 11 	call	0x2302	; 0x2302 <xQueueGenericSend>
    3b8c:	21 e0       	ldi	r18, 0x01	; 1
    3b8e:	30 e0       	ldi	r19, 0x00	; 0
    3b90:	81 30       	cpi	r24, 0x01	; 1
    3b92:	11 f0       	breq	.+4      	; 0x3b98 <csp_bin_sem_post+0x20>
    3b94:	20 e0       	ldi	r18, 0x00	; 0
    3b96:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_SEMAPHORE_OK;
	} else {
		return CSP_SEMAPHORE_ERROR;
	}
}
    3b98:	c9 01       	movw	r24, r18
    3b9a:	08 95       	ret

00003b9c <csp_sys_tasklist>:

int csp_sys_tasklist(char * out) {
#if FREERTOS_VERSION < 8
	vTaskList((signed char *) out);
#else
	vTaskList(out);
    3b9c:	57 dc       	rcall	.-1874   	; 0x344c <vTaskList>
#endif
	return CSP_ERR_NONE;
}
    3b9e:	80 e0       	ldi	r24, 0x00	; 0
    3ba0:	90 e0       	ldi	r25, 0x00	; 0
    3ba2:	08 95       	ret

00003ba4 <csp_sys_tasklist_size>:

int csp_sys_tasklist_size(void) {
	return 40 * uxTaskGetNumberOfTasks();
    3ba4:	5b d8       	rcall	.-3914   	; 0x2c5c <uxTaskGetNumberOfTasks>
}
    3ba6:	28 e2       	ldi	r18, 0x28	; 40
    3ba8:	82 9f       	mul	r24, r18
    3baa:	c0 01       	movw	r24, r0
    3bac:	11 24       	eor	r1, r1
    3bae:	08 95       	ret

00003bb0 <csp_sys_memfree>:

uint32_t csp_sys_memfree(void) {
    3bb0:	4f 92       	push	r4
    3bb2:	5f 92       	push	r5
    3bb4:	6f 92       	push	r6
    3bb6:	7f 92       	push	r7
    3bb8:	8f 92       	push	r8
    3bba:	9f 92       	push	r9
    3bbc:	af 92       	push	r10
    3bbe:	bf 92       	push	r11
    3bc0:	cf 92       	push	r12
    3bc2:	df 92       	push	r13
    3bc4:	ef 92       	push	r14
    3bc6:	ff 92       	push	r15

	uint32_t total = 0, max = UINT32_MAX, size;
	void * pmem;

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;
    3bc8:	0f 2e       	mov	r0, r31
    3bca:	f0 e1       	ldi	r31, 0x10	; 16
    3bcc:	cf 2e       	mov	r12, r31
    3bce:	f7 e2       	ldi	r31, 0x27	; 39
    3bd0:	df 2e       	mov	r13, r31
    3bd2:	e1 2c       	mov	r14, r1
    3bd4:	f1 2c       	mov	r15, r1
    3bd6:	f0 2d       	mov	r31, r0
	return 40 * uxTaskGetNumberOfTasks();
}

uint32_t csp_sys_memfree(void) {

	uint32_t total = 0, max = UINT32_MAX, size;
    3bd8:	44 24       	eor	r4, r4
    3bda:	4a 94       	dec	r4
    3bdc:	54 2c       	mov	r5, r4
    3bde:	32 01       	movw	r6, r4
    3be0:	81 2c       	mov	r8, r1
    3be2:	91 2c       	mov	r9, r1
    3be4:	54 01       	movw	r10, r8

	/* If size_t is less than 32 bits, start with 10 KiB */
	size = sizeof(uint32_t) > sizeof(size_t) ? 10000 : 1000000;

	while (1) {
		pmem = pvPortMalloc(size + total);
    3be6:	c4 01       	movw	r24, r8
    3be8:	8c 0d       	add	r24, r12
    3bea:	9d 1d       	adc	r25, r13
    3bec:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <pvPortMalloc>
		if (pmem == NULL) {
    3bf0:	00 97       	sbiw	r24, 0x00	; 0
    3bf2:	59 f4       	brne	.+22     	; 0x3c0a <csp_sys_memfree+0x5a>
			max = size + total;
    3bf4:	26 01       	movw	r4, r12
    3bf6:	37 01       	movw	r6, r14
    3bf8:	48 0c       	add	r4, r8
    3bfa:	59 1c       	adc	r5, r9
    3bfc:	6a 1c       	adc	r6, r10
    3bfe:	7b 1c       	adc	r7, r11
			size = size / 2;
    3c00:	f6 94       	lsr	r15
    3c02:	e7 94       	ror	r14
    3c04:	d7 94       	ror	r13
    3c06:	c7 94       	ror	r12
    3c08:	15 c0       	rjmp	.+42     	; 0x3c34 <csp_sys_memfree+0x84>
		} else {
			total += size;
    3c0a:	8c 0c       	add	r8, r12
    3c0c:	9d 1c       	adc	r9, r13
    3c0e:	ae 1c       	adc	r10, r14
    3c10:	bf 1c       	adc	r11, r15
			if (total + size >= max)
    3c12:	b5 01       	movw	r22, r10
    3c14:	a4 01       	movw	r20, r8
    3c16:	4c 0d       	add	r20, r12
    3c18:	5d 1d       	adc	r21, r13
    3c1a:	6e 1d       	adc	r22, r14
    3c1c:	7f 1d       	adc	r23, r15
    3c1e:	44 15       	cp	r20, r4
    3c20:	55 05       	cpc	r21, r5
    3c22:	66 05       	cpc	r22, r6
    3c24:	77 05       	cpc	r23, r7
    3c26:	20 f0       	brcs	.+8      	; 0x3c30 <csp_sys_memfree+0x80>
				size = size / 2;
    3c28:	f6 94       	lsr	r15
    3c2a:	e7 94       	ror	r14
    3c2c:	d7 94       	ror	r13
    3c2e:	c7 94       	ror	r12
			vPortFree(pmem);
    3c30:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <vPortFree>
		}
		if (size < 32) break;
    3c34:	80 e2       	ldi	r24, 0x20	; 32
    3c36:	c8 16       	cp	r12, r24
    3c38:	d1 04       	cpc	r13, r1
    3c3a:	e1 04       	cpc	r14, r1
    3c3c:	f1 04       	cpc	r15, r1
    3c3e:	98 f6       	brcc	.-90     	; 0x3be6 <csp_sys_memfree+0x36>
	}

	return total;
}
    3c40:	c5 01       	movw	r24, r10
    3c42:	b4 01       	movw	r22, r8
    3c44:	ff 90       	pop	r15
    3c46:	ef 90       	pop	r14
    3c48:	df 90       	pop	r13
    3c4a:	cf 90       	pop	r12
    3c4c:	bf 90       	pop	r11
    3c4e:	af 90       	pop	r10
    3c50:	9f 90       	pop	r9
    3c52:	8f 90       	pop	r8
    3c54:	7f 90       	pop	r7
    3c56:	6f 90       	pop	r6
    3c58:	5f 90       	pop	r5
    3c5a:	4f 90       	pop	r4
    3c5c:	08 95       	ret

00003c5e <csp_sys_reboot>:

int csp_sys_reboot(void) {

	extern void __attribute__((weak)) cpu_set_reset_cause(unsigned int);
	if (cpu_set_reset_cause)
    3c5e:	80 e0       	ldi	r24, 0x00	; 0
    3c60:	90 e0       	ldi	r25, 0x00	; 0
    3c62:	89 2b       	or	r24, r25
    3c64:	21 f0       	breq	.+8      	; 0x3c6e <csp_sys_reboot+0x10>
		cpu_set_reset_cause(1);
    3c66:	81 e0       	ldi	r24, 0x01	; 1
    3c68:	90 e0       	ldi	r25, 0x00	; 0
    3c6a:	0e 94 00 00 	call	0	; 0x0 <__vectors>
	
	extern void __attribute__((weak)) cpu_reset(void);
	if (cpu_reset) {
    3c6e:	80 e0       	ldi	r24, 0x00	; 0
    3c70:	90 e0       	ldi	r25, 0x00	; 0
    3c72:	89 2b       	or	r24, r25
    3c74:	19 f0       	breq	.+6      	; 0x3c7c <csp_sys_reboot+0x1e>
		cpu_reset();
    3c76:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    3c7a:	ff cf       	rjmp	.-2      	; 0x3c7a <csp_sys_reboot+0x1c>
	}
	
	csp_log_error("Failed to reboot\r\n");

	return CSP_ERR_INVAL;
}
    3c7c:	8e ef       	ldi	r24, 0xFE	; 254
    3c7e:	9f ef       	ldi	r25, 0xFF	; 255
    3c80:	08 95       	ret

00003c82 <csp_thread_create>:
/* CSP includes */
#include <csp/csp.h>

#include <csp/arch/csp_thread.h>

int csp_thread_create(csp_thread_return_t (* routine)(void *), const signed char * const thread_name, unsigned short stack_depth, void * parameters, unsigned int priority, csp_thread_handle_t * handle) {
    3c82:	af 92       	push	r10
    3c84:	bf 92       	push	r11
    3c86:	cf 92       	push	r12
    3c88:	df 92       	push	r13
    3c8a:	ef 92       	push	r14
    3c8c:	ff 92       	push	r15
    3c8e:	0f 93       	push	r16
#if (FREERTOS_VERSION >= 8)
	portBASE_TYPE ret = xTaskCreate(routine, (char *) thread_name, stack_depth, parameters, priority, handle);
    3c90:	a1 2c       	mov	r10, r1
    3c92:	b1 2c       	mov	r11, r1
    3c94:	c1 2c       	mov	r12, r1
    3c96:	d1 2c       	mov	r13, r1
    3c98:	0e 94 9d 14 	call	0x293a	; 0x293a <xTaskGenericCreate>
#else
	portBASE_TYPE ret = xTaskCreate(routine, thread_name, stack_depth, parameters, priority, handle);
#endif
	if (ret != pdTRUE)
    3c9c:	21 e0       	ldi	r18, 0x01	; 1
    3c9e:	30 e0       	ldi	r19, 0x00	; 0
    3ca0:	81 30       	cpi	r24, 0x01	; 1
    3ca2:	11 f4       	brne	.+4      	; 0x3ca8 <csp_thread_create+0x26>
    3ca4:	20 e0       	ldi	r18, 0x00	; 0
    3ca6:	30 e0       	ldi	r19, 0x00	; 0
		return CSP_ERR_NOMEM;
	return CSP_ERR_NONE;
}
    3ca8:	88 27       	eor	r24, r24
    3caa:	99 27       	eor	r25, r25
    3cac:	82 1b       	sub	r24, r18
    3cae:	93 0b       	sbc	r25, r19
    3cb0:	0f 91       	pop	r16
    3cb2:	ff 90       	pop	r15
    3cb4:	ef 90       	pop	r14
    3cb6:	df 90       	pop	r13
    3cb8:	cf 90       	pop	r12
    3cba:	bf 90       	pop	r11
    3cbc:	af 90       	pop	r10
    3cbe:	08 95       	ret

00003cc0 <csp_get_ms>:
	return (uint32_t)(xTaskGetTickCount() * (1000/configTICK_RATE_HZ));
}

uint32_t csp_get_ms_isr(void) {
	return (uint32_t)(xTaskGetTickCountFromISR() * (1000/configTICK_RATE_HZ));
}
    3cc0:	0e 94 24 16 	call	0x2c48	; 0x2c48 <xTaskGetTickCount>
    3cc4:	88 0f       	add	r24, r24
    3cc6:	99 1f       	adc	r25, r25
    3cc8:	bc 01       	movw	r22, r24
    3cca:	80 e0       	ldi	r24, 0x00	; 0
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	08 95       	ret

00003cd0 <csp_get_s>:

uint32_t csp_get_s(void) {
	return (uint32_t)(xTaskGetTickCount()/configTICK_RATE_HZ);
    3cd0:	0e 94 24 16 	call	0x2c48	; 0x2c48 <xTaskGetTickCount>
    3cd4:	9c 01       	movw	r18, r24
    3cd6:	36 95       	lsr	r19
    3cd8:	27 95       	ror	r18
    3cda:	36 95       	lsr	r19
    3cdc:	27 95       	ror	r18
    3cde:	a5 ec       	ldi	r26, 0xC5	; 197
    3ce0:	b0 e2       	ldi	r27, 0x20	; 32
    3ce2:	0e 94 e6 3f 	call	0x7fcc	; 0x7fcc <__umulhisi3>
    3ce6:	92 95       	swap	r25
    3ce8:	82 95       	swap	r24
    3cea:	8f 70       	andi	r24, 0x0F	; 15
    3cec:	89 27       	eor	r24, r25
    3cee:	9f 70       	andi	r25, 0x0F	; 15
    3cf0:	89 27       	eor	r24, r25
    3cf2:	bc 01       	movw	r22, r24
    3cf4:	80 e0       	ldi	r24, 0x00	; 0
    3cf6:	90 e0       	ldi	r25, 0x00	; 0
}
    3cf8:	08 95       	ret

00003cfa <csp_buffer_init>:
	if (clone)
		memcpy(clone, packet, size);

	return clone;

}
    3cfa:	cf 92       	push	r12
    3cfc:	df 92       	push	r13
    3cfe:	ef 92       	push	r14
    3d00:	ff 92       	push	r15
    3d02:	0f 93       	push	r16
    3d04:	1f 93       	push	r17
    3d06:	cf 93       	push	r28
    3d08:	df 93       	push	r29
    3d0a:	1f 92       	push	r1
    3d0c:	1f 92       	push	r1
    3d0e:	cd b7       	in	r28, 0x3d	; 61
    3d10:	de b7       	in	r29, 0x3e	; 62
    3d12:	80 93 33 39 	sts	0x3933, r24
    3d16:	90 93 34 39 	sts	0x3934, r25
    3d1a:	60 93 31 39 	sts	0x3931, r22
    3d1e:	70 93 32 39 	sts	0x3932, r23
    3d22:	6b 01       	movw	r12, r22
    3d24:	25 e0       	ldi	r18, 0x05	; 5
    3d26:	c2 0e       	add	r12, r18
    3d28:	d1 1c       	adc	r13, r1
    3d2a:	e8 94       	clt
    3d2c:	c0 f8       	bld	r12, 0
    3d2e:	c8 9e       	mul	r12, r24
    3d30:	80 01       	movw	r16, r0
    3d32:	c9 9e       	mul	r12, r25
    3d34:	10 0d       	add	r17, r0
    3d36:	d8 9e       	mul	r13, r24
    3d38:	10 0d       	add	r17, r0
    3d3a:	11 24       	eor	r1, r1
    3d3c:	c8 01       	movw	r24, r16
    3d3e:	9f de       	rcall	.-706    	; 0x3a7e <csp_malloc>
    3d40:	80 93 35 39 	sts	0x3935, r24
    3d44:	90 93 36 39 	sts	0x3936, r25
    3d48:	89 2b       	or	r24, r25
    3d4a:	09 f4       	brne	.+2      	; 0x3d4e <csp_buffer_init+0x54>
    3d4c:	4d c0       	rjmp	.+154    	; 0x3de8 <csp_buffer_init+0xee>
    3d4e:	62 e0       	ldi	r22, 0x02	; 2
    3d50:	70 e0       	ldi	r23, 0x00	; 0
    3d52:	80 91 33 39 	lds	r24, 0x3933
    3d56:	90 91 34 39 	lds	r25, 0x3934
    3d5a:	97 de       	rcall	.-722    	; 0x3a8a <csp_queue_create>
    3d5c:	80 93 37 39 	sts	0x3937, r24
    3d60:	90 93 38 39 	sts	0x3938, r25
    3d64:	89 2b       	or	r24, r25
    3d66:	c1 f1       	breq	.+112    	; 0x3dd8 <csp_buffer_init+0xde>
    3d68:	a8 01       	movw	r20, r16
    3d6a:	60 e0       	ldi	r22, 0x00	; 0
    3d6c:	70 e0       	ldi	r23, 0x00	; 0
    3d6e:	80 91 35 39 	lds	r24, 0x3935
    3d72:	90 91 36 39 	lds	r25, 0x3936
    3d76:	0e 94 69 41 	call	0x82d2	; 0x82d2 <memset>
    3d7a:	80 91 33 39 	lds	r24, 0x3933
    3d7e:	90 91 34 39 	lds	r25, 0x3934
    3d82:	89 2b       	or	r24, r25
    3d84:	a1 f1       	breq	.+104    	; 0x3dee <csp_buffer_init+0xf4>
    3d86:	e1 2c       	mov	r14, r1
    3d88:	f1 2c       	mov	r15, r1
    3d8a:	00 e0       	ldi	r16, 0x00	; 0
    3d8c:	10 e0       	ldi	r17, 0x00	; 0
    3d8e:	e0 91 35 39 	lds	r30, 0x3935
    3d92:	f0 91 36 39 	lds	r31, 0x3936
    3d96:	ee 0d       	add	r30, r14
    3d98:	ff 1d       	adc	r31, r15
    3d9a:	e9 83       	std	Y+1, r30	; 0x01
    3d9c:	fa 83       	std	Y+2, r31	; 0x02
    3d9e:	10 82       	st	Z, r1
    3da0:	11 82       	std	Z+1, r1	; 0x01
    3da2:	e9 81       	ldd	r30, Y+1	; 0x01
    3da4:	fa 81       	ldd	r31, Y+2	; 0x02
    3da6:	e2 83       	std	Z+2, r30	; 0x02
    3da8:	f3 83       	std	Z+3, r31	; 0x03
    3daa:	20 e0       	ldi	r18, 0x00	; 0
    3dac:	30 e0       	ldi	r19, 0x00	; 0
    3dae:	a9 01       	movw	r20, r18
    3db0:	be 01       	movw	r22, r28
    3db2:	6f 5f       	subi	r22, 0xFF	; 255
    3db4:	7f 4f       	sbci	r23, 0xFF	; 255
    3db6:	80 91 37 39 	lds	r24, 0x3937
    3dba:	90 91 38 39 	lds	r25, 0x3938
    3dbe:	69 de       	rcall	.-814    	; 0x3a92 <csp_queue_enqueue>
    3dc0:	0f 5f       	subi	r16, 0xFF	; 255
    3dc2:	1f 4f       	sbci	r17, 0xFF	; 255
    3dc4:	ec 0c       	add	r14, r12
    3dc6:	fd 1c       	adc	r15, r13
    3dc8:	80 91 33 39 	lds	r24, 0x3933
    3dcc:	90 91 34 39 	lds	r25, 0x3934
    3dd0:	08 17       	cp	r16, r24
    3dd2:	19 07       	cpc	r17, r25
    3dd4:	e0 f2       	brcs	.-72     	; 0x3d8e <csp_buffer_init+0x94>
    3dd6:	0e c0       	rjmp	.+28     	; 0x3df4 <csp_buffer_init+0xfa>
    3dd8:	80 91 35 39 	lds	r24, 0x3935
    3ddc:	90 91 36 39 	lds	r25, 0x3936
    3de0:	51 de       	rcall	.-862    	; 0x3a84 <csp_free>
    3de2:	8f ef       	ldi	r24, 0xFF	; 255
    3de4:	9f ef       	ldi	r25, 0xFF	; 255
    3de6:	08 c0       	rjmp	.+16     	; 0x3df8 <csp_buffer_init+0xfe>
    3de8:	8f ef       	ldi	r24, 0xFF	; 255
    3dea:	9f ef       	ldi	r25, 0xFF	; 255
    3dec:	05 c0       	rjmp	.+10     	; 0x3df8 <csp_buffer_init+0xfe>
    3dee:	80 e0       	ldi	r24, 0x00	; 0
    3df0:	90 e0       	ldi	r25, 0x00	; 0
    3df2:	02 c0       	rjmp	.+4      	; 0x3df8 <csp_buffer_init+0xfe>
    3df4:	80 e0       	ldi	r24, 0x00	; 0
    3df6:	90 e0       	ldi	r25, 0x00	; 0
    3df8:	0f 90       	pop	r0
    3dfa:	0f 90       	pop	r0
    3dfc:	df 91       	pop	r29
    3dfe:	cf 91       	pop	r28
    3e00:	1f 91       	pop	r17
    3e02:	0f 91       	pop	r16
    3e04:	ff 90       	pop	r15
    3e06:	ef 90       	pop	r14
    3e08:	df 90       	pop	r13
    3e0a:	cf 90       	pop	r12
    3e0c:	08 95       	ret

00003e0e <csp_buffer_get>:
    3e0e:	cf 93       	push	r28
    3e10:	df 93       	push	r29
    3e12:	1f 92       	push	r1
    3e14:	1f 92       	push	r1
    3e16:	cd b7       	in	r28, 0x3d	; 61
    3e18:	de b7       	in	r29, 0x3e	; 62
    3e1a:	19 82       	std	Y+1, r1	; 0x01
    3e1c:	1a 82       	std	Y+2, r1	; 0x02
    3e1e:	0e 96       	adiw	r24, 0x0e	; 14
    3e20:	20 91 31 39 	lds	r18, 0x3931
    3e24:	30 91 32 39 	lds	r19, 0x3932
    3e28:	28 17       	cp	r18, r24
    3e2a:	39 07       	cpc	r19, r25
    3e2c:	e8 f0       	brcs	.+58     	; 0x3e68 <csp_buffer_get+0x5a>
    3e2e:	20 e0       	ldi	r18, 0x00	; 0
    3e30:	30 e0       	ldi	r19, 0x00	; 0
    3e32:	a9 01       	movw	r20, r18
    3e34:	be 01       	movw	r22, r28
    3e36:	6f 5f       	subi	r22, 0xFF	; 255
    3e38:	7f 4f       	sbci	r23, 0xFF	; 255
    3e3a:	80 91 37 39 	lds	r24, 0x3937
    3e3e:	90 91 38 39 	lds	r25, 0x3938
    3e42:	3f de       	rcall	.-898    	; 0x3ac2 <csp_queue_dequeue>
    3e44:	e9 81       	ldd	r30, Y+1	; 0x01
    3e46:	fa 81       	ldd	r31, Y+2	; 0x02
    3e48:	30 97       	sbiw	r30, 0x00	; 0
    3e4a:	89 f0       	breq	.+34     	; 0x3e6e <csp_buffer_get+0x60>
    3e4c:	82 81       	ldd	r24, Z+2	; 0x02
    3e4e:	93 81       	ldd	r25, Z+3	; 0x03
    3e50:	e8 17       	cp	r30, r24
    3e52:	f9 07       	cpc	r31, r25
    3e54:	79 f4       	brne	.+30     	; 0x3e74 <csp_buffer_get+0x66>
    3e56:	80 81       	ld	r24, Z
    3e58:	91 81       	ldd	r25, Z+1	; 0x01
    3e5a:	01 96       	adiw	r24, 0x01	; 1
    3e5c:	80 83       	st	Z, r24
    3e5e:	91 83       	std	Z+1, r25	; 0x01
    3e60:	89 81       	ldd	r24, Y+1	; 0x01
    3e62:	9a 81       	ldd	r25, Y+2	; 0x02
    3e64:	04 96       	adiw	r24, 0x04	; 4
    3e66:	08 c0       	rjmp	.+16     	; 0x3e78 <csp_buffer_get+0x6a>
    3e68:	80 e0       	ldi	r24, 0x00	; 0
    3e6a:	90 e0       	ldi	r25, 0x00	; 0
    3e6c:	05 c0       	rjmp	.+10     	; 0x3e78 <csp_buffer_get+0x6a>
    3e6e:	80 e0       	ldi	r24, 0x00	; 0
    3e70:	90 e0       	ldi	r25, 0x00	; 0
    3e72:	02 c0       	rjmp	.+4      	; 0x3e78 <csp_buffer_get+0x6a>
    3e74:	80 e0       	ldi	r24, 0x00	; 0
    3e76:	90 e0       	ldi	r25, 0x00	; 0
    3e78:	0f 90       	pop	r0
    3e7a:	0f 90       	pop	r0
    3e7c:	df 91       	pop	r29
    3e7e:	cf 91       	pop	r28
    3e80:	08 95       	ret

00003e82 <csp_buffer_free_isr>:
    3e82:	cf 93       	push	r28
    3e84:	df 93       	push	r29
    3e86:	00 d0       	rcall	.+0      	; 0x3e88 <csp_buffer_free_isr+0x6>
    3e88:	cd b7       	in	r28, 0x3d	; 61
    3e8a:	de b7       	in	r29, 0x3e	; 62
    3e8c:	19 82       	std	Y+1, r1	; 0x01
    3e8e:	00 97       	sbiw	r24, 0x00	; 0
    3e90:	51 f1       	breq	.+84     	; 0x3ee6 <csp_buffer_free_isr+0x64>
    3e92:	9c 01       	movw	r18, r24
    3e94:	24 50       	subi	r18, 0x04	; 4
    3e96:	31 09       	sbc	r19, r1
    3e98:	2a 83       	std	Y+2, r18	; 0x02
    3e9a:	3b 83       	std	Y+3, r19	; 0x03
    3e9c:	20 fd       	sbrc	r18, 0
    3e9e:	23 c0       	rjmp	.+70     	; 0x3ee6 <csp_buffer_free_isr+0x64>
    3ea0:	f9 01       	movw	r30, r18
    3ea2:	42 81       	ldd	r20, Z+2	; 0x02
    3ea4:	53 81       	ldd	r21, Z+3	; 0x03
    3ea6:	24 17       	cp	r18, r20
    3ea8:	35 07       	cpc	r19, r21
    3eaa:	e9 f4       	brne	.+58     	; 0x3ee6 <csp_buffer_free_isr+0x64>
    3eac:	f9 01       	movw	r30, r18
    3eae:	20 81       	ld	r18, Z
    3eb0:	31 81       	ldd	r19, Z+1	; 0x01
    3eb2:	21 15       	cp	r18, r1
    3eb4:	31 05       	cpc	r19, r1
    3eb6:	b9 f0       	breq	.+46     	; 0x3ee6 <csp_buffer_free_isr+0x64>
    3eb8:	22 30       	cpi	r18, 0x02	; 2
    3eba:	31 05       	cpc	r19, r1
    3ebc:	28 f0       	brcs	.+10     	; 0x3ec8 <csp_buffer_free_isr+0x46>
    3ebe:	21 50       	subi	r18, 0x01	; 1
    3ec0:	31 09       	sbc	r19, r1
    3ec2:	20 83       	st	Z, r18
    3ec4:	31 83       	std	Z+1, r19	; 0x01
    3ec6:	0f c0       	rjmp	.+30     	; 0x3ee6 <csp_buffer_free_isr+0x64>
    3ec8:	fc 01       	movw	r30, r24
    3eca:	34 97       	sbiw	r30, 0x04	; 4
    3ecc:	10 82       	st	Z, r1
    3ece:	11 82       	std	Z+1, r1	; 0x01
    3ed0:	ae 01       	movw	r20, r28
    3ed2:	4f 5f       	subi	r20, 0xFF	; 255
    3ed4:	5f 4f       	sbci	r21, 0xFF	; 255
    3ed6:	be 01       	movw	r22, r28
    3ed8:	6e 5f       	subi	r22, 0xFE	; 254
    3eda:	7f 4f       	sbci	r23, 0xFF	; 255
    3edc:	80 91 37 39 	lds	r24, 0x3937
    3ee0:	90 91 38 39 	lds	r25, 0x3938
    3ee4:	e9 dd       	rcall	.-1070   	; 0x3ab8 <csp_queue_enqueue_isr>
    3ee6:	23 96       	adiw	r28, 0x03	; 3
    3ee8:	cd bf       	out	0x3d, r28	; 61
    3eea:	de bf       	out	0x3e, r29	; 62
    3eec:	df 91       	pop	r29
    3eee:	cf 91       	pop	r28
    3ef0:	08 95       	ret

00003ef2 <csp_buffer_free>:
    3ef2:	cf 93       	push	r28
    3ef4:	df 93       	push	r29
    3ef6:	1f 92       	push	r1
    3ef8:	1f 92       	push	r1
    3efa:	cd b7       	in	r28, 0x3d	; 61
    3efc:	de b7       	in	r29, 0x3e	; 62
    3efe:	00 97       	sbiw	r24, 0x00	; 0
    3f00:	51 f1       	breq	.+84     	; 0x3f56 <csp_buffer_free+0x64>
    3f02:	9c 01       	movw	r18, r24
    3f04:	24 50       	subi	r18, 0x04	; 4
    3f06:	31 09       	sbc	r19, r1
    3f08:	29 83       	std	Y+1, r18	; 0x01
    3f0a:	3a 83       	std	Y+2, r19	; 0x02
    3f0c:	20 fd       	sbrc	r18, 0
    3f0e:	23 c0       	rjmp	.+70     	; 0x3f56 <csp_buffer_free+0x64>
    3f10:	f9 01       	movw	r30, r18
    3f12:	42 81       	ldd	r20, Z+2	; 0x02
    3f14:	53 81       	ldd	r21, Z+3	; 0x03
    3f16:	24 17       	cp	r18, r20
    3f18:	35 07       	cpc	r19, r21
    3f1a:	e9 f4       	brne	.+58     	; 0x3f56 <csp_buffer_free+0x64>
    3f1c:	f9 01       	movw	r30, r18
    3f1e:	20 81       	ld	r18, Z
    3f20:	31 81       	ldd	r19, Z+1	; 0x01
    3f22:	21 15       	cp	r18, r1
    3f24:	31 05       	cpc	r19, r1
    3f26:	b9 f0       	breq	.+46     	; 0x3f56 <csp_buffer_free+0x64>
    3f28:	22 30       	cpi	r18, 0x02	; 2
    3f2a:	31 05       	cpc	r19, r1
    3f2c:	28 f0       	brcs	.+10     	; 0x3f38 <csp_buffer_free+0x46>
    3f2e:	21 50       	subi	r18, 0x01	; 1
    3f30:	31 09       	sbc	r19, r1
    3f32:	20 83       	st	Z, r18
    3f34:	31 83       	std	Z+1, r19	; 0x01
    3f36:	0f c0       	rjmp	.+30     	; 0x3f56 <csp_buffer_free+0x64>
    3f38:	fc 01       	movw	r30, r24
    3f3a:	34 97       	sbiw	r30, 0x04	; 4
    3f3c:	10 82       	st	Z, r1
    3f3e:	11 82       	std	Z+1, r1	; 0x01
    3f40:	20 e0       	ldi	r18, 0x00	; 0
    3f42:	30 e0       	ldi	r19, 0x00	; 0
    3f44:	a9 01       	movw	r20, r18
    3f46:	be 01       	movw	r22, r28
    3f48:	6f 5f       	subi	r22, 0xFF	; 255
    3f4a:	7f 4f       	sbci	r23, 0xFF	; 255
    3f4c:	80 91 37 39 	lds	r24, 0x3937
    3f50:	90 91 38 39 	lds	r25, 0x3938
    3f54:	9e dd       	rcall	.-1220   	; 0x3a92 <csp_queue_enqueue>
    3f56:	0f 90       	pop	r0
    3f58:	0f 90       	pop	r0
    3f5a:	df 91       	pop	r29
    3f5c:	cf 91       	pop	r28
    3f5e:	08 95       	ret

00003f60 <csp_buffer_remaining>:

int csp_buffer_remaining(void) {
	return csp_queue_size(csp_buffers);
    3f60:	80 91 37 39 	lds	r24, 0x3937
    3f64:	90 91 38 39 	lds	r25, 0x3938
    3f68:	bf cd       	rjmp	.-1154   	; 0x3ae8 <csp_queue_size>
}
    3f6a:	08 95       	ret

00003f6c <csp_conn_enqueue_packet>:
#endif

	/* We have a successful connection */
	return conn;

}
    3f6c:	cf 93       	push	r28
    3f6e:	df 93       	push	r29
    3f70:	1f 92       	push	r1
    3f72:	1f 92       	push	r1
    3f74:	cd b7       	in	r28, 0x3d	; 61
    3f76:	de b7       	in	r29, 0x3e	; 62
    3f78:	69 83       	std	Y+1, r22	; 0x01
    3f7a:	7a 83       	std	Y+2, r23	; 0x02
    3f7c:	00 97       	sbiw	r24, 0x00	; 0
    3f7e:	a9 f0       	breq	.+42     	; 0x3faa <csp_conn_enqueue_packet+0x3e>
    3f80:	20 e0       	ldi	r18, 0x00	; 0
    3f82:	30 e0       	ldi	r19, 0x00	; 0
    3f84:	a9 01       	movw	r20, r18
    3f86:	be 01       	movw	r22, r28
    3f88:	6f 5f       	subi	r22, 0xFF	; 255
    3f8a:	7f 4f       	sbci	r23, 0xFF	; 255
    3f8c:	fc 01       	movw	r30, r24
    3f8e:	84 85       	ldd	r24, Z+12	; 0x0c
    3f90:	95 85       	ldd	r25, Z+13	; 0x0d
    3f92:	7f dd       	rcall	.-1282   	; 0x3a92 <csp_queue_enqueue>
    3f94:	21 e0       	ldi	r18, 0x01	; 1
    3f96:	30 e0       	ldi	r19, 0x00	; 0
    3f98:	01 97       	sbiw	r24, 0x01	; 1
    3f9a:	11 f4       	brne	.+4      	; 0x3fa0 <csp_conn_enqueue_packet+0x34>
    3f9c:	20 e0       	ldi	r18, 0x00	; 0
    3f9e:	30 e0       	ldi	r19, 0x00	; 0
    3fa0:	88 27       	eor	r24, r24
    3fa2:	99 27       	eor	r25, r25
    3fa4:	82 1b       	sub	r24, r18
    3fa6:	93 0b       	sbc	r25, r19
    3fa8:	02 c0       	rjmp	.+4      	; 0x3fae <csp_conn_enqueue_packet+0x42>
    3faa:	8e ef       	ldi	r24, 0xFE	; 254
    3fac:	9f ef       	ldi	r25, 0xFF	; 255
    3fae:	0f 90       	pop	r0
    3fb0:	0f 90       	pop	r0
    3fb2:	df 91       	pop	r29
    3fb4:	cf 91       	pop	r28
    3fb6:	08 95       	ret

00003fb8 <csp_conn_init>:
    3fb8:	0f 93       	push	r16
    3fba:	1f 93       	push	r17
    3fbc:	cf 93       	push	r28
    3fbe:	df 93       	push	r29
    3fc0:	7f de       	rcall	.-770    	; 0x3cc0 <csp_get_ms>
    3fc2:	cb 01       	movw	r24, r22
    3fc4:	0e 94 65 40 	call	0x80ca	; 0x80ca <srand>
    3fc8:	0e 94 62 40 	call	0x80c4	; 0x80c4 <rand>
    3fcc:	8f 71       	andi	r24, 0x1F	; 31
    3fce:	90 78       	andi	r25, 0x80	; 128
    3fd0:	99 23       	and	r25, r25
    3fd2:	24 f4       	brge	.+8      	; 0x3fdc <csp_conn_init+0x24>
    3fd4:	01 97       	sbiw	r24, 0x01	; 1
    3fd6:	80 6e       	ori	r24, 0xE0	; 224
    3fd8:	9f 6f       	ori	r25, 0xFF	; 255
    3fda:	01 96       	adiw	r24, 0x01	; 1
    3fdc:	80 5e       	subi	r24, 0xE0	; 224
    3fde:	80 93 3c 39 	sts	0x393C, r24
    3fe2:	8a e3       	ldi	r24, 0x3A	; 58
    3fe4:	99 e3       	ldi	r25, 0x39	; 57
    3fe6:	96 dd       	rcall	.-1236   	; 0x3b14 <csp_bin_sem_create>
    3fe8:	01 97       	sbiw	r24, 0x01	; 1
    3fea:	31 f5       	brne	.+76     	; 0x4038 <__stack+0x39>
    3fec:	c1 e4       	ldi	r28, 0x41	; 65
    3fee:	d9 e3       	ldi	r29, 0x39	; 57
    3ff0:	01 e3       	ldi	r16, 0x31	; 49
    3ff2:	1a e3       	ldi	r17, 0x3A	; 58
    3ff4:	04 c0       	rjmp	.+8      	; 0x3ffe <csp_conn_init+0x46>
    3ff6:	68 96       	adiw	r28, 0x18	; 24
    3ff8:	c0 17       	cp	r28, r16
    3ffa:	d1 07       	cpc	r29, r17
    3ffc:	79 f0       	breq	.+30     	; 0x401c <__stack+0x1d>
    3ffe:	62 e0       	ldi	r22, 0x02	; 2
    4000:	70 e0       	ldi	r23, 0x00	; 0
    4002:	8a e0       	ldi	r24, 0x0A	; 10
    4004:	90 e0       	ldi	r25, 0x00	; 0
    4006:	41 dd       	rcall	.-1406   	; 0x3a8a <csp_queue_create>
    4008:	8a 87       	std	Y+10, r24	; 0x0a
    400a:	9b 87       	std	Y+11, r25	; 0x0b
    400c:	fe 01       	movw	r30, r28
    400e:	31 97       	sbiw	r30, 0x01	; 1
    4010:	10 82       	st	Z, r1
    4012:	ce 01       	movw	r24, r28
    4014:	6d dd       	rcall	.-1318   	; 0x3af0 <csp_mutex_create>
    4016:	01 97       	sbiw	r24, 0x01	; 1
    4018:	71 f3       	breq	.-36     	; 0x3ff6 <csp_conn_init+0x3e>
    401a:	11 c0       	rjmp	.+34     	; 0x403e <__stack+0x3f>
    401c:	8d e3       	ldi	r24, 0x3D	; 61
    401e:	99 e3       	ldi	r25, 0x39	; 57
    4020:	79 dd       	rcall	.-1294   	; 0x3b14 <csp_bin_sem_create>
    4022:	21 e0       	ldi	r18, 0x01	; 1
    4024:	30 e0       	ldi	r19, 0x00	; 0
    4026:	01 97       	sbiw	r24, 0x01	; 1
    4028:	11 f4       	brne	.+4      	; 0x402e <__stack+0x2f>
    402a:	20 e0       	ldi	r18, 0x00	; 0
    402c:	30 e0       	ldi	r19, 0x00	; 0
    402e:	88 27       	eor	r24, r24
    4030:	99 27       	eor	r25, r25
    4032:	82 1b       	sub	r24, r18
    4034:	93 0b       	sbc	r25, r19
    4036:	05 c0       	rjmp	.+10     	; 0x4042 <__stack+0x43>
    4038:	8f ef       	ldi	r24, 0xFF	; 255
    403a:	9f ef       	ldi	r25, 0xFF	; 255
    403c:	02 c0       	rjmp	.+4      	; 0x4042 <__stack+0x43>
    403e:	8f ef       	ldi	r24, 0xFF	; 255
    4040:	9f ef       	ldi	r25, 0xFF	; 255
    4042:	df 91       	pop	r29
    4044:	cf 91       	pop	r28
    4046:	1f 91       	pop	r17
    4048:	0f 91       	pop	r16
    404a:	08 95       	ret

0000404c <csp_conn_find>:
    404c:	cf 92       	push	r12
    404e:	df 92       	push	r13
    4050:	ef 92       	push	r14
    4052:	ff 92       	push	r15
    4054:	0f 93       	push	r16
    4056:	1f 93       	push	r17
    4058:	cf 93       	push	r28
    405a:	df 93       	push	r29
    405c:	ef e3       	ldi	r30, 0x3F	; 63
    405e:	f9 e3       	ldi	r31, 0x39	; 57
    4060:	0f e2       	ldi	r16, 0x2F	; 47
    4062:	1a e3       	ldi	r17, 0x3A	; 58
    4064:	ef 01       	movw	r28, r30
    4066:	a1 81       	ldd	r26, Z+1	; 0x01
    4068:	aa 23       	and	r26, r26
    406a:	99 f0       	breq	.+38     	; 0x4092 <csp_conn_find+0x46>
    406c:	a0 81       	ld	r26, Z
    406e:	a1 11       	cpse	r26, r1
    4070:	10 c0       	rjmp	.+32     	; 0x4092 <csp_conn_find+0x46>
    4072:	c4 80       	ldd	r12, Z+4	; 0x04
    4074:	d5 80       	ldd	r13, Z+5	; 0x05
    4076:	e6 80       	ldd	r14, Z+6	; 0x06
    4078:	f7 80       	ldd	r15, Z+7	; 0x07
    407a:	c6 26       	eor	r12, r22
    407c:	d7 26       	eor	r13, r23
    407e:	e8 26       	eor	r14, r24
    4080:	f9 26       	eor	r15, r25
    4082:	c2 22       	and	r12, r18
    4084:	d3 22       	and	r13, r19
    4086:	e4 22       	and	r14, r20
    4088:	f5 22       	and	r15, r21
    408a:	cd 28       	or	r12, r13
    408c:	ce 28       	or	r12, r14
    408e:	cf 28       	or	r12, r15
    4090:	29 f0       	breq	.+10     	; 0x409c <csp_conn_find+0x50>
    4092:	78 96       	adiw	r30, 0x18	; 24
    4094:	e0 17       	cp	r30, r16
    4096:	f1 07       	cpc	r31, r17
    4098:	29 f7       	brne	.-54     	; 0x4064 <csp_conn_find+0x18>
    409a:	03 c0       	rjmp	.+6      	; 0x40a2 <csp_conn_find+0x56>
    409c:	8e 2f       	mov	r24, r30
    409e:	9d 2f       	mov	r25, r29
    40a0:	02 c0       	rjmp	.+4      	; 0x40a6 <csp_conn_find+0x5a>
    40a2:	80 e0       	ldi	r24, 0x00	; 0
    40a4:	90 e0       	ldi	r25, 0x00	; 0
    40a6:	df 91       	pop	r29
    40a8:	cf 91       	pop	r28
    40aa:	1f 91       	pop	r17
    40ac:	0f 91       	pop	r16
    40ae:	ff 90       	pop	r15
    40b0:	ef 90       	pop	r14
    40b2:	df 90       	pop	r13
    40b4:	cf 90       	pop	r12
    40b6:	08 95       	ret

000040b8 <csp_conn_flush_rx_queue>:
    40b8:	0f 93       	push	r16
    40ba:	1f 93       	push	r17
    40bc:	cf 93       	push	r28
    40be:	df 93       	push	r29
    40c0:	1f 92       	push	r1
    40c2:	1f 92       	push	r1
    40c4:	cd b7       	in	r28, 0x3d	; 61
    40c6:	de b7       	in	r29, 0x3e	; 62
    40c8:	8c 01       	movw	r16, r24
    40ca:	05 c0       	rjmp	.+10     	; 0x40d6 <csp_conn_flush_rx_queue+0x1e>
    40cc:	89 81       	ldd	r24, Y+1	; 0x01
    40ce:	9a 81       	ldd	r25, Y+2	; 0x02
    40d0:	00 97       	sbiw	r24, 0x00	; 0
    40d2:	09 f0       	breq	.+2      	; 0x40d6 <csp_conn_flush_rx_queue+0x1e>
    40d4:	0e df       	rcall	.-484    	; 0x3ef2 <csp_buffer_free>
    40d6:	20 e0       	ldi	r18, 0x00	; 0
    40d8:	30 e0       	ldi	r19, 0x00	; 0
    40da:	a9 01       	movw	r20, r18
    40dc:	be 01       	movw	r22, r28
    40de:	6f 5f       	subi	r22, 0xFF	; 255
    40e0:	7f 4f       	sbci	r23, 0xFF	; 255
    40e2:	f8 01       	movw	r30, r16
    40e4:	84 85       	ldd	r24, Z+12	; 0x0c
    40e6:	95 85       	ldd	r25, Z+13	; 0x0d
    40e8:	ec dc       	rcall	.-1576   	; 0x3ac2 <csp_queue_dequeue>
    40ea:	01 97       	sbiw	r24, 0x01	; 1
    40ec:	79 f3       	breq	.-34     	; 0x40cc <csp_conn_flush_rx_queue+0x14>
    40ee:	80 e0       	ldi	r24, 0x00	; 0
    40f0:	90 e0       	ldi	r25, 0x00	; 0
    40f2:	0f 90       	pop	r0
    40f4:	0f 90       	pop	r0
    40f6:	df 91       	pop	r29
    40f8:	cf 91       	pop	r28
    40fa:	1f 91       	pop	r17
    40fc:	0f 91       	pop	r16
    40fe:	08 95       	ret

00004100 <csp_conn_allocate>:
    4100:	1f 93       	push	r17
    4102:	cf 93       	push	r28
    4104:	df 93       	push	r29
    4106:	18 2f       	mov	r17, r24
    4108:	44 e6       	ldi	r20, 0x64	; 100
    410a:	50 e0       	ldi	r21, 0x00	; 0
    410c:	60 e0       	ldi	r22, 0x00	; 0
    410e:	70 e0       	ldi	r23, 0x00	; 0
    4110:	8d e3       	ldi	r24, 0x3D	; 61
    4112:	99 e3       	ldi	r25, 0x39	; 57
    4114:	17 dd       	rcall	.-1490   	; 0x3b44 <csp_bin_sem_wait>
    4116:	01 97       	sbiw	r24, 0x01	; 1
    4118:	09 f0       	breq	.+2      	; 0x411c <csp_conn_allocate+0x1c>
    411a:	47 c0       	rjmp	.+142    	; 0x41aa <csp_conn_allocate+0xaa>
    411c:	80 91 39 39 	lds	r24, 0x3939
    4120:	90 e0       	ldi	r25, 0x00	; 0
    4122:	01 96       	adiw	r24, 0x01	; 1
    4124:	6a e0       	ldi	r22, 0x0A	; 10
    4126:	70 e0       	ldi	r23, 0x00	; 0
    4128:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <__divmodhi4>
    412c:	ec 01       	movw	r28, r24
    412e:	cc 0f       	add	r28, r28
    4130:	dd 1f       	adc	r29, r29
    4132:	c8 0f       	add	r28, r24
    4134:	d9 1f       	adc	r29, r25
    4136:	cc 0f       	add	r28, r28
    4138:	dd 1f       	adc	r29, r29
    413a:	cc 0f       	add	r28, r28
    413c:	dd 1f       	adc	r29, r29
    413e:	cc 0f       	add	r28, r28
    4140:	dd 1f       	adc	r29, r29
    4142:	c1 5c       	subi	r28, 0xC1	; 193
    4144:	d6 4c       	sbci	r29, 0xC6	; 198
    4146:	49 81       	ldd	r20, Y+1	; 0x01
    4148:	41 11       	cpse	r20, r1
    414a:	32 c0       	rjmp	.+100    	; 0x41b0 <csp_conn_allocate+0xb0>
    414c:	21 c0       	rjmp	.+66     	; 0x4190 <csp_conn_allocate+0x90>
    414e:	ec 01       	movw	r28, r24
    4150:	cc 0f       	add	r28, r28
    4152:	dd 1f       	adc	r29, r29
    4154:	c8 0f       	add	r28, r24
    4156:	d9 1f       	adc	r29, r25
    4158:	cc 0f       	add	r28, r28
    415a:	dd 1f       	adc	r29, r29
    415c:	cc 0f       	add	r28, r28
    415e:	dd 1f       	adc	r29, r29
    4160:	cc 0f       	add	r28, r28
    4162:	dd 1f       	adc	r29, r29
    4164:	c1 5c       	subi	r28, 0xC1	; 193
    4166:	d6 4c       	sbci	r29, 0xC6	; 198
    4168:	49 81       	ldd	r20, Y+1	; 0x01
    416a:	44 23       	and	r20, r20
    416c:	89 f0       	breq	.+34     	; 0x4190 <csp_conn_allocate+0x90>
    416e:	01 96       	adiw	r24, 0x01	; 1
    4170:	bf 01       	movw	r22, r30
    4172:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <__divmodhi4>
    4176:	21 50       	subi	r18, 0x01	; 1
    4178:	31 09       	sbc	r19, r1
    417a:	21 15       	cp	r18, r1
    417c:	31 05       	cpc	r19, r1
    417e:	39 f7       	brne	.-50     	; 0x414e <csp_conn_allocate+0x4e>
    4180:	41 30       	cpi	r20, 0x01	; 1
    4182:	31 f4       	brne	.+12     	; 0x4190 <csp_conn_allocate+0x90>
    4184:	8d e3       	ldi	r24, 0x3D	; 61
    4186:	99 e3       	ldi	r25, 0x39	; 57
    4188:	f7 dc       	rcall	.-1554   	; 0x3b78 <csp_bin_sem_post>
    418a:	80 e0       	ldi	r24, 0x00	; 0
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	1a c0       	rjmp	.+52     	; 0x41c4 <csp_conn_allocate+0xc4>
    4190:	91 e0       	ldi	r25, 0x01	; 1
    4192:	99 83       	std	Y+1, r25	; 0x01
    4194:	1e 86       	std	Y+14, r1	; 0x0e
    4196:	1f 86       	std	Y+15, r1	; 0x0f
    4198:	18 83       	st	Y, r17
    419a:	80 93 39 39 	sts	0x3939, r24
    419e:	8d e3       	ldi	r24, 0x3D	; 61
    41a0:	99 e3       	ldi	r25, 0x39	; 57
    41a2:	ea dc       	rcall	.-1580   	; 0x3b78 <csp_bin_sem_post>
    41a4:	8c 2f       	mov	r24, r28
    41a6:	9d 2f       	mov	r25, r29
    41a8:	0d c0       	rjmp	.+26     	; 0x41c4 <csp_conn_allocate+0xc4>
    41aa:	80 e0       	ldi	r24, 0x00	; 0
    41ac:	90 e0       	ldi	r25, 0x00	; 0
    41ae:	0a c0       	rjmp	.+20     	; 0x41c4 <csp_conn_allocate+0xc4>
    41b0:	01 96       	adiw	r24, 0x01	; 1
    41b2:	6a e0       	ldi	r22, 0x0A	; 10
    41b4:	70 e0       	ldi	r23, 0x00	; 0
    41b6:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <__divmodhi4>
    41ba:	29 e0       	ldi	r18, 0x09	; 9
    41bc:	30 e0       	ldi	r19, 0x00	; 0
    41be:	ea e0       	ldi	r30, 0x0A	; 10
    41c0:	f0 e0       	ldi	r31, 0x00	; 0
    41c2:	c5 cf       	rjmp	.-118    	; 0x414e <csp_conn_allocate+0x4e>
    41c4:	df 91       	pop	r29
    41c6:	cf 91       	pop	r28
    41c8:	1f 91       	pop	r17
    41ca:	08 95       	ret

000041cc <csp_conn_new>:
    41cc:	8f 92       	push	r8
    41ce:	9f 92       	push	r9
    41d0:	af 92       	push	r10
    41d2:	bf 92       	push	r11
    41d4:	cf 92       	push	r12
    41d6:	df 92       	push	r13
    41d8:	ef 92       	push	r14
    41da:	ff 92       	push	r15
    41dc:	cf 93       	push	r28
    41de:	df 93       	push	r29
    41e0:	4b 01       	movw	r8, r22
    41e2:	5c 01       	movw	r10, r24
    41e4:	69 01       	movw	r12, r18
    41e6:	7a 01       	movw	r14, r20
    41e8:	80 e0       	ldi	r24, 0x00	; 0
    41ea:	8a df       	rcall	.-236    	; 0x4100 <csp_conn_allocate>
    41ec:	ec 01       	movw	r28, r24
    41ee:	00 97       	sbiw	r24, 0x00	; 0
    41f0:	79 f0       	breq	.+30     	; 0x4210 <csp_conn_new+0x44>
    41f2:	8c 82       	std	Y+4, r8	; 0x04
    41f4:	9d 82       	std	Y+5, r9	; 0x05
    41f6:	ae 82       	std	Y+6, r10	; 0x06
    41f8:	bf 82       	std	Y+7, r11	; 0x07
    41fa:	c8 86       	std	Y+8, r12	; 0x08
    41fc:	d9 86       	std	Y+9, r13	; 0x09
    41fe:	ea 86       	std	Y+10, r14	; 0x0a
    4200:	fb 86       	std	Y+11, r15	; 0x0b
    4202:	5e dd       	rcall	.-1348   	; 0x3cc0 <csp_get_ms>
    4204:	68 8b       	std	Y+16, r22	; 0x10
    4206:	79 8b       	std	Y+17, r23	; 0x11
    4208:	8a 8b       	std	Y+18, r24	; 0x12
    420a:	9b 8b       	std	Y+19, r25	; 0x13
    420c:	ce 01       	movw	r24, r28
    420e:	54 df       	rcall	.-344    	; 0x40b8 <csp_conn_flush_rx_queue>
    4210:	ce 01       	movw	r24, r28
    4212:	df 91       	pop	r29
    4214:	cf 91       	pop	r28
    4216:	ff 90       	pop	r15
    4218:	ef 90       	pop	r14
    421a:	df 90       	pop	r13
    421c:	cf 90       	pop	r12
    421e:	bf 90       	pop	r11
    4220:	af 90       	pop	r10
    4222:	9f 90       	pop	r9
    4224:	8f 90       	pop	r8
    4226:	08 95       	ret

00004228 <csp_close>:
    4228:	cf 93       	push	r28
    422a:	df 93       	push	r29
    422c:	ec 01       	movw	r28, r24
    422e:	00 97       	sbiw	r24, 0x00	; 0
    4230:	a9 f0       	breq	.+42     	; 0x425c <csp_close+0x34>
    4232:	89 81       	ldd	r24, Y+1	; 0x01
    4234:	88 23       	and	r24, r24
    4236:	a9 f0       	breq	.+42     	; 0x4262 <csp_close+0x3a>
    4238:	44 e6       	ldi	r20, 0x64	; 100
    423a:	50 e0       	ldi	r21, 0x00	; 0
    423c:	60 e0       	ldi	r22, 0x00	; 0
    423e:	70 e0       	ldi	r23, 0x00	; 0
    4240:	8d e3       	ldi	r24, 0x3D	; 61
    4242:	99 e3       	ldi	r25, 0x39	; 57
    4244:	7f dc       	rcall	.-1794   	; 0x3b44 <csp_bin_sem_wait>
    4246:	01 97       	sbiw	r24, 0x01	; 1
    4248:	79 f4       	brne	.+30     	; 0x4268 <csp_close+0x40>
    424a:	19 82       	std	Y+1, r1	; 0x01
    424c:	ce 01       	movw	r24, r28
    424e:	34 df       	rcall	.-408    	; 0x40b8 <csp_conn_flush_rx_queue>
    4250:	8d e3       	ldi	r24, 0x3D	; 61
    4252:	99 e3       	ldi	r25, 0x39	; 57
    4254:	91 dc       	rcall	.-1758   	; 0x3b78 <csp_bin_sem_post>
    4256:	80 e0       	ldi	r24, 0x00	; 0
    4258:	90 e0       	ldi	r25, 0x00	; 0
    425a:	08 c0       	rjmp	.+16     	; 0x426c <csp_close+0x44>
    425c:	8e ef       	ldi	r24, 0xFE	; 254
    425e:	9f ef       	ldi	r25, 0xFF	; 255
    4260:	05 c0       	rjmp	.+10     	; 0x426c <csp_close+0x44>
    4262:	80 e0       	ldi	r24, 0x00	; 0
    4264:	90 e0       	ldi	r25, 0x00	; 0
    4266:	02 c0       	rjmp	.+4      	; 0x426c <csp_close+0x44>
    4268:	8d ef       	ldi	r24, 0xFD	; 253
    426a:	9f ef       	ldi	r25, 0xFF	; 255
    426c:	df 91       	pop	r29
    426e:	cf 91       	pop	r28
    4270:	08 95       	ret

00004272 <csp_conn_dport>:

inline int csp_conn_dport(csp_conn_t * conn) {
    4272:	fc 01       	movw	r30, r24

	return conn->idin.dport;
    4274:	95 81       	ldd	r25, Z+5	; 0x05
    4276:	92 95       	swap	r25
    4278:	96 95       	lsr	r25
    427a:	96 95       	lsr	r25
    427c:	93 70       	andi	r25, 0x03	; 3
    427e:	86 81       	ldd	r24, Z+6	; 0x06
    4280:	8f 70       	andi	r24, 0x0F	; 15
    4282:	88 0f       	add	r24, r24
    4284:	88 0f       	add	r24, r24
    4286:	89 2b       	or	r24, r25

}
    4288:	90 e0       	ldi	r25, 0x00	; 0
    428a:	08 95       	ret

0000428c <csp_crc32_memory>:
		0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
		0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
		0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
    428c:	8f 92       	push	r8
    428e:	9f 92       	push	r9
    4290:	af 92       	push	r10
    4292:	bf 92       	push	r11
    4294:	cf 92       	push	r12
    4296:	df 92       	push	r13
    4298:	ef 92       	push	r14
    429a:	ff 92       	push	r15
    429c:	0f 93       	push	r16
    429e:	1f 93       	push	r17
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    42a0:	8a 01       	movw	r16, r20
    42a2:	9b 01       	movw	r18, r22
    42a4:	01 50       	subi	r16, 0x01	; 1
    42a6:	11 09       	sbc	r17, r1
    42a8:	21 09       	sbc	r18, r1
    42aa:	31 09       	sbc	r19, r1
    42ac:	45 2b       	or	r20, r21
    42ae:	46 2b       	or	r20, r22
    42b0:	47 2b       	or	r20, r23
    42b2:	49 f1       	breq	.+82     	; 0x4306 <csp_crc32_memory+0x7a>
    42b4:	a8 2f       	mov	r26, r24
    42b6:	b9 2f       	mov	r27, r25
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    42b8:	88 24       	eor	r8, r8
    42ba:	8a 94       	dec	r8
    42bc:	98 2c       	mov	r9, r8
    42be:	54 01       	movw	r10, r8
   while (length--)
#ifdef __AVR__
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
    42c0:	4d 91       	ld	r20, X+
    42c2:	75 01       	movw	r14, r10
    42c4:	64 01       	movw	r12, r8
    42c6:	c4 26       	eor	r12, r20
    42c8:	dd 24       	eor	r13, r13
    42ca:	ee 24       	eor	r14, r14
    42cc:	ff 24       	eor	r15, r15
    42ce:	c6 01       	movw	r24, r12
    42d0:	88 0f       	add	r24, r24
    42d2:	99 1f       	adc	r25, r25
    42d4:	88 0f       	add	r24, r24
    42d6:	99 1f       	adc	r25, r25
    42d8:	fc 01       	movw	r30, r24
    42da:	e0 57       	subi	r30, 0x70	; 112
    42dc:	f1 4f       	sbci	r31, 0xF1	; 241
    42de:	c5 90       	lpm	r12, Z+
    42e0:	d5 90       	lpm	r13, Z+
    42e2:	e5 90       	lpm	r14, Z+
    42e4:	f4 90       	lpm	r15, Z
    42e6:	77 27       	eor	r23, r23
    42e8:	6b 2d       	mov	r22, r11
    42ea:	5a 2d       	mov	r21, r10
    42ec:	49 2d       	mov	r20, r9
    42ee:	4a 01       	movw	r8, r20
    42f0:	5b 01       	movw	r10, r22
    42f2:	8c 24       	eor	r8, r12
    42f4:	9d 24       	eor	r9, r13
    42f6:	ae 24       	eor	r10, r14
    42f8:	bf 24       	eor	r11, r15

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
   while (length--)
    42fa:	01 50       	subi	r16, 0x01	; 1
    42fc:	11 09       	sbc	r17, r1
    42fe:	21 09       	sbc	r18, r1
    4300:	31 09       	sbc	r19, r1
    4302:	f0 f6       	brcc	.-68     	; 0x42c0 <csp_crc32_memory+0x34>
    4304:	04 c0       	rjmp	.+8      	; 0x430e <csp_crc32_memory+0x82>
		0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351 };

uint32_t csp_crc32_memory(const uint8_t * data, uint32_t length) {
   uint32_t crc;

   crc = 0xFFFFFFFF;
    4306:	88 24       	eor	r8, r8
    4308:	8a 94       	dec	r8
    430a:	98 2c       	mov	r9, r8
    430c:	54 01       	movw	r10, r8
	   crc = pgm_read_dword(&crc_tab[(crc ^ *data++) & 0xFFL]) ^ (crc >> 8);
#else
	   crc = crc_tab[(crc ^ *data++) & 0xFFL] ^ (crc >> 8);
#endif

   return (crc ^ 0xFFFFFFFF);
    430e:	c5 01       	movw	r24, r10
    4310:	b4 01       	movw	r22, r8
    4312:	60 95       	com	r22
    4314:	70 95       	com	r23
    4316:	80 95       	com	r24
    4318:	90 95       	com	r25
}
    431a:	1f 91       	pop	r17
    431c:	0f 91       	pop	r16
    431e:	ff 90       	pop	r15
    4320:	ef 90       	pop	r14
    4322:	df 90       	pop	r13
    4324:	cf 90       	pop	r12
    4326:	bf 90       	pop	r11
    4328:	af 90       	pop	r10
    432a:	9f 90       	pop	r9
    432c:	8f 90       	pop	r8
    432e:	08 95       	ret

00004330 <csp_crc32_append>:

int csp_crc32_append(csp_packet_t * packet) {
    4330:	cf 93       	push	r28
    4332:	df 93       	push	r29
    4334:	ec 01       	movw	r28, r24

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    4336:	00 97       	sbiw	r24, 0x00	; 0
    4338:	b9 f0       	breq	.+46     	; 0x4368 <csp_crc32_append+0x38>
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	crc = csp_crc32_memory(packet->data, packet->length);
    433a:	48 85       	ldd	r20, Y+8	; 0x08
    433c:	59 85       	ldd	r21, Y+9	; 0x09
    433e:	60 e0       	ldi	r22, 0x00	; 0
    4340:	70 e0       	ldi	r23, 0x00	; 0
    4342:	0e 96       	adiw	r24, 0x0e	; 14
    4344:	a3 df       	rcall	.-186    	; 0x428c <csp_crc32_memory>
	crc = csp_hton32(crc);
    4346:	5e d0       	rcall	.+188    	; 0x4404 <csp_hton32>

	/* Copy checksum to packet */
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
    4348:	e8 85       	ldd	r30, Y+8	; 0x08
    434a:	f9 85       	ldd	r31, Y+9	; 0x09
    434c:	ec 0f       	add	r30, r28
    434e:	fd 1f       	adc	r31, r29
    4350:	66 87       	std	Z+14, r22	; 0x0e
    4352:	77 87       	std	Z+15, r23	; 0x0f
    4354:	80 8b       	std	Z+16, r24	; 0x10
    4356:	91 8b       	std	Z+17, r25	; 0x11
	packet->length += sizeof(uint32_t);
    4358:	88 85       	ldd	r24, Y+8	; 0x08
    435a:	99 85       	ldd	r25, Y+9	; 0x09
    435c:	04 96       	adiw	r24, 0x04	; 4
    435e:	88 87       	std	Y+8, r24	; 0x08
    4360:	99 87       	std	Y+9, r25	; 0x09

	return CSP_ERR_NONE;
    4362:	80 e0       	ldi	r24, 0x00	; 0
    4364:	90 e0       	ldi	r25, 0x00	; 0
    4366:	02 c0       	rjmp	.+4      	; 0x436c <csp_crc32_append+0x3c>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    4368:	8e ef       	ldi	r24, 0xFE	; 254
    436a:	9f ef       	ldi	r25, 0xFF	; 255
	memcpy(&packet->data[packet->length], &crc, sizeof(uint32_t));
	packet->length += sizeof(uint32_t);

	return CSP_ERR_NONE;

}
    436c:	df 91       	pop	r29
    436e:	cf 91       	pop	r28
    4370:	08 95       	ret

00004372 <csp_crc32_verify>:

int csp_crc32_verify(csp_packet_t * packet) {
    4372:	ef 92       	push	r14
    4374:	ff 92       	push	r15
    4376:	0f 93       	push	r16
    4378:	1f 93       	push	r17
    437a:	cf 93       	push	r28
    437c:	df 93       	push	r29
    437e:	00 d0       	rcall	.+0      	; 0x4380 <csp_crc32_verify+0xe>
    4380:	1f 92       	push	r1
    4382:	cd b7       	in	r28, 0x3d	; 61
    4384:	de b7       	in	r29, 0x3e	; 62
    4386:	8c 01       	movw	r16, r24

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
    4388:	00 97       	sbiw	r24, 0x00	; 0
    438a:	51 f1       	breq	.+84     	; 0x43e0 <csp_crc32_verify+0x6e>
		return CSP_ERR_INVAL;

	if (packet->length < sizeof(uint32_t))
    438c:	fc 01       	movw	r30, r24
    438e:	80 85       	ldd	r24, Z+8	; 0x08
    4390:	91 85       	ldd	r25, Z+9	; 0x09
    4392:	84 30       	cpi	r24, 0x04	; 4
    4394:	91 05       	cpc	r25, r1
    4396:	38 f1       	brcs	.+78     	; 0x43e6 <csp_crc32_verify+0x74>
		return CSP_ERR_INVAL;

	/* Calculate CRC32, convert to network byte order */
	crc = csp_crc32_memory(packet->data, packet->length - sizeof(uint32_t));
    4398:	ac 01       	movw	r20, r24
    439a:	44 50       	subi	r20, 0x04	; 4
    439c:	51 09       	sbc	r21, r1
    439e:	60 e0       	ldi	r22, 0x00	; 0
    43a0:	70 e0       	ldi	r23, 0x00	; 0
    43a2:	c8 01       	movw	r24, r16
    43a4:	0e 96       	adiw	r24, 0x0e	; 14
    43a6:	72 df       	rcall	.-284    	; 0x428c <csp_crc32_memory>
	crc = csp_hton32(crc);
    43a8:	2d d0       	rcall	.+90     	; 0x4404 <csp_hton32>
    43aa:	69 83       	std	Y+1, r22	; 0x01
    43ac:	7a 83       	std	Y+2, r23	; 0x02
    43ae:	8b 83       	std	Y+3, r24	; 0x03
    43b0:	9c 83       	std	Y+4, r25	; 0x04

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
    43b2:	f8 01       	movw	r30, r16
    43b4:	80 85       	ldd	r24, Z+8	; 0x08
    43b6:	91 85       	ldd	r25, Z+9	; 0x09
    43b8:	7c 01       	movw	r14, r24
    43ba:	f4 e0       	ldi	r31, 0x04	; 4
    43bc:	ef 1a       	sub	r14, r31
    43be:	f1 08       	sbc	r15, r1
    43c0:	0a 96       	adiw	r24, 0x0a	; 10
    43c2:	44 e0       	ldi	r20, 0x04	; 4
    43c4:	50 e0       	ldi	r21, 0x00	; 0
    43c6:	be 01       	movw	r22, r28
    43c8:	6f 5f       	subi	r22, 0xFF	; 255
    43ca:	7f 4f       	sbci	r23, 0xFF	; 255
    43cc:	80 0f       	add	r24, r16
    43ce:	91 1f       	adc	r25, r17
    43d0:	0e 94 53 41 	call	0x82a6	; 0x82a6 <memcmp>
    43d4:	00 97       	sbiw	r24, 0x00	; 0
    43d6:	51 f4       	brne	.+20     	; 0x43ec <csp_crc32_verify+0x7a>
		/* CRC32 failed */
		return CSP_ERR_INVAL;
	} else {
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
    43d8:	f8 01       	movw	r30, r16
    43da:	e0 86       	std	Z+8, r14	; 0x08
    43dc:	f1 86       	std	Z+9, r15	; 0x09
		return CSP_ERR_NONE;
    43de:	08 c0       	rjmp	.+16     	; 0x43f0 <csp_crc32_verify+0x7e>

	uint32_t crc;

	/* NULL pointer check */
	if (packet == NULL)
		return CSP_ERR_INVAL;
    43e0:	8e ef       	ldi	r24, 0xFE	; 254
    43e2:	9f ef       	ldi	r25, 0xFF	; 255
    43e4:	05 c0       	rjmp	.+10     	; 0x43f0 <csp_crc32_verify+0x7e>

	if (packet->length < sizeof(uint32_t))
		return CSP_ERR_INVAL;
    43e6:	8e ef       	ldi	r24, 0xFE	; 254
    43e8:	9f ef       	ldi	r25, 0xFF	; 255
    43ea:	02 c0       	rjmp	.+4      	; 0x43f0 <csp_crc32_verify+0x7e>
	crc = csp_hton32(crc);

	/* Compare calculated checksum with packet header */
	if (memcmp(&packet->data[packet->length] - sizeof(uint32_t), &crc, sizeof(uint32_t)) != 0) {
		/* CRC32 failed */
		return CSP_ERR_INVAL;
    43ec:	8e ef       	ldi	r24, 0xFE	; 254
    43ee:	9f ef       	ldi	r25, 0xFF	; 255
		/* Strip CRC32 */
		packet->length -= sizeof(uint32_t);
		return CSP_ERR_NONE;
	}

}
    43f0:	24 96       	adiw	r28, 0x04	; 4
    43f2:	cd bf       	out	0x3d, r28	; 61
    43f4:	de bf       	out	0x3e, r29	; 62
    43f6:	df 91       	pop	r29
    43f8:	cf 91       	pop	r28
    43fa:	1f 91       	pop	r17
    43fc:	0f 91       	pop	r16
    43fe:	ff 90       	pop	r15
    4400:	ef 90       	pop	r14
    4402:	08 95       	ret

00004404 <csp_hton32>:
inline uint16_t __attribute__ ((__const__)) csp_ntoh16(uint16_t n16) {
	return csp_hton16(n16);
}

/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
    4404:	cf 92       	push	r12
    4406:	df 92       	push	r13
    4408:	ef 92       	push	r14
    440a:	ff 92       	push	r15
    440c:	0f 93       	push	r16
    440e:	1f 93       	push	r17
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    4410:	f6 2e       	mov	r15, r22
    4412:	ee 24       	eor	r14, r14
    4414:	dd 24       	eor	r13, r13
    4416:	cc 24       	eor	r12, r12
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    4418:	09 2f       	mov	r16, r25
    441a:	11 27       	eor	r17, r17
    441c:	22 27       	eor	r18, r18
    441e:	33 27       	eor	r19, r19
    4420:	0c 29       	or	r16, r12
    4422:	1d 29       	or	r17, r13
    4424:	2e 29       	or	r18, r14
    4426:	3f 29       	or	r19, r15
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
    4428:	6b 01       	movw	r12, r22
    442a:	7c 01       	movw	r14, r24
    442c:	cc 24       	eor	r12, r12
    442e:	ee 24       	eor	r14, r14
    4430:	ff 24       	eor	r15, r15
    4432:	fe 2c       	mov	r15, r14
    4434:	ed 2c       	mov	r14, r13
    4436:	dc 2c       	mov	r13, r12
    4438:	cc 24       	eor	r12, r12
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    443a:	0c 29       	or	r16, r12
    443c:	1d 29       	or	r17, r13
    443e:	2e 29       	or	r18, r14
    4440:	3f 29       	or	r19, r15
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
    4442:	dc 01       	movw	r26, r24
    4444:	cb 01       	movw	r24, r22
    4446:	88 27       	eor	r24, r24
    4448:	99 27       	eor	r25, r25
    444a:	bb 27       	eor	r27, r27
    444c:	89 2f       	mov	r24, r25
    444e:	9a 2f       	mov	r25, r26
    4450:	ab 2f       	mov	r26, r27
    4452:	bb 27       	eor	r27, r27
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    4454:	bc 01       	movw	r22, r24
    4456:	cd 01       	movw	r24, r26
    4458:	60 2b       	or	r22, r16
    445a:	71 2b       	or	r23, r17
    445c:	82 2b       	or	r24, r18
    445e:	93 2b       	or	r25, r19
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
#endif
}
    4460:	1f 91       	pop	r17
    4462:	0f 91       	pop	r16
    4464:	ff 90       	pop	r15
    4466:	ef 90       	pop	r14
    4468:	df 90       	pop	r13
    446a:	cf 90       	pop	r12
    446c:	08 95       	ret

0000446e <csp_ntoh32>:

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
    446e:	cf 92       	push	r12
    4470:	df 92       	push	r13
    4472:	ef 92       	push	r14
    4474:	ff 92       	push	r15
    4476:	0f 93       	push	r16
    4478:	1f 93       	push	r17
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    447a:	f6 2e       	mov	r15, r22
    447c:	ee 24       	eor	r14, r14
    447e:	dd 24       	eor	r13, r13
    4480:	cc 24       	eor	r12, r12
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    4482:	09 2f       	mov	r16, r25
    4484:	11 27       	eor	r17, r17
    4486:	22 27       	eor	r18, r18
    4488:	33 27       	eor	r19, r19
    448a:	0c 29       	or	r16, r12
    448c:	1d 29       	or	r17, r13
    448e:	2e 29       	or	r18, r14
    4490:	3f 29       	or	r19, r15
			((h32 & 0x000000ff) << 24) |
			((h32 & 0x0000ff00) <<  8) |
    4492:	6b 01       	movw	r12, r22
    4494:	7c 01       	movw	r14, r24
    4496:	cc 24       	eor	r12, r12
    4498:	ee 24       	eor	r14, r14
    449a:	ff 24       	eor	r15, r15
    449c:	fe 2c       	mov	r15, r14
    449e:	ed 2c       	mov	r14, r13
    44a0:	dc 2c       	mov	r13, r12
    44a2:	cc 24       	eor	r12, r12
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
			((h32 & 0x000000ff) << 24) |
    44a4:	0c 29       	or	r16, r12
    44a6:	1d 29       	or	r17, r13
    44a8:	2e 29       	or	r18, r14
    44aa:	3f 29       	or	r19, r15
			((h32 & 0x0000ff00) <<  8) |
			((h32 & 0x00ff0000) >>  8));
    44ac:	dc 01       	movw	r26, r24
    44ae:	cb 01       	movw	r24, r22
    44b0:	88 27       	eor	r24, r24
    44b2:	99 27       	eor	r25, r25
    44b4:	bb 27       	eor	r27, r27
    44b6:	89 2f       	mov	r24, r25
    44b8:	9a 2f       	mov	r25, r26
    44ba:	ab 2f       	mov	r26, r27
    44bc:	bb 27       	eor	r27, r27
/* Convert 32-bit number from host byte order to network byte order */
inline uint32_t __attribute__ ((__const__)) csp_hton32(uint32_t h32) {
#ifdef CSP_BIG_ENDIAN
	return h32;
#else
	return (((h32 & 0xff000000) >> 24) |
    44be:	bc 01       	movw	r22, r24
    44c0:	cd 01       	movw	r24, r26
    44c2:	60 2b       	or	r22, r16
    44c4:	71 2b       	or	r23, r17
    44c6:	82 2b       	or	r24, r18
    44c8:	93 2b       	or	r25, r19
}

/* Convert 32-bit number from network byte order to host byte order */
inline uint32_t __attribute__ ((__const__)) csp_ntoh32(uint32_t n32) {
	return csp_hton32(n32);
}
    44ca:	1f 91       	pop	r17
    44cc:	0f 91       	pop	r16
    44ce:	ff 90       	pop	r15
    44d0:	ef 90       	pop	r14
    44d2:	df 90       	pop	r13
    44d4:	cf 90       	pop	r12
    44d6:	08 95       	ret

000044d8 <csp_get_hostname>:
	csp_packet_t * packet = NULL;
	csp_queue_dequeue(socket->socket, &packet, timeout);

	return packet;

}
    44d8:	80 91 31 3a 	lds	r24, 0x3A31
    44dc:	90 91 32 3a 	lds	r25, 0x3A32
    44e0:	08 95       	ret

000044e2 <csp_get_model>:
    44e2:	80 91 2f 3a 	lds	r24, 0x3A2F
    44e6:	90 91 30 3a 	lds	r25, 0x3A30
    44ea:	08 95       	ret

000044ec <csp_init>:
    44ec:	80 93 88 3c 	sts	0x3C88, r24
    44f0:	63 dd       	rcall	.-1338   	; 0x3fb8 <csp_conn_init>
    44f2:	9c 01       	movw	r18, r24
    44f4:	00 97       	sbiw	r24, 0x00	; 0
    44f6:	31 f4       	brne	.+12     	; 0x4504 <csp_init+0x18>
    44f8:	08 d2       	rcall	.+1040   	; 0x490a <csp_port_init>
    44fa:	9c 01       	movw	r18, r24
    44fc:	00 97       	sbiw	r24, 0x00	; 0
    44fe:	21 f4       	brne	.+8      	; 0x4508 <csp_init+0x1c>
    4500:	37 c3       	rjmp	.+1646   	; 0x4b70 <csp_route_table_init>
    4502:	08 95       	ret
    4504:	93 2f       	mov	r25, r19
    4506:	08 95       	ret
    4508:	93 2f       	mov	r25, r19
    450a:	08 95       	ret

0000450c <csp_socket>:
    450c:	cf 92       	push	r12
    450e:	df 92       	push	r13
    4510:	ef 92       	push	r14
    4512:	ff 92       	push	r15
    4514:	cf 93       	push	r28
    4516:	df 93       	push	r29
    4518:	6b 01       	movw	r12, r22
    451a:	7c 01       	movw	r14, r24
    451c:	dc 01       	movw	r26, r24
    451e:	cb 01       	movw	r24, r22
    4520:	81 71       	andi	r24, 0x11	; 17
    4522:	99 27       	eor	r25, r25
    4524:	aa 27       	eor	r26, r26
    4526:	bb 27       	eor	r27, r27
    4528:	89 2b       	or	r24, r25
    452a:	8a 2b       	or	r24, r26
    452c:	8b 2b       	or	r24, r27
    452e:	11 f5       	brne	.+68     	; 0x4574 <csp_socket+0x68>
    4530:	d7 01       	movw	r26, r14
    4532:	c6 01       	movw	r24, r12
    4534:	8e 7a       	andi	r24, 0xAE	; 174
    4536:	9e 7f       	andi	r25, 0xFE	; 254
    4538:	89 2b       	or	r24, r25
    453a:	8a 2b       	or	r24, r26
    453c:	8b 2b       	or	r24, r27
    453e:	e9 f4       	brne	.+58     	; 0x457a <csp_socket+0x6e>
    4540:	81 e0       	ldi	r24, 0x01	; 1
    4542:	de dd       	rcall	.-1092   	; 0x4100 <csp_conn_allocate>
    4544:	ec 01       	movw	r28, r24
    4546:	00 97       	sbiw	r24, 0x00	; 0
    4548:	d9 f0       	breq	.+54     	; 0x4580 <csp_socket+0x74>
    454a:	d0 fe       	sbrs	r13, 0
    454c:	0a c0       	rjmp	.+20     	; 0x4562 <csp_socket+0x56>
    454e:	62 e0       	ldi	r22, 0x02	; 2
    4550:	70 e0       	ldi	r23, 0x00	; 0
    4552:	8a e0       	ldi	r24, 0x0A	; 10
    4554:	90 e0       	ldi	r25, 0x00	; 0
    4556:	99 da       	rcall	.-2766   	; 0x3a8a <csp_queue_create>
    4558:	8e 87       	std	Y+14, r24	; 0x0e
    455a:	9f 87       	std	Y+15, r25	; 0x0f
    455c:	89 2b       	or	r24, r25
    455e:	19 f4       	brne	.+6      	; 0x4566 <csp_socket+0x5a>
    4560:	12 c0       	rjmp	.+36     	; 0x4586 <csp_socket+0x7a>
    4562:	1e 86       	std	Y+14, r1	; 0x0e
    4564:	1f 86       	std	Y+15, r1	; 0x0f
    4566:	cc 8a       	std	Y+20, r12	; 0x14
    4568:	dd 8a       	std	Y+21, r13	; 0x15
    456a:	ee 8a       	std	Y+22, r14	; 0x16
    456c:	ff 8a       	std	Y+23, r15	; 0x17
    456e:	8c 2f       	mov	r24, r28
    4570:	9d 2f       	mov	r25, r29
    4572:	0b c0       	rjmp	.+22     	; 0x458a <csp_socket+0x7e>
    4574:	80 e0       	ldi	r24, 0x00	; 0
    4576:	90 e0       	ldi	r25, 0x00	; 0
    4578:	08 c0       	rjmp	.+16     	; 0x458a <csp_socket+0x7e>
    457a:	80 e0       	ldi	r24, 0x00	; 0
    457c:	90 e0       	ldi	r25, 0x00	; 0
    457e:	05 c0       	rjmp	.+10     	; 0x458a <csp_socket+0x7e>
    4580:	80 e0       	ldi	r24, 0x00	; 0
    4582:	90 e0       	ldi	r25, 0x00	; 0
    4584:	02 c0       	rjmp	.+4      	; 0x458a <csp_socket+0x7e>
    4586:	80 e0       	ldi	r24, 0x00	; 0
    4588:	90 e0       	ldi	r25, 0x00	; 0
    458a:	df 91       	pop	r29
    458c:	cf 91       	pop	r28
    458e:	ff 90       	pop	r15
    4590:	ef 90       	pop	r14
    4592:	df 90       	pop	r13
    4594:	cf 90       	pop	r12
    4596:	08 95       	ret

00004598 <csp_accept>:
    4598:	cf 93       	push	r28
    459a:	df 93       	push	r29
    459c:	1f 92       	push	r1
    459e:	1f 92       	push	r1
    45a0:	cd b7       	in	r28, 0x3d	; 61
    45a2:	de b7       	in	r29, 0x3e	; 62
    45a4:	00 97       	sbiw	r24, 0x00	; 0
    45a6:	81 f0       	breq	.+32     	; 0x45c8 <csp_accept+0x30>
    45a8:	fc 01       	movw	r30, r24
    45aa:	86 85       	ldd	r24, Z+14	; 0x0e
    45ac:	97 85       	ldd	r25, Z+15	; 0x0f
    45ae:	00 97       	sbiw	r24, 0x00	; 0
    45b0:	71 f0       	breq	.+28     	; 0x45ce <csp_accept+0x36>
    45b2:	9a 01       	movw	r18, r20
    45b4:	ab 01       	movw	r20, r22
    45b6:	be 01       	movw	r22, r28
    45b8:	6f 5f       	subi	r22, 0xFF	; 255
    45ba:	7f 4f       	sbci	r23, 0xFF	; 255
    45bc:	82 da       	rcall	.-2812   	; 0x3ac2 <csp_queue_dequeue>
    45be:	01 97       	sbiw	r24, 0x01	; 1
    45c0:	49 f4       	brne	.+18     	; 0x45d4 <csp_accept+0x3c>
    45c2:	89 81       	ldd	r24, Y+1	; 0x01
    45c4:	9a 81       	ldd	r25, Y+2	; 0x02
    45c6:	08 c0       	rjmp	.+16     	; 0x45d8 <csp_accept+0x40>
    45c8:	80 e0       	ldi	r24, 0x00	; 0
    45ca:	90 e0       	ldi	r25, 0x00	; 0
    45cc:	05 c0       	rjmp	.+10     	; 0x45d8 <csp_accept+0x40>
    45ce:	80 e0       	ldi	r24, 0x00	; 0
    45d0:	90 e0       	ldi	r25, 0x00	; 0
    45d2:	02 c0       	rjmp	.+4      	; 0x45d8 <csp_accept+0x40>
    45d4:	80 e0       	ldi	r24, 0x00	; 0
    45d6:	90 e0       	ldi	r25, 0x00	; 0
    45d8:	0f 90       	pop	r0
    45da:	0f 90       	pop	r0
    45dc:	df 91       	pop	r29
    45de:	cf 91       	pop	r28
    45e0:	08 95       	ret

000045e2 <csp_read>:
    45e2:	cf 93       	push	r28
    45e4:	df 93       	push	r29
    45e6:	1f 92       	push	r1
    45e8:	1f 92       	push	r1
    45ea:	cd b7       	in	r28, 0x3d	; 61
    45ec:	de b7       	in	r29, 0x3e	; 62
    45ee:	19 82       	std	Y+1, r1	; 0x01
    45f0:	1a 82       	std	Y+2, r1	; 0x02
    45f2:	00 97       	sbiw	r24, 0x00	; 0
    45f4:	89 f0       	breq	.+34     	; 0x4618 <csp_read+0x36>
    45f6:	fc 01       	movw	r30, r24
    45f8:	21 81       	ldd	r18, Z+1	; 0x01
    45fa:	21 30       	cpi	r18, 0x01	; 1
    45fc:	81 f4       	brne	.+32     	; 0x461e <csp_read+0x3c>
    45fe:	9a 01       	movw	r18, r20
    4600:	ab 01       	movw	r20, r22
    4602:	be 01       	movw	r22, r28
    4604:	6f 5f       	subi	r22, 0xFF	; 255
    4606:	7f 4f       	sbci	r23, 0xFF	; 255
    4608:	84 85       	ldd	r24, Z+12	; 0x0c
    460a:	95 85       	ldd	r25, Z+13	; 0x0d
    460c:	5a da       	rcall	.-2892   	; 0x3ac2 <csp_queue_dequeue>
    460e:	01 97       	sbiw	r24, 0x01	; 1
    4610:	49 f4       	brne	.+18     	; 0x4624 <csp_read+0x42>
    4612:	89 81       	ldd	r24, Y+1	; 0x01
    4614:	9a 81       	ldd	r25, Y+2	; 0x02
    4616:	08 c0       	rjmp	.+16     	; 0x4628 <csp_read+0x46>
    4618:	80 e0       	ldi	r24, 0x00	; 0
    461a:	90 e0       	ldi	r25, 0x00	; 0
    461c:	05 c0       	rjmp	.+10     	; 0x4628 <csp_read+0x46>
    461e:	80 e0       	ldi	r24, 0x00	; 0
    4620:	90 e0       	ldi	r25, 0x00	; 0
    4622:	02 c0       	rjmp	.+4      	; 0x4628 <csp_read+0x46>
    4624:	80 e0       	ldi	r24, 0x00	; 0
    4626:	90 e0       	ldi	r25, 0x00	; 0
    4628:	0f 90       	pop	r0
    462a:	0f 90       	pop	r0
    462c:	df 91       	pop	r29
    462e:	cf 91       	pop	r28
    4630:	08 95       	ret

00004632 <csp_send_direct>:
    4632:	8f 92       	push	r8
    4634:	9f 92       	push	r9
    4636:	af 92       	push	r10
    4638:	bf 92       	push	r11
    463a:	cf 92       	push	r12
    463c:	df 92       	push	r13
    463e:	ef 92       	push	r14
    4640:	ff 92       	push	r15
    4642:	0f 93       	push	r16
    4644:	1f 93       	push	r17
    4646:	cf 93       	push	r28
    4648:	df 93       	push	r29
    464a:	96 2e       	mov	r9, r22
    464c:	87 2e       	mov	r8, r23
    464e:	d8 2f       	mov	r29, r24
    4650:	c9 2f       	mov	r28, r25
    4652:	5a 01       	movw	r10, r20
    4654:	68 01       	movw	r12, r16
    4656:	79 01       	movw	r14, r18
    4658:	41 15       	cp	r20, r1
    465a:	51 05       	cpc	r21, r1
    465c:	09 f4       	brne	.+2      	; 0x4660 <csp_send_direct+0x2e>
    465e:	7b c0       	rjmp	.+246    	; 0x4756 <csp_send_direct+0x124>
    4660:	89 2f       	mov	r24, r25
    4662:	81 70       	andi	r24, 0x01	; 1
    4664:	82 95       	swap	r24
    4666:	80 7f       	andi	r24, 0xF0	; 240
    4668:	9d 2f       	mov	r25, r29
    466a:	92 95       	swap	r25
    466c:	9f 70       	andi	r25, 0x0F	; 15
    466e:	89 2b       	or	r24, r25
    4670:	a9 d2       	rcall	.+1362   	; 0x4bc4 <csp_route_if>
    4672:	8c 01       	movw	r16, r24
    4674:	00 97       	sbiw	r24, 0x00	; 0
    4676:	09 f4       	brne	.+2      	; 0x467a <csp_send_direct+0x48>
    4678:	71 c0       	rjmp	.+226    	; 0x475c <csp_send_direct+0x12a>
    467a:	dc 01       	movw	r26, r24
    467c:	ed 91       	ld	r30, X+
    467e:	fc 91       	ld	r31, X
    4680:	30 97       	sbiw	r30, 0x00	; 0
    4682:	09 f4       	brne	.+2      	; 0x4686 <csp_send_direct+0x54>
    4684:	6e c0       	rjmp	.+220    	; 0x4762 <csp_send_direct+0x130>
    4686:	24 81       	ldd	r18, Z+4	; 0x04
    4688:	35 81       	ldd	r19, Z+5	; 0x05
    468a:	23 2b       	or	r18, r19
    468c:	09 f4       	brne	.+2      	; 0x4690 <csp_send_direct+0x5e>
    468e:	6c c0       	rjmp	.+216    	; 0x4768 <csp_send_direct+0x136>
    4690:	2c 2f       	mov	r18, r28
    4692:	26 95       	lsr	r18
    4694:	2f 71       	andi	r18, 0x1F	; 31
    4696:	30 e0       	ldi	r19, 0x00	; 0
    4698:	80 91 88 3c 	lds	r24, 0x3C88
    469c:	90 e0       	ldi	r25, 0x00	; 0
    469e:	28 17       	cp	r18, r24
    46a0:	39 07       	cpc	r19, r25
    46a2:	59 f4       	brne	.+22     	; 0x46ba <csp_send_direct+0x88>
    46a4:	93 fc       	sbrc	r9, 3
    46a6:	46 c0       	rjmp	.+140    	; 0x4734 <csp_send_direct+0x102>
    46a8:	90 fe       	sbrs	r9, 0
    46aa:	05 c0       	rjmp	.+10     	; 0x46b6 <csp_send_direct+0x84>
    46ac:	c5 01       	movw	r24, r10
    46ae:	40 de       	rcall	.-896    	; 0x4330 <csp_crc32_append>
    46b0:	89 2b       	or	r24, r25
    46b2:	09 f0       	breq	.+2      	; 0x46b6 <csp_send_direct+0x84>
    46b4:	3f c0       	rjmp	.+126    	; 0x4734 <csp_send_direct+0x102>
    46b6:	92 fc       	sbrc	r9, 2
    46b8:	3d c0       	rjmp	.+122    	; 0x4734 <csp_send_direct+0x102>
    46ba:	f5 01       	movw	r30, r10
    46bc:	92 86       	std	Z+10, r9	; 0x0a
    46be:	83 86       	std	Z+11, r8	; 0x0b
    46c0:	d4 87       	std	Z+12, r29	; 0x0c
    46c2:	c5 87       	std	Z+13, r28	; 0x0d
    46c4:	c0 85       	ldd	r28, Z+8	; 0x08
    46c6:	d1 85       	ldd	r29, Z+9	; 0x09
    46c8:	f8 01       	movw	r30, r16
    46ca:	a0 81       	ld	r26, Z
    46cc:	b1 81       	ldd	r27, Z+1	; 0x01
    46ce:	17 96       	adiw	r26, 0x07	; 7
    46d0:	8d 91       	ld	r24, X+
    46d2:	9c 91       	ld	r25, X
    46d4:	18 97       	sbiw	r26, 0x08	; 8
    46d6:	00 97       	sbiw	r24, 0x00	; 0
    46d8:	19 f0       	breq	.+6      	; 0x46e0 <csp_send_direct+0xae>
    46da:	8c 17       	cp	r24, r28
    46dc:	9d 07       	cpc	r25, r29
    46de:	50 f1       	brcs	.+84     	; 0x4734 <csp_send_direct+0x102>
    46e0:	14 96       	adiw	r26, 0x04	; 4
    46e2:	ed 91       	ld	r30, X+
    46e4:	fc 91       	ld	r31, X
    46e6:	15 97       	sbiw	r26, 0x05	; 5
    46e8:	a7 01       	movw	r20, r14
    46ea:	96 01       	movw	r18, r12
    46ec:	b5 01       	movw	r22, r10
    46ee:	cd 01       	movw	r24, r26
    46f0:	19 95       	eicall
    46f2:	00 97       	sbiw	r24, 0x00	; 0
    46f4:	f9 f4       	brne	.+62     	; 0x4734 <csp_send_direct+0x102>
    46f6:	d8 01       	movw	r26, r16
    46f8:	ed 91       	ld	r30, X+
    46fa:	fc 91       	ld	r31, X
    46fc:	11 97       	sbiw	r26, 0x01	; 1
    46fe:	42 85       	ldd	r20, Z+10	; 0x0a
    4700:	53 85       	ldd	r21, Z+11	; 0x0b
    4702:	64 85       	ldd	r22, Z+12	; 0x0c
    4704:	75 85       	ldd	r23, Z+13	; 0x0d
    4706:	4f 5f       	subi	r20, 0xFF	; 255
    4708:	5f 4f       	sbci	r21, 0xFF	; 255
    470a:	6f 4f       	sbci	r22, 0xFF	; 255
    470c:	7f 4f       	sbci	r23, 0xFF	; 255
    470e:	42 87       	std	Z+10, r20	; 0x0a
    4710:	53 87       	std	Z+11, r21	; 0x0b
    4712:	64 87       	std	Z+12, r22	; 0x0c
    4714:	75 87       	std	Z+13, r23	; 0x0d
    4716:	ed 91       	ld	r30, X+
    4718:	fc 91       	ld	r31, X
    471a:	46 a1       	ldd	r20, Z+38	; 0x26
    471c:	57 a1       	ldd	r21, Z+39	; 0x27
    471e:	60 a5       	ldd	r22, Z+40	; 0x28
    4720:	71 a5       	ldd	r23, Z+41	; 0x29
    4722:	4c 0f       	add	r20, r28
    4724:	5d 1f       	adc	r21, r29
    4726:	61 1d       	adc	r22, r1
    4728:	71 1d       	adc	r23, r1
    472a:	46 a3       	std	Z+38, r20	; 0x26
    472c:	57 a3       	std	Z+39, r21	; 0x27
    472e:	60 a7       	std	Z+40, r22	; 0x28
    4730:	71 a7       	std	Z+41, r23	; 0x29
    4732:	1c c0       	rjmp	.+56     	; 0x476c <csp_send_direct+0x13a>
    4734:	d8 01       	movw	r26, r16
    4736:	ed 91       	ld	r30, X+
    4738:	fc 91       	ld	r31, X
    473a:	82 89       	ldd	r24, Z+18	; 0x12
    473c:	93 89       	ldd	r25, Z+19	; 0x13
    473e:	a4 89       	ldd	r26, Z+20	; 0x14
    4740:	b5 89       	ldd	r27, Z+21	; 0x15
    4742:	01 96       	adiw	r24, 0x01	; 1
    4744:	a1 1d       	adc	r26, r1
    4746:	b1 1d       	adc	r27, r1
    4748:	82 8b       	std	Z+18, r24	; 0x12
    474a:	93 8b       	std	Z+19, r25	; 0x13
    474c:	a4 8b       	std	Z+20, r26	; 0x14
    474e:	b5 8b       	std	Z+21, r27	; 0x15
    4750:	86 ef       	ldi	r24, 0xF6	; 246
    4752:	9f ef       	ldi	r25, 0xFF	; 255
    4754:	0b c0       	rjmp	.+22     	; 0x476c <csp_send_direct+0x13a>
    4756:	86 ef       	ldi	r24, 0xF6	; 246
    4758:	9f ef       	ldi	r25, 0xFF	; 255
    475a:	08 c0       	rjmp	.+16     	; 0x476c <csp_send_direct+0x13a>
    475c:	86 ef       	ldi	r24, 0xF6	; 246
    475e:	9f ef       	ldi	r25, 0xFF	; 255
    4760:	05 c0       	rjmp	.+10     	; 0x476c <csp_send_direct+0x13a>
    4762:	86 ef       	ldi	r24, 0xF6	; 246
    4764:	9f ef       	ldi	r25, 0xFF	; 255
    4766:	02 c0       	rjmp	.+4      	; 0x476c <csp_send_direct+0x13a>
    4768:	86 ef       	ldi	r24, 0xF6	; 246
    476a:	9f ef       	ldi	r25, 0xFF	; 255
    476c:	df 91       	pop	r29
    476e:	cf 91       	pop	r28
    4770:	1f 91       	pop	r17
    4772:	0f 91       	pop	r16
    4774:	ff 90       	pop	r15
    4776:	ef 90       	pop	r14
    4778:	df 90       	pop	r13
    477a:	cf 90       	pop	r12
    477c:	bf 90       	pop	r11
    477e:	af 90       	pop	r10
    4780:	9f 90       	pop	r9
    4782:	8f 90       	pop	r8
    4784:	08 95       	ret

00004786 <csp_send>:
    4786:	0f 93       	push	r16
    4788:	1f 93       	push	r17
    478a:	fb 01       	movw	r30, r22
    478c:	00 97       	sbiw	r24, 0x00	; 0
    478e:	d1 f0       	breq	.+52     	; 0x47c4 <csp_send+0x3e>
    4790:	30 97       	sbiw	r30, 0x00	; 0
    4792:	d9 f0       	breq	.+54     	; 0x47ca <csp_send+0x44>
    4794:	dc 01       	movw	r26, r24
    4796:	11 96       	adiw	r26, 0x01	; 1
    4798:	6c 91       	ld	r22, X
    479a:	11 97       	sbiw	r26, 0x01	; 1
    479c:	61 30       	cpi	r22, 0x01	; 1
    479e:	c1 f4       	brne	.+48     	; 0x47d0 <csp_send+0x4a>
    47a0:	18 96       	adiw	r26, 0x08	; 8
    47a2:	6d 91       	ld	r22, X+
    47a4:	7d 91       	ld	r23, X+
    47a6:	8d 91       	ld	r24, X+
    47a8:	9c 91       	ld	r25, X
    47aa:	1b 97       	sbiw	r26, 0x0b	; 11
    47ac:	89 01       	movw	r16, r18
    47ae:	9a 01       	movw	r18, r20
    47b0:	af 01       	movw	r20, r30
    47b2:	3f df       	rcall	.-386    	; 0x4632 <csp_send_direct>
    47b4:	31 e0       	ldi	r19, 0x01	; 1
    47b6:	20 e0       	ldi	r18, 0x00	; 0
    47b8:	89 2b       	or	r24, r25
    47ba:	09 f0       	breq	.+2      	; 0x47be <csp_send+0x38>
    47bc:	30 e0       	ldi	r19, 0x00	; 0
    47be:	83 2f       	mov	r24, r19
    47c0:	92 2f       	mov	r25, r18
    47c2:	08 c0       	rjmp	.+16     	; 0x47d4 <csp_send+0x4e>
    47c4:	80 e0       	ldi	r24, 0x00	; 0
    47c6:	90 e0       	ldi	r25, 0x00	; 0
    47c8:	05 c0       	rjmp	.+10     	; 0x47d4 <csp_send+0x4e>
    47ca:	80 e0       	ldi	r24, 0x00	; 0
    47cc:	90 e0       	ldi	r25, 0x00	; 0
    47ce:	02 c0       	rjmp	.+4      	; 0x47d4 <csp_send+0x4e>
    47d0:	80 e0       	ldi	r24, 0x00	; 0
    47d2:	90 e0       	ldi	r25, 0x00	; 0
    47d4:	1f 91       	pop	r17
    47d6:	0f 91       	pop	r16
    47d8:	08 95       	ret

000047da <csp_sendto>:

int csp_sendto(uint8_t prio, uint8_t dest, uint8_t dport, uint8_t src_port, uint32_t opts, csp_packet_t * packet, uint32_t timeout) {
    47da:	4f 92       	push	r4
    47dc:	5f 92       	push	r5
    47de:	6f 92       	push	r6
    47e0:	7f 92       	push	r7
    47e2:	8f 92       	push	r8
    47e4:	9f 92       	push	r9
    47e6:	af 92       	push	r10
    47e8:	bf 92       	push	r11
    47ea:	cf 92       	push	r12
    47ec:	df 92       	push	r13
    47ee:	ef 92       	push	r14
    47f0:	ff 92       	push	r15
    47f2:	0f 93       	push	r16
    47f4:	1f 93       	push	r17
    47f6:	cf 93       	push	r28
    47f8:	df 93       	push	r29
    47fa:	cd b7       	in	r28, 0x3d	; 61
    47fc:	de b7       	in	r29, 0x3e	; 62
    47fe:	f6 01       	movw	r30, r12

	packet->id.flags = 0;
    4800:	12 86       	std	Z+10, r1	; 0x0a

	if (opts & CSP_O_RDP) {
    4802:	e0 fc       	sbrc	r14, 0
    4804:	45 c0       	rjmp	.+138    	; 0x4890 <csp_sendto+0xb6>
    4806:	27 01       	movw	r4, r14
    4808:	38 01       	movw	r6, r16
    480a:	94 e1       	ldi	r25, 0x14	; 20
    480c:	49 22       	and	r4, r25
    480e:	55 24       	eor	r5, r5
    4810:	66 24       	eor	r6, r6
    4812:	77 24       	eor	r7, r7
		csp_log_error("Attempt to create HMAC authenticated packet, but CSP was compiled without HMAC support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	if (opts & CSP_O_XTEA) {
    4814:	45 28       	or	r4, r5
    4816:	46 28       	or	r4, r6
    4818:	47 28       	or	r4, r7
    481a:	e9 f5       	brne	.+122    	; 0x4896 <csp_sendto+0xbc>
		csp_log_error("Attempt to create XTEA encrypted packet, but CSP was compiled without XTEA support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	if (opts & CSP_O_CRC32) {
    481c:	e6 fe       	sbrs	r14, 6
    481e:	02 c0       	rjmp	.+4      	; 0x4824 <csp_sendto+0x4a>
#ifdef CSP_USE_CRC32
		packet->id.flags |= CSP_FCRC32;
    4820:	91 e0       	ldi	r25, 0x01	; 1
    4822:	92 87       	std	Z+10, r25	; 0x0a
		csp_log_error("Attempt to create CRC32 validated packet, but CSP was compiled without CRC32 support\r\n");
		return CSP_ERR_NOTSUP;
#endif
	}

	packet->id.dst = dest;
    4824:	64 fb       	bst	r22, 4
    4826:	99 27       	eor	r25, r25
    4828:	90 f9       	bld	r25, 0
    482a:	35 85       	ldd	r19, Z+13	; 0x0d
    482c:	3e 7f       	andi	r19, 0xFE	; 254
    482e:	39 2b       	or	r19, r25
    4830:	35 87       	std	Z+13, r19	; 0x0d
	packet->id.dport = dport;
    4832:	54 2f       	mov	r21, r20
    4834:	52 95       	swap	r21
    4836:	55 0f       	add	r21, r21
    4838:	55 0f       	add	r21, r21
    483a:	50 7c       	andi	r21, 0xC0	; 192
    483c:	93 85       	ldd	r25, Z+11	; 0x0b
    483e:	9f 73       	andi	r25, 0x3F	; 63
    4840:	95 2b       	or	r25, r21
    4842:	93 87       	std	Z+11, r25	; 0x0b
    4844:	46 95       	lsr	r20
    4846:	46 95       	lsr	r20
    4848:	4f 70       	andi	r20, 0x0F	; 15
    484a:	62 95       	swap	r22
    484c:	60 7f       	andi	r22, 0xF0	; 240
    484e:	64 2b       	or	r22, r20
    4850:	64 87       	std	Z+12, r22	; 0x0c
	packet->id.src = my_address;
    4852:	40 91 88 3c 	lds	r20, 0x3C88
    4856:	4f 71       	andi	r20, 0x1F	; 31
    4858:	44 0f       	add	r20, r20
    485a:	31 70       	andi	r19, 0x01	; 1
	packet->id.sport = src_port;
    485c:	2f 73       	andi	r18, 0x3F	; 63
    485e:	90 7c       	andi	r25, 0xC0	; 192
    4860:	29 2b       	or	r18, r25
    4862:	23 87       	std	Z+11, r18	; 0x0b
	packet->id.pri = prio;
    4864:	98 2f       	mov	r25, r24
    4866:	92 95       	swap	r25
    4868:	99 0f       	add	r25, r25
    486a:	99 0f       	add	r25, r25
    486c:	90 7c       	andi	r25, 0xC0	; 192
    486e:	83 2f       	mov	r24, r19
    4870:	84 2b       	or	r24, r20
    4872:	89 2b       	or	r24, r25
    4874:	85 87       	std	Z+13, r24	; 0x0d

	if (csp_send_direct(packet->id, packet, timeout) != CSP_ERR_NONE)
    4876:	62 85       	ldd	r22, Z+10	; 0x0a
    4878:	73 85       	ldd	r23, Z+11	; 0x0b
    487a:	84 85       	ldd	r24, Z+12	; 0x0c
    487c:	95 85       	ldd	r25, Z+13	; 0x0d
    487e:	95 01       	movw	r18, r10
    4880:	84 01       	movw	r16, r8
    4882:	af 01       	movw	r20, r30
    4884:	d6 de       	rcall	.-596    	; 0x4632 <csp_send_direct>
    4886:	00 97       	sbiw	r24, 0x00	; 0
    4888:	41 f0       	breq	.+16     	; 0x489a <csp_sendto+0xc0>
		return CSP_ERR_NOTSUP;
    488a:	8b ef       	ldi	r24, 0xFB	; 251
    488c:	9f ef       	ldi	r25, 0xFF	; 255
    488e:	05 c0       	rjmp	.+10     	; 0x489a <csp_sendto+0xc0>

	packet->id.flags = 0;

	if (opts & CSP_O_RDP) {
		csp_log_error("Attempt to create RDP packet on connection-less socket\r\n");
		return CSP_ERR_INVAL;
    4890:	8e ef       	ldi	r24, 0xFE	; 254
    4892:	9f ef       	ldi	r25, 0xFF	; 255
    4894:	02 c0       	rjmp	.+4      	; 0x489a <csp_sendto+0xc0>
	if (opts & CSP_O_XTEA) {
#ifdef CSP_USE_XTEA
		packet->id.flags |= CSP_FXTEA;
#else
		csp_log_error("Attempt to create XTEA encrypted packet, but CSP was compiled without XTEA support\r\n");
		return CSP_ERR_NOTSUP;
    4896:	8b ef       	ldi	r24, 0xFB	; 251
    4898:	9f ef       	ldi	r25, 0xFF	; 255
	if (csp_send_direct(packet->id, packet, timeout) != CSP_ERR_NONE)
		return CSP_ERR_NOTSUP;
	
	return CSP_ERR_NONE;

}
    489a:	df 91       	pop	r29
    489c:	cf 91       	pop	r28
    489e:	1f 91       	pop	r17
    48a0:	0f 91       	pop	r16
    48a2:	ff 90       	pop	r15
    48a4:	ef 90       	pop	r14
    48a6:	df 90       	pop	r13
    48a8:	cf 90       	pop	r12
    48aa:	bf 90       	pop	r11
    48ac:	af 90       	pop	r10
    48ae:	9f 90       	pop	r9
    48b0:	8f 90       	pop	r8
    48b2:	7f 90       	pop	r7
    48b4:	6f 90       	pop	r6
    48b6:	5f 90       	pop	r5
    48b8:	4f 90       	pop	r4
    48ba:	08 95       	ret

000048bc <csp_port_get_socket>:

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port > CSP_ANY)
    48bc:	81 32       	cpi	r24, 0x21	; 33
    48be:	91 05       	cpc	r25, r1
    48c0:	f0 f4       	brcc	.+60     	; 0x48fe <csp_port_get_socket+0x42>
		return NULL;

	/* Match dport to socket or local "catch all" port number */
	if (ports[port].state == PORT_OPEN)
    48c2:	fc 01       	movw	r30, r24
    48c4:	ee 0f       	add	r30, r30
    48c6:	ff 1f       	adc	r31, r31
    48c8:	e8 0f       	add	r30, r24
    48ca:	f9 1f       	adc	r31, r25
    48cc:	ed 5c       	subi	r30, 0xCD	; 205
    48ce:	f5 4c       	sbci	r31, 0xC5	; 197
    48d0:	20 81       	ld	r18, Z
    48d2:	21 30       	cpi	r18, 0x01	; 1
    48d4:	59 f4       	brne	.+22     	; 0x48ec <csp_port_get_socket+0x30>
		ret = ports[port].socket;
    48d6:	fc 01       	movw	r30, r24
    48d8:	ee 0f       	add	r30, r30
    48da:	ff 1f       	adc	r31, r31
    48dc:	8e 0f       	add	r24, r30
    48de:	9f 1f       	adc	r25, r31
    48e0:	fc 01       	movw	r30, r24
    48e2:	ed 5c       	subi	r30, 0xCD	; 205
    48e4:	f5 4c       	sbci	r31, 0xC5	; 197
    48e6:	81 81       	ldd	r24, Z+1	; 0x01
    48e8:	92 81       	ldd	r25, Z+2	; 0x02
    48ea:	08 95       	ret
	else if (ports[CSP_ANY].state == PORT_OPEN)
    48ec:	80 91 93 3a 	lds	r24, 0x3A93
    48f0:	81 30       	cpi	r24, 0x01	; 1
    48f2:	41 f4       	brne	.+16     	; 0x4904 <csp_port_get_socket+0x48>
		ret = ports[CSP_ANY].socket;
    48f4:	80 91 94 3a 	lds	r24, 0x3A94
    48f8:	90 91 95 3a 	lds	r25, 0x3A95
    48fc:	08 95       	ret
csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;

	if (port > CSP_ANY)
		return NULL;
    48fe:	80 e0       	ldi	r24, 0x00	; 0
    4900:	90 e0       	ldi	r25, 0x00	; 0
    4902:	08 95       	ret
/* Allocation of ports */
static csp_port_t ports[CSP_MAX_BIND_PORT + 2];

csp_socket_t * csp_port_get_socket(unsigned int port) {

	csp_socket_t * ret = NULL;
    4904:	80 e0       	ldi	r24, 0x00	; 0
    4906:	90 e0       	ldi	r25, 0x00	; 0
	else if (ports[CSP_ANY].state == PORT_OPEN)
		ret = ports[CSP_ANY].socket;

	return ret;

}
    4908:	08 95       	ret

0000490a <csp_port_init>:

int csp_port_init(void) {

	memset(ports, PORT_CLOSED, sizeof(csp_port_t) * (CSP_MAX_BIND_PORT + 2));
    490a:	83 e6       	ldi	r24, 0x63	; 99
    490c:	e3 e3       	ldi	r30, 0x33	; 51
    490e:	fa e3       	ldi	r31, 0x3A	; 58
    4910:	df 01       	movw	r26, r30
    4912:	1d 92       	st	X+, r1
    4914:	8a 95       	dec	r24
    4916:	e9 f7       	brne	.-6      	; 0x4912 <csp_port_init+0x8>

	return CSP_ERR_NONE;

}
    4918:	80 e0       	ldi	r24, 0x00	; 0
    491a:	90 e0       	ldi	r25, 0x00	; 0
    491c:	08 95       	ret

0000491e <csp_listen>:

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
    491e:	cf 93       	push	r28
    4920:	df 93       	push	r29
    4922:	ec 01       	movw	r28, r24
    4924:	cb 01       	movw	r24, r22
	
	if (socket == NULL)
    4926:	20 97       	sbiw	r28, 0x00	; 0
    4928:	81 f0       	breq	.+32     	; 0x494a <csp_listen+0x2c>
		return CSP_ERR_INVAL;

	socket->socket = csp_queue_create(conn_queue_length, sizeof(csp_conn_t *));
    492a:	62 e0       	ldi	r22, 0x02	; 2
    492c:	70 e0       	ldi	r23, 0x00	; 0
    492e:	ad d8       	rcall	.-3750   	; 0x3a8a <csp_queue_create>
    4930:	8e 87       	std	Y+14, r24	; 0x0e
    4932:	9f 87       	std	Y+15, r25	; 0x0f
	if (socket->socket == NULL)
    4934:	21 e0       	ldi	r18, 0x01	; 1
    4936:	30 e0       	ldi	r19, 0x00	; 0
    4938:	89 2b       	or	r24, r25
    493a:	11 f0       	breq	.+4      	; 0x4940 <csp_listen+0x22>
    493c:	20 e0       	ldi	r18, 0x00	; 0
    493e:	30 e0       	ldi	r19, 0x00	; 0
    4940:	88 27       	eor	r24, r24
    4942:	99 27       	eor	r25, r25
    4944:	82 1b       	sub	r24, r18
    4946:	93 0b       	sbc	r25, r19
    4948:	02 c0       	rjmp	.+4      	; 0x494e <csp_listen+0x30>
}

int csp_listen(csp_socket_t * socket, size_t conn_queue_length) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    494a:	8e ef       	ldi	r24, 0xFE	; 254
    494c:	9f ef       	ldi	r25, 0xFF	; 255
	if (socket->socket == NULL)
		return CSP_ERR_NOMEM;

	return CSP_ERR_NONE;

}
    494e:	df 91       	pop	r29
    4950:	cf 91       	pop	r28
    4952:	08 95       	ret

00004954 <csp_bind>:

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
    4954:	00 97       	sbiw	r24, 0x00	; 0
    4956:	e1 f0       	breq	.+56     	; 0x4990 <csp_bind+0x3c>
		return CSP_ERR_INVAL;

	if (port > CSP_ANY) {
    4958:	61 32       	cpi	r22, 0x21	; 33
    495a:	e8 f4       	brcc	.+58     	; 0x4996 <csp_bind+0x42>
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports\r\n", CSP_ANY);
		return CSP_ERR_INVAL;
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
    495c:	70 e0       	ldi	r23, 0x00	; 0
    495e:	fb 01       	movw	r30, r22
    4960:	ee 0f       	add	r30, r30
    4962:	ff 1f       	adc	r31, r31
    4964:	e6 0f       	add	r30, r22
    4966:	f7 1f       	adc	r31, r23
    4968:	ed 5c       	subi	r30, 0xCD	; 205
    496a:	f5 4c       	sbci	r31, 0xC5	; 197
    496c:	20 81       	ld	r18, Z
    496e:	21 11       	cpse	r18, r1
    4970:	15 c0       	rjmp	.+42     	; 0x499c <csp_bind+0x48>
	}

	csp_log_info("Binding socket %p to port %u\r\n", socket, port);

	/* Save listener */
	ports[port].socket = socket;
    4972:	fb 01       	movw	r30, r22
    4974:	ee 0f       	add	r30, r30
    4976:	ff 1f       	adc	r31, r31
    4978:	6e 0f       	add	r22, r30
    497a:	7f 1f       	adc	r23, r31
    497c:	fb 01       	movw	r30, r22
    497e:	ed 5c       	subi	r30, 0xCD	; 205
    4980:	f5 4c       	sbci	r31, 0xC5	; 197
    4982:	81 83       	std	Z+1, r24	; 0x01
    4984:	92 83       	std	Z+2, r25	; 0x02
	ports[port].state = PORT_OPEN;
    4986:	81 e0       	ldi	r24, 0x01	; 1
    4988:	80 83       	st	Z, r24

	return CSP_ERR_NONE;
    498a:	80 e0       	ldi	r24, 0x00	; 0
    498c:	90 e0       	ldi	r25, 0x00	; 0
    498e:	08 95       	ret
}

int csp_bind(csp_socket_t * socket, uint8_t port) {
	
	if (socket == NULL)
		return CSP_ERR_INVAL;
    4990:	8e ef       	ldi	r24, 0xFE	; 254
    4992:	9f ef       	ldi	r25, 0xFF	; 255
    4994:	08 95       	ret

	if (port > CSP_ANY) {
		csp_log_error("Only ports from 0-%u (and CSP_ANY for default) are available for incoming ports\r\n", CSP_ANY);
		return CSP_ERR_INVAL;
    4996:	8e ef       	ldi	r24, 0xFE	; 254
    4998:	9f ef       	ldi	r25, 0xFF	; 255
    499a:	08 95       	ret
	}

	/* Check if port number is valid */
	if (ports[port].state != PORT_CLOSED) {
		csp_log_error("Port %d is already in use\r\n", port);
		return CSP_ERR_USED;
    499c:	8c ef       	ldi	r24, 0xFC	; 252
    499e:	9f ef       	ldi	r25, 0xFF	; 255
	ports[port].socket = socket;
	ports[port].state = PORT_OPEN;

	return CSP_ERR_NONE;

}
    49a0:	08 95       	ret

000049a2 <csp_route_security_check>:
	return prio;
#else
	return 0;
#endif

}
    49a2:	0f 93       	push	r16
    49a4:	1f 93       	push	r17
    49a6:	cf 93       	push	r28
    49a8:	df 93       	push	r29
    49aa:	ea 01       	movw	r28, r20
    49ac:	89 01       	movw	r16, r18
    49ae:	f9 01       	movw	r30, r18
    49b0:	82 85       	ldd	r24, Z+10	; 0x0a
    49b2:	82 ff       	sbrs	r24, 2
    49b4:	0e c0       	rjmp	.+28     	; 0x49d2 <csp_route_security_check+0x30>
    49b6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    49b8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    49ba:	a8 a1       	ldd	r26, Y+32	; 0x20
    49bc:	b9 a1       	ldd	r27, Y+33	; 0x21
    49be:	01 96       	adiw	r24, 0x01	; 1
    49c0:	a1 1d       	adc	r26, r1
    49c2:	b1 1d       	adc	r27, r1
    49c4:	8e 8f       	std	Y+30, r24	; 0x1e
    49c6:	9f 8f       	std	Y+31, r25	; 0x1f
    49c8:	a8 a3       	std	Y+32, r26	; 0x20
    49ca:	b9 a3       	std	Y+33, r27	; 0x21
    49cc:	8b ef       	ldi	r24, 0xFB	; 251
    49ce:	9f ef       	ldi	r25, 0xFF	; 255
    49d0:	28 c0       	rjmp	.+80     	; 0x4a22 <csp_route_security_check+0x80>
    49d2:	80 ff       	sbrs	r24, 0
    49d4:	12 c0       	rjmp	.+36     	; 0x49fa <csp_route_security_check+0x58>
    49d6:	c9 01       	movw	r24, r18
    49d8:	cc dc       	rcall	.-1640   	; 0x4372 <csp_crc32_verify>
    49da:	89 2b       	or	r24, r25
    49dc:	71 f0       	breq	.+28     	; 0x49fa <csp_route_security_check+0x58>
    49de:	8e 89       	ldd	r24, Y+22	; 0x16
    49e0:	9f 89       	ldd	r25, Y+23	; 0x17
    49e2:	a8 8d       	ldd	r26, Y+24	; 0x18
    49e4:	b9 8d       	ldd	r27, Y+25	; 0x19
    49e6:	01 96       	adiw	r24, 0x01	; 1
    49e8:	a1 1d       	adc	r26, r1
    49ea:	b1 1d       	adc	r27, r1
    49ec:	8e 8b       	std	Y+22, r24	; 0x16
    49ee:	9f 8b       	std	Y+23, r25	; 0x17
    49f0:	a8 8f       	std	Y+24, r26	; 0x18
    49f2:	b9 8f       	std	Y+25, r27	; 0x19
    49f4:	8a e9       	ldi	r24, 0x9A	; 154
    49f6:	9f ef       	ldi	r25, 0xFF	; 255
    49f8:	14 c0       	rjmp	.+40     	; 0x4a22 <csp_route_security_check+0x80>
    49fa:	f8 01       	movw	r30, r16
    49fc:	82 85       	ldd	r24, Z+10	; 0x0a
    49fe:	83 ff       	sbrs	r24, 3
    4a00:	0e c0       	rjmp	.+28     	; 0x4a1e <csp_route_security_check+0x7c>
    4a02:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4a04:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4a06:	a8 a1       	ldd	r26, Y+32	; 0x20
    4a08:	b9 a1       	ldd	r27, Y+33	; 0x21
    4a0a:	01 96       	adiw	r24, 0x01	; 1
    4a0c:	a1 1d       	adc	r26, r1
    4a0e:	b1 1d       	adc	r27, r1
    4a10:	8e 8f       	std	Y+30, r24	; 0x1e
    4a12:	9f 8f       	std	Y+31, r25	; 0x1f
    4a14:	a8 a3       	std	Y+32, r26	; 0x20
    4a16:	b9 a3       	std	Y+33, r27	; 0x21
    4a18:	8b ef       	ldi	r24, 0xFB	; 251
    4a1a:	9f ef       	ldi	r25, 0xFF	; 255
    4a1c:	02 c0       	rjmp	.+4      	; 0x4a22 <csp_route_security_check+0x80>
    4a1e:	80 e0       	ldi	r24, 0x00	; 0
    4a20:	90 e0       	ldi	r25, 0x00	; 0
    4a22:	df 91       	pop	r29
    4a24:	cf 91       	pop	r28
    4a26:	1f 91       	pop	r17
    4a28:	0f 91       	pop	r16
    4a2a:	08 95       	ret

00004a2c <csp_route_next_packet>:
    4a2c:	2f ef       	ldi	r18, 0xFF	; 255
    4a2e:	3f ef       	ldi	r19, 0xFF	; 255
    4a30:	40 e0       	ldi	r20, 0x00	; 0
    4a32:	50 e0       	ldi	r21, 0x00	; 0
    4a34:	bc 01       	movw	r22, r24
    4a36:	80 91 96 3a 	lds	r24, 0x3A96
    4a3a:	90 91 97 3a 	lds	r25, 0x3A97
    4a3e:	41 d8       	rcall	.-3966   	; 0x3ac2 <csp_queue_dequeue>
    4a40:	01 97       	sbiw	r24, 0x01	; 1
    4a42:	19 f0       	breq	.+6      	; 0x4a4a <csp_route_next_packet+0x1e>
    4a44:	8d ef       	ldi	r24, 0xFD	; 253
    4a46:	9f ef       	ldi	r25, 0xFF	; 255
    4a48:	08 95       	ret
    4a4a:	80 e0       	ldi	r24, 0x00	; 0
    4a4c:	90 e0       	ldi	r25, 0x00	; 0
    4a4e:	08 95       	ret

00004a50 <csp_route_start_task>:
    4a50:	ef 92       	push	r14
    4a52:	ff 92       	push	r15
    4a54:	0f 93       	push	r16
    4a56:	1f 93       	push	r17
    4a58:	0f 2e       	mov	r0, r31
    4a5a:	f8 e9       	ldi	r31, 0x98	; 152
    4a5c:	ef 2e       	mov	r14, r31
    4a5e:	fa e3       	ldi	r31, 0x3A	; 58
    4a60:	ff 2e       	mov	r15, r31
    4a62:	f0 2d       	mov	r31, r0
    4a64:	8b 01       	movw	r16, r22
    4a66:	20 e0       	ldi	r18, 0x00	; 0
    4a68:	30 e0       	ldi	r19, 0x00	; 0
    4a6a:	ac 01       	movw	r20, r24
    4a6c:	60 e9       	ldi	r22, 0x90	; 144
    4a6e:	70 e2       	ldi	r23, 0x20	; 32
    4a70:	8c ef       	ldi	r24, 0xFC	; 252
    4a72:	95 e2       	ldi	r25, 0x25	; 37
    4a74:	06 d9       	rcall	.-3572   	; 0x3c82 <csp_thread_create>
    4a76:	21 e0       	ldi	r18, 0x01	; 1
    4a78:	30 e0       	ldi	r19, 0x00	; 0
    4a7a:	89 2b       	or	r24, r25
    4a7c:	11 f4       	brne	.+4      	; 0x4a82 <csp_route_start_task+0x32>
    4a7e:	20 e0       	ldi	r18, 0x00	; 0
    4a80:	30 e0       	ldi	r19, 0x00	; 0
    4a82:	88 27       	eor	r24, r24
    4a84:	99 27       	eor	r25, r25
    4a86:	82 1b       	sub	r24, r18
    4a88:	93 0b       	sbc	r25, r19
    4a8a:	1f 91       	pop	r17
    4a8c:	0f 91       	pop	r16
    4a8e:	ff 90       	pop	r15
    4a90:	ef 90       	pop	r14
    4a92:	08 95       	ret

00004a94 <csp_route_get_if_by_name>:
    4a94:	0f 93       	push	r16
    4a96:	1f 93       	push	r17
    4a98:	cf 93       	push	r28
    4a9a:	df 93       	push	r29
    4a9c:	8c 01       	movw	r16, r24
    4a9e:	c0 91 fd 3a 	lds	r28, 0x3AFD
    4aa2:	d0 91 fe 3a 	lds	r29, 0x3AFE
    4aa6:	20 97       	sbiw	r28, 0x00	; 0
    4aa8:	71 f0       	breq	.+28     	; 0x4ac6 <csp_route_get_if_by_name+0x32>
    4aaa:	4a e0       	ldi	r20, 0x0A	; 10
    4aac:	50 e0       	ldi	r21, 0x00	; 0
    4aae:	b8 01       	movw	r22, r16
    4ab0:	88 81       	ld	r24, Y
    4ab2:	99 81       	ldd	r25, Y+1	; 0x01
    4ab4:	0e 94 77 41 	call	0x82ee	; 0x82ee <strncmp>
    4ab8:	89 2b       	or	r24, r25
    4aba:	29 f0       	breq	.+10     	; 0x4ac6 <csp_route_get_if_by_name+0x32>
    4abc:	0a a8       	ldd	r0, Y+50	; 0x32
    4abe:	db a9       	ldd	r29, Y+51	; 0x33
    4ac0:	c0 2d       	mov	r28, r0
    4ac2:	20 97       	sbiw	r28, 0x00	; 0
    4ac4:	91 f7       	brne	.-28     	; 0x4aaa <csp_route_get_if_by_name+0x16>
    4ac6:	ce 01       	movw	r24, r28
    4ac8:	df 91       	pop	r29
    4aca:	cf 91       	pop	r28
    4acc:	1f 91       	pop	r17
    4ace:	0f 91       	pop	r16
    4ad0:	08 95       	ret

00004ad2 <csp_route_add_if>:
    4ad2:	a0 91 fd 3a 	lds	r26, 0x3AFD
    4ad6:	b0 91 fe 3a 	lds	r27, 0x3AFE
    4ada:	10 97       	sbiw	r26, 0x00	; 0
    4adc:	41 f4       	brne	.+16     	; 0x4aee <csp_route_add_if+0x1c>
    4ade:	80 93 fd 3a 	sts	0x3AFD, r24
    4ae2:	90 93 fe 3a 	sts	0x3AFE, r25
    4ae6:	fc 01       	movw	r30, r24
    4ae8:	12 aa       	std	Z+50, r1	; 0x32
    4aea:	13 aa       	std	Z+51, r1	; 0x33
    4aec:	08 95       	ret
    4aee:	a8 17       	cp	r26, r24
    4af0:	b9 07       	cpc	r27, r25
    4af2:	b9 f0       	breq	.+46     	; 0x4b22 <csp_route_add_if+0x50>
    4af4:	d2 96       	adiw	r26, 0x32	; 50
    4af6:	ed 91       	ld	r30, X+
    4af8:	fc 91       	ld	r31, X
    4afa:	d3 97       	sbiw	r26, 0x33	; 51
    4afc:	30 97       	sbiw	r30, 0x00	; 0
    4afe:	39 f4       	brne	.+14     	; 0x4b0e <csp_route_add_if+0x3c>
    4b00:	0a c0       	rjmp	.+20     	; 0x4b16 <csp_route_add_if+0x44>
    4b02:	22 a9       	ldd	r18, Z+50	; 0x32
    4b04:	33 a9       	ldd	r19, Z+51	; 0x33
    4b06:	21 15       	cp	r18, r1
    4b08:	31 05       	cpc	r19, r1
    4b0a:	31 f0       	breq	.+12     	; 0x4b18 <csp_route_add_if+0x46>
    4b0c:	f9 01       	movw	r30, r18
    4b0e:	8e 17       	cp	r24, r30
    4b10:	9f 07       	cpc	r25, r31
    4b12:	b9 f7       	brne	.-18     	; 0x4b02 <csp_route_add_if+0x30>
    4b14:	08 95       	ret
    4b16:	fd 01       	movw	r30, r26
    4b18:	82 ab       	std	Z+50, r24	; 0x32
    4b1a:	93 ab       	std	Z+51, r25	; 0x33
    4b1c:	fc 01       	movw	r30, r24
    4b1e:	12 aa       	std	Z+50, r1	; 0x32
    4b20:	13 aa       	std	Z+51, r1	; 0x33
    4b22:	08 95       	ret

00004b24 <csp_route_set>:
    4b24:	0f 93       	push	r16
    4b26:	1f 93       	push	r17
    4b28:	cf 93       	push	r28
    4b2a:	df 93       	push	r29
    4b2c:	18 2f       	mov	r17, r24
    4b2e:	eb 01       	movw	r28, r22
    4b30:	04 2f       	mov	r16, r20
    4b32:	20 97       	sbiw	r28, 0x00	; 0
    4b34:	99 f0       	breq	.+38     	; 0x4b5c <csp_route_set+0x38>
    4b36:	cb 01       	movw	r24, r22
    4b38:	cc df       	rcall	.-104    	; 0x4ad2 <csp_route_add_if>
    4b3a:	11 32       	cpi	r17, 0x21	; 33
    4b3c:	90 f4       	brcc	.+36     	; 0x4b62 <csp_route_set+0x3e>
    4b3e:	81 2f       	mov	r24, r17
    4b40:	90 e0       	ldi	r25, 0x00	; 0
    4b42:	fc 01       	movw	r30, r24
    4b44:	ee 0f       	add	r30, r30
    4b46:	ff 1f       	adc	r31, r31
    4b48:	e8 0f       	add	r30, r24
    4b4a:	f9 1f       	adc	r31, r25
    4b4c:	e6 56       	subi	r30, 0x66	; 102
    4b4e:	f5 4c       	sbci	r31, 0xC5	; 197
    4b50:	c0 83       	st	Z, r28
    4b52:	d1 83       	std	Z+1, r29	; 0x01
    4b54:	02 83       	std	Z+2, r16	; 0x02
    4b56:	80 e0       	ldi	r24, 0x00	; 0
    4b58:	90 e0       	ldi	r25, 0x00	; 0
    4b5a:	05 c0       	rjmp	.+10     	; 0x4b66 <csp_route_set+0x42>
    4b5c:	8e ef       	ldi	r24, 0xFE	; 254
    4b5e:	9f ef       	ldi	r25, 0xFF	; 255
    4b60:	02 c0       	rjmp	.+4      	; 0x4b66 <csp_route_set+0x42>
    4b62:	8e ef       	ldi	r24, 0xFE	; 254
    4b64:	9f ef       	ldi	r25, 0xFF	; 255
    4b66:	df 91       	pop	r29
    4b68:	cf 91       	pop	r28
    4b6a:	1f 91       	pop	r17
    4b6c:	0f 91       	pop	r16
    4b6e:	08 95       	ret

00004b70 <csp_route_table_init>:
    4b70:	83 e6       	ldi	r24, 0x63	; 99
    4b72:	ea e9       	ldi	r30, 0x9A	; 154
    4b74:	fa e3       	ldi	r31, 0x3A	; 58
    4b76:	df 01       	movw	r26, r30
    4b78:	1d 92       	st	X+, r1
    4b7a:	8a 95       	dec	r24
    4b7c:	e9 f7       	brne	.-6      	; 0x4b78 <csp_route_table_init+0x8>
    4b7e:	80 91 96 3a 	lds	r24, 0x3A96
    4b82:	90 91 97 3a 	lds	r25, 0x3A97
    4b86:	89 2b       	or	r24, r25
    4b88:	61 f4       	brne	.+24     	; 0x4ba2 <csp_route_table_init+0x32>
    4b8a:	64 e0       	ldi	r22, 0x04	; 4
    4b8c:	70 e0       	ldi	r23, 0x00	; 0
    4b8e:	8a e0       	ldi	r24, 0x0A	; 10
    4b90:	90 e0       	ldi	r25, 0x00	; 0
    4b92:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <csp_queue_create>
    4b96:	80 93 96 3a 	sts	0x3A96, r24
    4b9a:	90 93 97 3a 	sts	0x3A97, r25
    4b9e:	89 2b       	or	r24, r25
    4ba0:	71 f0       	breq	.+28     	; 0x4bbe <csp_route_table_init+0x4e>
    4ba2:	4f ef       	ldi	r20, 0xFF	; 255
    4ba4:	6a e3       	ldi	r22, 0x3A	; 58
    4ba6:	70 e2       	ldi	r23, 0x20	; 32
    4ba8:	80 91 88 3c 	lds	r24, 0x3C88
    4bac:	bb df       	rcall	.-138    	; 0x4b24 <csp_route_set>
    4bae:	4f ef       	ldi	r20, 0xFF	; 255
    4bb0:	6a e3       	ldi	r22, 0x3A	; 58
    4bb2:	70 e2       	ldi	r23, 0x20	; 32
    4bb4:	80 e2       	ldi	r24, 0x20	; 32
    4bb6:	b6 df       	rcall	.-148    	; 0x4b24 <csp_route_set>
    4bb8:	80 e0       	ldi	r24, 0x00	; 0
    4bba:	90 e0       	ldi	r25, 0x00	; 0
    4bbc:	08 95       	ret
    4bbe:	8f ef       	ldi	r24, 0xFF	; 255
    4bc0:	9f ef       	ldi	r25, 0xFF	; 255
    4bc2:	08 95       	ret

00004bc4 <csp_route_if>:
    4bc4:	90 e0       	ldi	r25, 0x00	; 0
    4bc6:	fc 01       	movw	r30, r24
    4bc8:	ee 0f       	add	r30, r30
    4bca:	ff 1f       	adc	r31, r31
    4bcc:	e8 0f       	add	r30, r24
    4bce:	f9 1f       	adc	r31, r25
    4bd0:	e6 56       	subi	r30, 0x66	; 102
    4bd2:	f5 4c       	sbci	r31, 0xC5	; 197
    4bd4:	20 81       	ld	r18, Z
    4bd6:	31 81       	ldd	r19, Z+1	; 0x01
    4bd8:	23 2b       	or	r18, r19
    4bda:	11 f0       	breq	.+4      	; 0x4be0 <csp_route_if+0x1c>
    4bdc:	cf 01       	movw	r24, r30
    4bde:	08 95       	ret
    4be0:	80 91 fa 3a 	lds	r24, 0x3AFA
    4be4:	90 91 fb 3a 	lds	r25, 0x3AFB
    4be8:	89 2b       	or	r24, r25
    4bea:	19 f0       	breq	.+6      	; 0x4bf2 <csp_route_if+0x2e>
    4bec:	8a ef       	ldi	r24, 0xFA	; 250
    4bee:	9a e3       	ldi	r25, 0x3A	; 58
    4bf0:	08 95       	ret
    4bf2:	80 e0       	ldi	r24, 0x00	; 0
    4bf4:	90 e0       	ldi	r25, 0x00	; 0
    4bf6:	08 95       	ret

00004bf8 <csp_task_router>:
    4bf8:	cf 93       	push	r28
    4bfa:	df 93       	push	r29
    4bfc:	00 d0       	rcall	.+0      	; 0x4bfe <csp_task_router+0x6>
    4bfe:	00 d0       	rcall	.+0      	; 0x4c00 <csp_task_router+0x8>
    4c00:	cd b7       	in	r28, 0x3d	; 61
    4c02:	de b7       	in	r29, 0x3e	; 62
    4c04:	80 91 96 3a 	lds	r24, 0x3A96
    4c08:	90 91 97 3a 	lds	r25, 0x3A97
    4c0c:	89 2b       	or	r24, r25
    4c0e:	21 f4       	brne	.+8      	; 0x4c18 <csp_task_router+0x20>
    4c10:	80 e0       	ldi	r24, 0x00	; 0
    4c12:	90 e0       	ldi	r25, 0x00	; 0
    4c14:	0e 94 b0 15 	call	0x2b60	; 0x2b60 <vTaskDelete>
    4c18:	ce 01       	movw	r24, r28
    4c1a:	01 96       	adiw	r24, 0x01	; 1
    4c1c:	07 df       	rcall	.-498    	; 0x4a2c <csp_route_next_packet>
    4c1e:	89 2b       	or	r24, r25
    4c20:	d9 f7       	brne	.-10     	; 0x4c18 <csp_task_router+0x20>
    4c22:	cb 80       	ldd	r12, Y+3	; 0x03
    4c24:	dc 80       	ldd	r13, Y+4	; 0x04
    4c26:	cd 82       	std	Y+5, r12	; 0x05
    4c28:	de 82       	std	Y+6, r13	; 0x06
    4c2a:	d6 01       	movw	r26, r12
    4c2c:	1c 96       	adiw	r26, 0x0c	; 12
    4c2e:	9c 91       	ld	r25, X
    4c30:	1c 97       	sbiw	r26, 0x0c	; 12
    4c32:	92 95       	swap	r25
    4c34:	9f 70       	andi	r25, 0x0F	; 15
    4c36:	1d 96       	adiw	r26, 0x0d	; 13
    4c38:	8c 91       	ld	r24, X
    4c3a:	81 70       	andi	r24, 0x01	; 1
    4c3c:	82 95       	swap	r24
    4c3e:	80 7f       	andi	r24, 0xF0	; 240
    4c40:	89 2b       	or	r24, r25
    4c42:	48 2f       	mov	r20, r24
    4c44:	50 e0       	ldi	r21, 0x00	; 0
    4c46:	20 91 88 3c 	lds	r18, 0x3C88
    4c4a:	30 e0       	ldi	r19, 0x00	; 0
    4c4c:	42 17       	cp	r20, r18
    4c4e:	53 07       	cpc	r21, r19
    4c50:	21 f1       	breq	.+72     	; 0x4c9a <csp_task_router+0xa2>
    4c52:	8f 31       	cpi	r24, 0x1F	; 31
    4c54:	11 f1       	breq	.+68     	; 0x4c9a <csp_task_router+0xa2>
    4c56:	b6 df       	rcall	.-148    	; 0x4bc4 <csp_route_if>
    4c58:	00 97       	sbiw	r24, 0x00	; 0
    4c5a:	59 f0       	breq	.+22     	; 0x4c72 <csp_task_router+0x7a>
    4c5c:	dc 01       	movw	r26, r24
    4c5e:	ed 91       	ld	r30, X+
    4c60:	fc 91       	ld	r31, X
    4c62:	89 81       	ldd	r24, Y+1	; 0x01
    4c64:	9a 81       	ldd	r25, Y+2	; 0x02
    4c66:	e8 17       	cp	r30, r24
    4c68:	f9 07       	cpc	r31, r25
    4c6a:	31 f4       	brne	.+12     	; 0x4c78 <csp_task_router+0x80>
    4c6c:	81 85       	ldd	r24, Z+9	; 0x09
    4c6e:	81 11       	cpse	r24, r1
    4c70:	03 c0       	rjmp	.+6      	; 0x4c78 <csp_task_router+0x80>
    4c72:	c6 01       	movw	r24, r12
    4c74:	3e d9       	rcall	.-3460   	; 0x3ef2 <csp_buffer_free>
    4c76:	d0 cf       	rjmp	.-96     	; 0x4c18 <csp_task_router+0x20>
    4c78:	f6 01       	movw	r30, r12
    4c7a:	62 85       	ldd	r22, Z+10	; 0x0a
    4c7c:	73 85       	ldd	r23, Z+11	; 0x0b
    4c7e:	84 85       	ldd	r24, Z+12	; 0x0c
    4c80:	95 85       	ldd	r25, Z+13	; 0x0d
    4c82:	00 e0       	ldi	r16, 0x00	; 0
    4c84:	10 e0       	ldi	r17, 0x00	; 0
    4c86:	98 01       	movw	r18, r16
    4c88:	a6 01       	movw	r20, r12
    4c8a:	d3 dc       	rcall	.-1626   	; 0x4632 <csp_send_direct>
    4c8c:	89 2b       	or	r24, r25
    4c8e:	09 f4       	brne	.+2      	; 0x4c92 <csp_task_router+0x9a>
    4c90:	c3 cf       	rjmp	.-122    	; 0x4c18 <csp_task_router+0x20>
    4c92:	8d 81       	ldd	r24, Y+5	; 0x05
    4c94:	9e 81       	ldd	r25, Y+6	; 0x06
    4c96:	2d d9       	rcall	.-3494   	; 0x3ef2 <csp_buffer_free>
    4c98:	bf cf       	rjmp	.-130    	; 0x4c18 <csp_task_router+0x20>
    4c9a:	d6 01       	movw	r26, r12
    4c9c:	1b 96       	adiw	r26, 0x0b	; 11
    4c9e:	9c 91       	ld	r25, X
    4ca0:	1b 97       	sbiw	r26, 0x0b	; 11
    4ca2:	92 95       	swap	r25
    4ca4:	96 95       	lsr	r25
    4ca6:	96 95       	lsr	r25
    4ca8:	93 70       	andi	r25, 0x03	; 3
    4caa:	1c 96       	adiw	r26, 0x0c	; 12
    4cac:	8c 91       	ld	r24, X
    4cae:	8f 70       	andi	r24, 0x0F	; 15
    4cb0:	88 0f       	add	r24, r24
    4cb2:	88 0f       	add	r24, r24
    4cb4:	89 2b       	or	r24, r25
    4cb6:	90 e0       	ldi	r25, 0x00	; 0
    4cb8:	01 de       	rcall	.-1022   	; 0x48bc <csp_port_get_socket>
    4cba:	8c 01       	movw	r16, r24
    4cbc:	00 97       	sbiw	r24, 0x00	; 0
    4cbe:	09 f4       	brne	.+2      	; 0x4cc2 <csp_task_router+0xca>
    4cc0:	b5 c0       	rjmp	.+362    	; 0x4e2c <csp_task_router+0x234>
    4cc2:	fc 01       	movw	r30, r24
    4cc4:	64 89       	ldd	r22, Z+20	; 0x14
    4cc6:	75 89       	ldd	r23, Z+21	; 0x15
    4cc8:	86 89       	ldd	r24, Z+22	; 0x16
    4cca:	97 89       	ldd	r25, Z+23	; 0x17
    4ccc:	70 ff       	sbrs	r23, 0
    4cce:	bd c0       	rjmp	.+378    	; 0x4e4a <csp_task_router+0x252>
    4cd0:	2d 81       	ldd	r18, Y+5	; 0x05
    4cd2:	3e 81       	ldd	r19, Y+6	; 0x06
    4cd4:	49 81       	ldd	r20, Y+1	; 0x01
    4cd6:	5a 81       	ldd	r21, Y+2	; 0x02
    4cd8:	64 de       	rcall	.-824    	; 0x49a2 <csp_route_security_check>
    4cda:	99 23       	and	r25, r25
    4cdc:	24 f4       	brge	.+8      	; 0x4ce6 <csp_task_router+0xee>
    4cde:	8d 81       	ldd	r24, Y+5	; 0x05
    4ce0:	9e 81       	ldd	r25, Y+6	; 0x06
    4ce2:	07 d9       	rcall	.-3570   	; 0x3ef2 <csp_buffer_free>
    4ce4:	99 cf       	rjmp	.-206    	; 0x4c18 <csp_task_router+0x20>
    4ce6:	20 e0       	ldi	r18, 0x00	; 0
    4ce8:	30 e0       	ldi	r19, 0x00	; 0
    4cea:	a9 01       	movw	r20, r18
    4cec:	be 01       	movw	r22, r28
    4cee:	6b 5f       	subi	r22, 0xFB	; 251
    4cf0:	7f 4f       	sbci	r23, 0xFF	; 255
    4cf2:	d8 01       	movw	r26, r16
    4cf4:	1e 96       	adiw	r26, 0x0e	; 14
    4cf6:	8d 91       	ld	r24, X+
    4cf8:	9c 91       	ld	r25, X
    4cfa:	1f 97       	sbiw	r26, 0x0f	; 15
    4cfc:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <csp_queue_enqueue>
    4d00:	01 97       	sbiw	r24, 0x01	; 1
    4d02:	09 f4       	brne	.+2      	; 0x4d06 <csp_task_router+0x10e>
    4d04:	89 cf       	rjmp	.-238    	; 0x4c18 <csp_task_router+0x20>
    4d06:	8d 81       	ldd	r24, Y+5	; 0x05
    4d08:	9e 81       	ldd	r25, Y+6	; 0x06
    4d0a:	f3 d8       	rcall	.-3610   	; 0x3ef2 <csp_buffer_free>
    4d0c:	85 cf       	rjmp	.-246    	; 0x4c18 <csp_task_router+0x20>
    4d0e:	8d 81       	ldd	r24, Y+5	; 0x05
    4d10:	9e 81       	ldd	r25, Y+6	; 0x06
    4d12:	ef d8       	rcall	.-3618   	; 0x3ef2 <csp_buffer_free>
    4d14:	81 cf       	rjmp	.-254    	; 0x4c18 <csp_task_router+0x20>
    4d16:	2d 81       	ldd	r18, Y+5	; 0x05
    4d18:	3e 81       	ldd	r19, Y+6	; 0x06
    4d1a:	49 81       	ldd	r20, Y+1	; 0x01
    4d1c:	5a 81       	ldd	r21, Y+2	; 0x02
    4d1e:	f8 01       	movw	r30, r16
    4d20:	64 89       	ldd	r22, Z+20	; 0x14
    4d22:	75 89       	ldd	r23, Z+21	; 0x15
    4d24:	86 89       	ldd	r24, Z+22	; 0x16
    4d26:	97 89       	ldd	r25, Z+23	; 0x17
    4d28:	3c de       	rcall	.-904    	; 0x49a2 <csp_route_security_check>
    4d2a:	99 23       	and	r25, r25
    4d2c:	24 f4       	brge	.+8      	; 0x4d36 <csp_task_router+0x13e>
    4d2e:	8d 81       	ldd	r24, Y+5	; 0x05
    4d30:	9e 81       	ldd	r25, Y+6	; 0x06
    4d32:	df d8       	rcall	.-3650   	; 0x3ef2 <csp_buffer_free>
    4d34:	71 cf       	rjmp	.-286    	; 0x4c18 <csp_task_router+0x20>
    4d36:	ed 81       	ldd	r30, Y+5	; 0x05
    4d38:	fe 81       	ldd	r31, Y+6	; 0x06
    4d3a:	95 85       	ldd	r25, Z+13	; 0x0d
    4d3c:	89 2f       	mov	r24, r25
    4d3e:	80 7c       	andi	r24, 0xC0	; 192
    4d40:	2f 2d       	mov	r18, r15
    4d42:	2f 73       	andi	r18, 0x3F	; 63
    4d44:	f2 2e       	mov	r15, r18
    4d46:	f8 2a       	or	r15, r24
    4d48:	80 91 88 3c 	lds	r24, 0x3C88
    4d4c:	8f 71       	andi	r24, 0x1F	; 31
    4d4e:	88 0f       	add	r24, r24
    4d50:	2f 2d       	mov	r18, r15
    4d52:	21 7c       	andi	r18, 0xC1	; 193
    4d54:	f2 2e       	mov	r15, r18
    4d56:	f8 2a       	or	r15, r24
    4d58:	96 95       	lsr	r25
    4d5a:	94 fb       	bst	r25, 4
    4d5c:	88 27       	eor	r24, r24
    4d5e:	80 f9       	bld	r24, 0
    4d60:	80 fb       	bst	r24, 0
    4d62:	f0 f8       	bld	r15, 0
    4d64:	83 85       	ldd	r24, Z+11	; 0x0b
    4d66:	48 2f       	mov	r20, r24
    4d68:	4f 73       	andi	r20, 0x3F	; 63
    4d6a:	46 95       	lsr	r20
    4d6c:	46 95       	lsr	r20
    4d6e:	92 95       	swap	r25
    4d70:	90 7f       	andi	r25, 0xF0	; 240
    4d72:	49 2b       	or	r20, r25
    4d74:	98 2f       	mov	r25, r24
    4d76:	92 95       	swap	r25
    4d78:	96 95       	lsr	r25
    4d7a:	96 95       	lsr	r25
    4d7c:	93 70       	andi	r25, 0x03	; 3
    4d7e:	34 85       	ldd	r19, Z+12	; 0x0c
    4d80:	3f 70       	andi	r19, 0x0F	; 15
    4d82:	33 0f       	add	r19, r19
    4d84:	33 0f       	add	r19, r19
    4d86:	39 2b       	or	r19, r25
    4d88:	82 95       	swap	r24
    4d8a:	88 0f       	add	r24, r24
    4d8c:	88 0f       	add	r24, r24
    4d8e:	80 7c       	andi	r24, 0xC0	; 192
    4d90:	38 2b       	or	r19, r24
    4d92:	22 85       	ldd	r18, Z+10	; 0x0a
    4d94:	62 85       	ldd	r22, Z+10	; 0x0a
    4d96:	73 85       	ldd	r23, Z+11	; 0x0b
    4d98:	84 85       	ldd	r24, Z+12	; 0x0c
    4d9a:	95 85       	ldd	r25, Z+13	; 0x0d
    4d9c:	5f 2d       	mov	r21, r15
    4d9e:	16 da       	rcall	.-3028   	; 0x41cc <csp_conn_new>
    4da0:	6c 01       	movw	r12, r24
    4da2:	00 97       	sbiw	r24, 0x00	; 0
    4da4:	21 f4       	brne	.+8      	; 0x4dae <csp_task_router+0x1b6>
    4da6:	8d 81       	ldd	r24, Y+5	; 0x05
    4da8:	9e 81       	ldd	r25, Y+6	; 0x06
    4daa:	a3 d8       	rcall	.-3770   	; 0x3ef2 <csp_buffer_free>
    4dac:	35 cf       	rjmp	.-406    	; 0x4c18 <csp_task_router+0x20>
    4dae:	d8 01       	movw	r26, r16
    4db0:	1e 96       	adiw	r26, 0x0e	; 14
    4db2:	8d 91       	ld	r24, X+
    4db4:	9c 91       	ld	r25, X
    4db6:	1f 97       	sbiw	r26, 0x0f	; 15
    4db8:	f6 01       	movw	r30, r12
    4dba:	86 87       	std	Z+14, r24	; 0x0e
    4dbc:	97 87       	std	Z+15, r25	; 0x0f
    4dbe:	54 96       	adiw	r26, 0x14	; 20
    4dc0:	8d 91       	ld	r24, X+
    4dc2:	9d 91       	ld	r25, X+
    4dc4:	0d 90       	ld	r0, X+
    4dc6:	bc 91       	ld	r27, X
    4dc8:	a0 2d       	mov	r26, r0
    4dca:	84 8b       	std	Z+20, r24	; 0x14
    4dcc:	95 8b       	std	Z+21, r25	; 0x15
    4dce:	a6 8b       	std	Z+22, r26	; 0x16
    4dd0:	b7 8b       	std	Z+23, r27	; 0x17
    4dd2:	12 c0       	rjmp	.+36     	; 0x4df8 <csp_task_router+0x200>
    4dd4:	2d 81       	ldd	r18, Y+5	; 0x05
    4dd6:	3e 81       	ldd	r19, Y+6	; 0x06
    4dd8:	49 81       	ldd	r20, Y+1	; 0x01
    4dda:	5a 81       	ldd	r21, Y+2	; 0x02
    4ddc:	d6 01       	movw	r26, r12
    4dde:	54 96       	adiw	r26, 0x14	; 20
    4de0:	6d 91       	ld	r22, X+
    4de2:	7d 91       	ld	r23, X+
    4de4:	8d 91       	ld	r24, X+
    4de6:	9c 91       	ld	r25, X
    4de8:	57 97       	sbiw	r26, 0x17	; 23
    4dea:	db dd       	rcall	.-1098   	; 0x49a2 <csp_route_security_check>
    4dec:	99 23       	and	r25, r25
    4dee:	24 f4       	brge	.+8      	; 0x4df8 <csp_task_router+0x200>
    4df0:	8d 81       	ldd	r24, Y+5	; 0x05
    4df2:	9e 81       	ldd	r25, Y+6	; 0x06
    4df4:	7e d8       	rcall	.-3844   	; 0x3ef2 <csp_buffer_free>
    4df6:	10 cf       	rjmp	.-480    	; 0x4c18 <csp_task_router+0x20>
    4df8:	8d 81       	ldd	r24, Y+5	; 0x05
    4dfa:	9e 81       	ldd	r25, Y+6	; 0x06
    4dfc:	fc 01       	movw	r30, r24
    4dfe:	22 85       	ldd	r18, Z+10	; 0x0a
    4e00:	21 ff       	sbrs	r18, 1
    4e02:	10 c0       	rjmp	.+32     	; 0x4e24 <csp_task_router+0x22c>
    4e04:	e9 81       	ldd	r30, Y+1	; 0x01
    4e06:	fa 81       	ldd	r31, Y+2	; 0x02
    4e08:	46 89       	ldd	r20, Z+22	; 0x16
    4e0a:	57 89       	ldd	r21, Z+23	; 0x17
    4e0c:	60 8d       	ldd	r22, Z+24	; 0x18
    4e0e:	71 8d       	ldd	r23, Z+25	; 0x19
    4e10:	4f 5f       	subi	r20, 0xFF	; 255
    4e12:	5f 4f       	sbci	r21, 0xFF	; 255
    4e14:	6f 4f       	sbci	r22, 0xFF	; 255
    4e16:	7f 4f       	sbci	r23, 0xFF	; 255
    4e18:	46 8b       	std	Z+22, r20	; 0x16
    4e1a:	57 8b       	std	Z+23, r21	; 0x17
    4e1c:	60 8f       	std	Z+24, r22	; 0x18
    4e1e:	71 8f       	std	Z+25, r23	; 0x19
    4e20:	68 d8       	rcall	.-3888   	; 0x3ef2 <csp_buffer_free>
    4e22:	fa ce       	rjmp	.-524    	; 0x4c18 <csp_task_router+0x20>
    4e24:	bc 01       	movw	r22, r24
    4e26:	c6 01       	movw	r24, r12
    4e28:	8a d3       	rcall	.+1812   	; 0x553e <csp_udp_new_packet>
    4e2a:	f6 ce       	rjmp	.-532    	; 0x4c18 <csp_task_router+0x20>
    4e2c:	ed 81       	ldd	r30, Y+5	; 0x05
    4e2e:	fe 81       	ldd	r31, Y+6	; 0x06
    4e30:	62 85       	ldd	r22, Z+10	; 0x0a
    4e32:	73 85       	ldd	r23, Z+11	; 0x0b
    4e34:	84 85       	ldd	r24, Z+12	; 0x0c
    4e36:	95 85       	ldd	r25, Z+13	; 0x0d
    4e38:	20 e0       	ldi	r18, 0x00	; 0
    4e3a:	3f ef       	ldi	r19, 0xFF	; 255
    4e3c:	4f ef       	ldi	r20, 0xFF	; 255
    4e3e:	5f e3       	ldi	r21, 0x3F	; 63
    4e40:	05 d9       	rcall	.-3574   	; 0x404c <csp_conn_find>
    4e42:	6c 01       	movw	r12, r24
    4e44:	00 97       	sbiw	r24, 0x00	; 0
    4e46:	31 f6       	brne	.-116    	; 0x4dd4 <csp_task_router+0x1dc>
    4e48:	62 cf       	rjmp	.-316    	; 0x4d0e <csp_task_router+0x116>
    4e4a:	ed 81       	ldd	r30, Y+5	; 0x05
    4e4c:	fe 81       	ldd	r31, Y+6	; 0x06
    4e4e:	62 85       	ldd	r22, Z+10	; 0x0a
    4e50:	73 85       	ldd	r23, Z+11	; 0x0b
    4e52:	84 85       	ldd	r24, Z+12	; 0x0c
    4e54:	95 85       	ldd	r25, Z+13	; 0x0d
    4e56:	20 e0       	ldi	r18, 0x00	; 0
    4e58:	3f ef       	ldi	r19, 0xFF	; 255
    4e5a:	4f ef       	ldi	r20, 0xFF	; 255
    4e5c:	5f e3       	ldi	r21, 0x3F	; 63
    4e5e:	f6 d8       	rcall	.-3604   	; 0x404c <csp_conn_find>
    4e60:	6c 01       	movw	r12, r24
    4e62:	00 97       	sbiw	r24, 0x00	; 0
    4e64:	09 f0       	breq	.+2      	; 0x4e68 <csp_task_router+0x270>
    4e66:	b6 cf       	rjmp	.-148    	; 0x4dd4 <csp_task_router+0x1dc>
    4e68:	56 cf       	rjmp	.-340    	; 0x4d16 <csp_task_router+0x11e>

00004e6a <csp_route_enqueue>:
    4e6a:	0f 93       	push	r16
    4e6c:	1f 93       	push	r17
    4e6e:	01 15       	cp	r16, r1
    4e70:	11 05       	cpc	r17, r1
    4e72:	19 f4       	brne	.+6      	; 0x4e7a <csp_route_enqueue+0x10>
    4e74:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <csp_queue_enqueue>
    4e78:	03 c0       	rjmp	.+6      	; 0x4e80 <csp_route_enqueue+0x16>
    4e7a:	a8 01       	movw	r20, r16
    4e7c:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <csp_queue_enqueue_isr>
    4e80:	01 97       	sbiw	r24, 0x01	; 1
    4e82:	19 f4       	brne	.+6      	; 0x4e8a <csp_route_enqueue+0x20>
    4e84:	80 e0       	ldi	r24, 0x00	; 0
    4e86:	90 e0       	ldi	r25, 0x00	; 0
    4e88:	02 c0       	rjmp	.+4      	; 0x4e8e <csp_route_enqueue+0x24>
    4e8a:	87 ef       	ldi	r24, 0xF7	; 247
    4e8c:	9f ef       	ldi	r25, 0xFF	; 255
    4e8e:	1f 91       	pop	r17
    4e90:	0f 91       	pop	r16
    4e92:	08 95       	ret

00004e94 <csp_new_packet>:

void csp_new_packet(csp_packet_t * packet, csp_iface_t * interface, CSP_BASE_TYPE * pxTaskWoken) {
    4e94:	af 92       	push	r10
    4e96:	bf 92       	push	r11
    4e98:	cf 92       	push	r12
    4e9a:	df 92       	push	r13
    4e9c:	ef 92       	push	r14
    4e9e:	ff 92       	push	r15
    4ea0:	0f 93       	push	r16
    4ea2:	1f 93       	push	r17
    4ea4:	cf 93       	push	r28
    4ea6:	df 93       	push	r29
    4ea8:	00 d0       	rcall	.+0      	; 0x4eaa <csp_new_packet+0x16>
    4eaa:	1f 92       	push	r1
    4eac:	cd b7       	in	r28, 0x3d	; 61
    4eae:	de b7       	in	r29, 0x3e	; 62
    4eb0:	6c 01       	movw	r12, r24
    4eb2:	7b 01       	movw	r14, r22
    4eb4:	5a 01       	movw	r10, r20

	int result, fifo;

	if (packet == NULL) {
    4eb6:	00 97       	sbiw	r24, 0x00	; 0
    4eb8:	09 f4       	brne	.+2      	; 0x4ebc <csp_new_packet+0x28>
    4eba:	50 c0       	rjmp	.+160    	; 0x4f5c <csp_new_packet+0xc8>
		csp_log_warn("csp_new packet called with NULL packet\r\n");
		return;
	} else if (interface == NULL) {
    4ebc:	61 15       	cp	r22, r1
    4ebe:	71 05       	cpc	r23, r1
    4ec0:	41 f4       	brne	.+16     	; 0x4ed2 <csp_new_packet+0x3e>
		csp_log_warn("csp_new packet called with NULL interface\r\n");
		if (pxTaskWoken == NULL)
    4ec2:	41 15       	cp	r20, r1
    4ec4:	51 05       	cpc	r21, r1
    4ec6:	11 f4       	brne	.+4      	; 0x4ecc <csp_new_packet+0x38>
			csp_buffer_free(packet);
    4ec8:	14 d8       	rcall	.-4056   	; 0x3ef2 <csp_buffer_free>
    4eca:	48 c0       	rjmp	.+144    	; 0x4f5c <csp_new_packet+0xc8>
		else
			csp_buffer_free_isr(packet);
    4ecc:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <csp_buffer_free_isr>
    4ed0:	45 c0       	rjmp	.+138    	; 0x4f5c <csp_new_packet+0xc8>
		return;
	}

	csp_route_queue_t queue_element;
	queue_element.interface = interface;
    4ed2:	69 83       	std	Y+1, r22	; 0x01
    4ed4:	7a 83       	std	Y+2, r23	; 0x02
	queue_element.outcomingPacket = packet;
    4ed6:	8b 83       	std	Y+3, r24	; 0x03
    4ed8:	9c 83       	std	Y+4, r25	; 0x04

	fifo = csp_route_get_fifo(packet->id.pri);
	result = csp_route_enqueue(router_input_fifo[fifo], &queue_element, 0, pxTaskWoken);
    4eda:	8a 01       	movw	r16, r20
    4edc:	20 e0       	ldi	r18, 0x00	; 0
    4ede:	30 e0       	ldi	r19, 0x00	; 0
    4ee0:	a9 01       	movw	r20, r18
    4ee2:	be 01       	movw	r22, r28
    4ee4:	6f 5f       	subi	r22, 0xFF	; 255
    4ee6:	7f 4f       	sbci	r23, 0xFF	; 255
    4ee8:	80 91 96 3a 	lds	r24, 0x3A96
    4eec:	90 91 97 3a 	lds	r25, 0x3A97
    4ef0:	bc df       	rcall	.-136    	; 0x4e6a <csp_route_enqueue>

	if (result != CSP_ERR_NONE) {
    4ef2:	89 2b       	or	r24, r25
    4ef4:	b1 f0       	breq	.+44     	; 0x4f22 <csp_new_packet+0x8e>
		csp_log_warn("ERROR: Routing input FIFO is FULL. Dropping packet.\r\n");
		interface->drop++;
    4ef6:	f7 01       	movw	r30, r14
    4ef8:	82 8d       	ldd	r24, Z+26	; 0x1a
    4efa:	93 8d       	ldd	r25, Z+27	; 0x1b
    4efc:	a4 8d       	ldd	r26, Z+28	; 0x1c
    4efe:	b5 8d       	ldd	r27, Z+29	; 0x1d
    4f00:	01 96       	adiw	r24, 0x01	; 1
    4f02:	a1 1d       	adc	r26, r1
    4f04:	b1 1d       	adc	r27, r1
    4f06:	82 8f       	std	Z+26, r24	; 0x1a
    4f08:	93 8f       	std	Z+27, r25	; 0x1b
    4f0a:	a4 8f       	std	Z+28, r26	; 0x1c
    4f0c:	b5 8f       	std	Z+29, r27	; 0x1d
		if (pxTaskWoken == NULL)
    4f0e:	ab 28       	or	r10, r11
    4f10:	21 f4       	brne	.+8      	; 0x4f1a <csp_new_packet+0x86>
			csp_buffer_free(packet);
    4f12:	c6 01       	movw	r24, r12
    4f14:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <csp_buffer_free>
    4f18:	21 c0       	rjmp	.+66     	; 0x4f5c <csp_new_packet+0xc8>
		else
			csp_buffer_free_isr(packet);
    4f1a:	c6 01       	movw	r24, r12
    4f1c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <csp_buffer_free_isr>
    4f20:	1d c0       	rjmp	.+58     	; 0x4f5c <csp_new_packet+0xc8>
	} else {
		interface->rx++;
    4f22:	f7 01       	movw	r30, r14
    4f24:	46 85       	ldd	r20, Z+14	; 0x0e
    4f26:	57 85       	ldd	r21, Z+15	; 0x0f
    4f28:	60 89       	ldd	r22, Z+16	; 0x10
    4f2a:	71 89       	ldd	r23, Z+17	; 0x11
    4f2c:	4f 5f       	subi	r20, 0xFF	; 255
    4f2e:	5f 4f       	sbci	r21, 0xFF	; 255
    4f30:	6f 4f       	sbci	r22, 0xFF	; 255
    4f32:	7f 4f       	sbci	r23, 0xFF	; 255
    4f34:	46 87       	std	Z+14, r20	; 0x0e
    4f36:	57 87       	std	Z+15, r21	; 0x0f
    4f38:	60 8b       	std	Z+16, r22	; 0x10
    4f3a:	71 8b       	std	Z+17, r23	; 0x11
		interface->rxbytes += packet->length;
    4f3c:	f6 01       	movw	r30, r12
    4f3e:	20 85       	ldd	r18, Z+8	; 0x08
    4f40:	31 85       	ldd	r19, Z+9	; 0x09
    4f42:	f7 01       	movw	r30, r14
    4f44:	82 a5       	ldd	r24, Z+42	; 0x2a
    4f46:	93 a5       	ldd	r25, Z+43	; 0x2b
    4f48:	a4 a5       	ldd	r26, Z+44	; 0x2c
    4f4a:	b5 a5       	ldd	r27, Z+45	; 0x2d
    4f4c:	82 0f       	add	r24, r18
    4f4e:	93 1f       	adc	r25, r19
    4f50:	a1 1d       	adc	r26, r1
    4f52:	b1 1d       	adc	r27, r1
    4f54:	82 a7       	std	Z+42, r24	; 0x2a
    4f56:	93 a7       	std	Z+43, r25	; 0x2b
    4f58:	a4 a7       	std	Z+44, r26	; 0x2c
    4f5a:	b5 a7       	std	Z+45, r27	; 0x2d
	}

}
    4f5c:	24 96       	adiw	r28, 0x04	; 4
    4f5e:	cd bf       	out	0x3d, r28	; 61
    4f60:	de bf       	out	0x3e, r29	; 62
    4f62:	df 91       	pop	r29
    4f64:	cf 91       	pop	r28
    4f66:	1f 91       	pop	r17
    4f68:	0f 91       	pop	r16
    4f6a:	ff 90       	pop	r15
    4f6c:	ef 90       	pop	r14
    4f6e:	df 90       	pop	r13
    4f70:	cf 90       	pop	r12
    4f72:	bf 90       	pop	r11
    4f74:	af 90       	pop	r10
    4f76:	08 95       	ret

00004f78 <csp_route_get_nexthop_mac>:

uint8_t csp_route_get_nexthop_mac(uint8_t node) {

	csp_route_t * route = csp_route_if(node);
    4f78:	25 de       	rcall	.-950    	; 0x4bc4 <csp_route_if>
	return route->nexthop_mac_addr;

}
    4f7a:	fc 01       	movw	r30, r24
    4f7c:	82 81       	ldd	r24, Z+2	; 0x02
    4f7e:	08 95       	ret

00004f80 <csp_cmp_handler>:
	return CSP_ERR_NONE;

}

/* CSP Management Protocol handler */
int csp_cmp_handler(csp_conn_t * conn, csp_packet_t * packet) {
    4f80:	0f 93       	push	r16
    4f82:	1f 93       	push	r17
    4f84:	cf 93       	push	r28
    4f86:	df 93       	push	r29
    4f88:	eb 01       	movw	r28, r22

	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
    4f8a:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f8c:	81 11       	cpse	r24, r1
    4f8e:	55 c1       	rjmp	.+682    	; 0x523a <csp_cmp_handler+0x2ba>
		return ret;

	switch (cmp->code) {
    4f90:	8f 85       	ldd	r24, Y+15	; 0x0f
    4f92:	83 30       	cpi	r24, 0x03	; 3
    4f94:	09 f4       	brne	.+2      	; 0x4f98 <csp_cmp_handler+0x18>
    4f96:	6d c0       	rjmp	.+218    	; 0x5072 <csp_cmp_handler+0xf2>
    4f98:	30 f4       	brcc	.+12     	; 0x4fa6 <csp_cmp_handler+0x26>
    4f9a:	81 30       	cpi	r24, 0x01	; 1
    4f9c:	69 f0       	breq	.+26     	; 0x4fb8 <csp_cmp_handler+0x38>
    4f9e:	82 30       	cpi	r24, 0x02	; 2
    4fa0:	09 f4       	brne	.+2      	; 0x4fa4 <csp_cmp_handler+0x24>
    4fa2:	4f c0       	rjmp	.+158    	; 0x5042 <csp_cmp_handler+0xc2>
    4fa4:	45 c1       	rjmp	.+650    	; 0x5230 <csp_cmp_handler+0x2b0>
    4fa6:	85 30       	cpi	r24, 0x05	; 5
    4fa8:	09 f4       	brne	.+2      	; 0x4fac <csp_cmp_handler+0x2c>
    4faa:	f1 c0       	rjmp	.+482    	; 0x518e <csp_cmp_handler+0x20e>
    4fac:	08 f4       	brcc	.+2      	; 0x4fb0 <csp_cmp_handler+0x30>
    4fae:	d8 c0       	rjmp	.+432    	; 0x5160 <csp_cmp_handler+0x1e0>
    4fb0:	86 30       	cpi	r24, 0x06	; 6
    4fb2:	09 f4       	brne	.+2      	; 0x4fb6 <csp_cmp_handler+0x36>
    4fb4:	06 c1       	rjmp	.+524    	; 0x51c2 <csp_cmp_handler+0x242>
    4fb6:	3c c1       	rjmp	.+632    	; 0x5230 <csp_cmp_handler+0x2b0>
#define CSP_RPS_MTU	196

static int do_cmp_ident(struct csp_cmp_message *cmp) {

	/* Copy revision */
	strncpy(cmp->ident.revision, GIT_REV, CSP_CMP_IDENT_REV_LEN);
    4fb8:	44 e1       	ldi	r20, 0x14	; 20
    4fba:	50 e0       	ldi	r21, 0x00	; 0
    4fbc:	64 e9       	ldi	r22, 0x94	; 148
    4fbe:	70 e2       	ldi	r23, 0x20	; 32
    4fc0:	ce 01       	movw	r24, r28
    4fc2:	8e 5b       	subi	r24, 0xBE	; 190
    4fc4:	9f 4f       	sbci	r25, 0xFF	; 255
    4fc6:	0e 94 85 41 	call	0x830a	; 0x830a <strncpy>
	cmp->ident.revision[CSP_CMP_IDENT_REV_LEN - 1] = '\0';
    4fca:	fe 01       	movw	r30, r28
    4fcc:	eb 5a       	subi	r30, 0xAB	; 171
    4fce:	ff 4f       	sbci	r31, 0xFF	; 255
    4fd0:	10 82       	st	Z, r1

	/* Copy compilation date */
	strncpy(cmp->ident.date, __DATE__, CSP_CMP_IDENT_DATE_LEN);
    4fd2:	8c e0       	ldi	r24, 0x0C	; 12
    4fd4:	ec e9       	ldi	r30, 0x9C	; 156
    4fd6:	f0 e2       	ldi	r31, 0x20	; 32
    4fd8:	de 01       	movw	r26, r28
    4fda:	aa 5a       	subi	r26, 0xAA	; 170
    4fdc:	bf 4f       	sbci	r27, 0xFF	; 255
    4fde:	01 90       	ld	r0, Z+
    4fe0:	0d 92       	st	X+, r0
    4fe2:	8a 95       	dec	r24
    4fe4:	e1 f7       	brne	.-8      	; 0x4fde <csp_cmp_handler+0x5e>
	cmp->ident.date[CSP_CMP_IDENT_DATE_LEN - 1] = '\0';
    4fe6:	fe 01       	movw	r30, r28
    4fe8:	ef 59       	subi	r30, 0x9F	; 159
    4fea:	ff 4f       	sbci	r31, 0xFF	; 255
    4fec:	10 82       	st	Z, r1

	/* Copy compilation time */
	strncpy(cmp->ident.time, __TIME__, CSP_CMP_IDENT_TIME_LEN);
    4fee:	89 e0       	ldi	r24, 0x09	; 9
    4ff0:	e8 ea       	ldi	r30, 0xA8	; 168
    4ff2:	f0 e2       	ldi	r31, 0x20	; 32
    4ff4:	de 01       	movw	r26, r28
    4ff6:	ae 59       	subi	r26, 0x9E	; 158
    4ff8:	bf 4f       	sbci	r27, 0xFF	; 255
    4ffa:	01 90       	ld	r0, Z+
    4ffc:	0d 92       	st	X+, r0
    4ffe:	8a 95       	dec	r24
    5000:	e1 f7       	brne	.-8      	; 0x4ffa <csp_cmp_handler+0x7a>
	cmp->ident.time[CSP_CMP_IDENT_TIME_LEN - 1] = '\0';
    5002:	fe 01       	movw	r30, r28
    5004:	e6 59       	subi	r30, 0x96	; 150
    5006:	ff 4f       	sbci	r31, 0xFF	; 255
    5008:	10 82       	st	Z, r1

	/* Copy hostname */
	strncpy(cmp->ident.hostname, csp_get_hostname(), CSP_HOSTNAME_LEN);
    500a:	66 da       	rcall	.-2868   	; 0x44d8 <csp_get_hostname>
    500c:	44 e1       	ldi	r20, 0x14	; 20
    500e:	50 e0       	ldi	r21, 0x00	; 0
    5010:	bc 01       	movw	r22, r24
    5012:	ce 01       	movw	r24, r28
    5014:	40 96       	adiw	r24, 0x10	; 16
    5016:	0e 94 85 41 	call	0x830a	; 0x830a <strncpy>
	cmp->ident.hostname[CSP_HOSTNAME_LEN - 1] = '\0';
    501a:	1b a2       	std	Y+35, r1	; 0x23

	/* Copy model name */
	strncpy(cmp->ident.model, csp_get_model(), CSP_MODEL_LEN);
    501c:	62 da       	rcall	.-2876   	; 0x44e2 <csp_get_model>
    501e:	4e e1       	ldi	r20, 0x1E	; 30
    5020:	50 e0       	ldi	r21, 0x00	; 0
    5022:	bc 01       	movw	r22, r24
    5024:	ce 01       	movw	r24, r28
    5026:	84 96       	adiw	r24, 0x24	; 36
    5028:	0e 94 85 41 	call	0x830a	; 0x830a <strncpy>
	cmp->ident.model[CSP_MODEL_LEN - 1] = '\0';
    502c:	fe 01       	movw	r30, r28
    502e:	ef 5b       	subi	r30, 0xBF	; 191
    5030:	ff 4f       	sbci	r31, 0xFF	; 255
    5032:	10 82       	st	Z, r1
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
			packet->length = CMP_SIZE(ident);
    5034:	8d e5       	ldi	r24, 0x5D	; 93
    5036:	90 e0       	ldi	r25, 0x00	; 0
    5038:	88 87       	std	Y+8, r24	; 0x08
    503a:	99 87       	std	Y+9, r25	; 0x09
	if (cmp->type != CSP_CMP_REQUEST)
		return ret;

	switch (cmp->code) {
		case CSP_CMP_IDENT:
			ret = do_cmp_ident(cmp);
    503c:	80 e0       	ldi	r24, 0x00	; 0
    503e:	90 e0       	ldi	r25, 0x00	; 0
			packet->length = CMP_SIZE(ident);
			break;
    5040:	f9 c0       	rjmp	.+498    	; 0x5234 <csp_cmp_handler+0x2b4>

}

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->route_set.interface);
    5042:	cb 01       	movw	r24, r22
    5044:	42 96       	adiw	r24, 0x12	; 18
    5046:	26 dd       	rcall	.-1460   	; 0x4a94 <csp_route_get_if_by_name>
	if (ifc == NULL)
    5048:	00 97       	sbiw	r24, 0x00	; 0
    504a:	49 f0       	breq	.+18     	; 0x505e <csp_cmp_handler+0xde>
		return CSP_ERR_INVAL;

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
    504c:	49 89       	ldd	r20, Y+17	; 0x11
    504e:	bc 01       	movw	r22, r24
    5050:	88 89       	ldd	r24, Y+16	; 0x10
    5052:	68 dd       	rcall	.-1328   	; 0x4b24 <csp_route_set>
    5054:	89 2b       	or	r24, r25
    5056:	31 f0       	breq	.+12     	; 0x5064 <csp_cmp_handler+0xe4>
		return CSP_ERR_INVAL;
    5058:	8e ef       	ldi	r24, 0xFE	; 254
    505a:	9f ef       	ldi	r25, 0xFF	; 255
    505c:	05 c0       	rjmp	.+10     	; 0x5068 <csp_cmp_handler+0xe8>

static int do_cmp_route_set(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->route_set.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    505e:	8e ef       	ldi	r24, 0xFE	; 254
    5060:	9f ef       	ldi	r25, 0xFF	; 255
    5062:	02 c0       	rjmp	.+4      	; 0x5068 <csp_cmp_handler+0xe8>

	if (csp_route_set(cmp->route_set.dest_node, ifc, cmp->route_set.next_hop_mac) != CSP_ERR_NONE)
		return CSP_ERR_INVAL;

	return CSP_ERR_NONE;
    5064:	80 e0       	ldi	r24, 0x00	; 0
    5066:	90 e0       	ldi	r25, 0x00	; 0
			packet->length = CMP_SIZE(ident);
			break;

		case CSP_CMP_ROUTE_SET:
			ret = do_cmp_route_set(cmp);
			packet->length = CMP_SIZE(route_set);
    5068:	2f e0       	ldi	r18, 0x0F	; 15
    506a:	30 e0       	ldi	r19, 0x00	; 0
    506c:	28 87       	std	Y+8, r18	; 0x08
    506e:	39 87       	std	Y+9, r19	; 0x09
			break;
    5070:	e1 c0       	rjmp	.+450    	; 0x5234 <csp_cmp_handler+0x2b4>

}

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->if_stats.interface);
    5072:	cb 01       	movw	r24, r22
    5074:	40 96       	adiw	r24, 0x10	; 16
    5076:	0e dd       	rcall	.-1508   	; 0x4a94 <csp_route_get_if_by_name>
    5078:	8c 01       	movw	r16, r24
	if (ifc == NULL)
    507a:	00 97       	sbiw	r24, 0x00	; 0
    507c:	09 f4       	brne	.+2      	; 0x5080 <csp_cmp_handler+0x100>
    507e:	69 c0       	rjmp	.+210    	; 0x5152 <csp_cmp_handler+0x1d2>
		return CSP_ERR_INVAL;

	cmp->if_stats.tx =       csp_hton32(ifc->tx);
    5080:	fc 01       	movw	r30, r24
    5082:	62 85       	ldd	r22, Z+10	; 0x0a
    5084:	73 85       	ldd	r23, Z+11	; 0x0b
    5086:	84 85       	ldd	r24, Z+12	; 0x0c
    5088:	95 85       	ldd	r25, Z+13	; 0x0d
    508a:	bc d9       	rcall	.-3208   	; 0x4404 <csp_hton32>
    508c:	6b 8f       	std	Y+27, r22	; 0x1b
    508e:	7c 8f       	std	Y+28, r23	; 0x1c
    5090:	8d 8f       	std	Y+29, r24	; 0x1d
    5092:	9e 8f       	std	Y+30, r25	; 0x1e
	cmp->if_stats.rx =       csp_hton32(ifc->rx);
    5094:	f8 01       	movw	r30, r16
    5096:	66 85       	ldd	r22, Z+14	; 0x0e
    5098:	77 85       	ldd	r23, Z+15	; 0x0f
    509a:	80 89       	ldd	r24, Z+16	; 0x10
    509c:	91 89       	ldd	r25, Z+17	; 0x11
    509e:	b2 d9       	rcall	.-3228   	; 0x4404 <csp_hton32>
    50a0:	6f 8f       	std	Y+31, r22	; 0x1f
    50a2:	78 a3       	std	Y+32, r23	; 0x20
    50a4:	89 a3       	std	Y+33, r24	; 0x21
    50a6:	9a a3       	std	Y+34, r25	; 0x22
	cmp->if_stats.tx_error = csp_hton32(ifc->tx_error);
    50a8:	f8 01       	movw	r30, r16
    50aa:	62 89       	ldd	r22, Z+18	; 0x12
    50ac:	73 89       	ldd	r23, Z+19	; 0x13
    50ae:	84 89       	ldd	r24, Z+20	; 0x14
    50b0:	95 89       	ldd	r25, Z+21	; 0x15
    50b2:	a8 d9       	rcall	.-3248   	; 0x4404 <csp_hton32>
    50b4:	6b a3       	std	Y+35, r22	; 0x23
    50b6:	7c a3       	std	Y+36, r23	; 0x24
    50b8:	8d a3       	std	Y+37, r24	; 0x25
    50ba:	9e a3       	std	Y+38, r25	; 0x26
	cmp->if_stats.rx_error = csp_hton32(ifc->rx_error);
    50bc:	f8 01       	movw	r30, r16
    50be:	66 89       	ldd	r22, Z+22	; 0x16
    50c0:	77 89       	ldd	r23, Z+23	; 0x17
    50c2:	80 8d       	ldd	r24, Z+24	; 0x18
    50c4:	91 8d       	ldd	r25, Z+25	; 0x19
    50c6:	9e d9       	rcall	.-3268   	; 0x4404 <csp_hton32>
    50c8:	6f a3       	std	Y+39, r22	; 0x27
    50ca:	78 a7       	std	Y+40, r23	; 0x28
    50cc:	89 a7       	std	Y+41, r24	; 0x29
    50ce:	9a a7       	std	Y+42, r25	; 0x2a
	cmp->if_stats.drop =     csp_hton32(ifc->drop);
    50d0:	f8 01       	movw	r30, r16
    50d2:	62 8d       	ldd	r22, Z+26	; 0x1a
    50d4:	73 8d       	ldd	r23, Z+27	; 0x1b
    50d6:	84 8d       	ldd	r24, Z+28	; 0x1c
    50d8:	95 8d       	ldd	r25, Z+29	; 0x1d
    50da:	94 d9       	rcall	.-3288   	; 0x4404 <csp_hton32>
    50dc:	6b a7       	std	Y+43, r22	; 0x2b
    50de:	7c a7       	std	Y+44, r23	; 0x2c
    50e0:	8d a7       	std	Y+45, r24	; 0x2d
    50e2:	9e a7       	std	Y+46, r25	; 0x2e
	cmp->if_stats.autherr =  csp_hton32(ifc->autherr);
    50e4:	f8 01       	movw	r30, r16
    50e6:	66 8d       	ldd	r22, Z+30	; 0x1e
    50e8:	77 8d       	ldd	r23, Z+31	; 0x1f
    50ea:	80 a1       	ldd	r24, Z+32	; 0x20
    50ec:	91 a1       	ldd	r25, Z+33	; 0x21
    50ee:	8a d9       	rcall	.-3308   	; 0x4404 <csp_hton32>
    50f0:	6f a7       	std	Y+47, r22	; 0x2f
    50f2:	78 ab       	std	Y+48, r23	; 0x30
    50f4:	89 ab       	std	Y+49, r24	; 0x31
    50f6:	9a ab       	std	Y+50, r25	; 0x32
	cmp->if_stats.frame =    csp_hton32(ifc->frame);
    50f8:	f8 01       	movw	r30, r16
    50fa:	62 a1       	ldd	r22, Z+34	; 0x22
    50fc:	73 a1       	ldd	r23, Z+35	; 0x23
    50fe:	84 a1       	ldd	r24, Z+36	; 0x24
    5100:	95 a1       	ldd	r25, Z+37	; 0x25
    5102:	80 d9       	rcall	.-3328   	; 0x4404 <csp_hton32>
    5104:	6b ab       	std	Y+51, r22	; 0x33
    5106:	7c ab       	std	Y+52, r23	; 0x34
    5108:	8d ab       	std	Y+53, r24	; 0x35
    510a:	9e ab       	std	Y+54, r25	; 0x36
	cmp->if_stats.txbytes =  csp_hton32(ifc->txbytes);
    510c:	f8 01       	movw	r30, r16
    510e:	66 a1       	ldd	r22, Z+38	; 0x26
    5110:	77 a1       	ldd	r23, Z+39	; 0x27
    5112:	80 a5       	ldd	r24, Z+40	; 0x28
    5114:	91 a5       	ldd	r25, Z+41	; 0x29
    5116:	76 d9       	rcall	.-3348   	; 0x4404 <csp_hton32>
    5118:	6f ab       	std	Y+55, r22	; 0x37
    511a:	78 af       	std	Y+56, r23	; 0x38
    511c:	89 af       	std	Y+57, r24	; 0x39
    511e:	9a af       	std	Y+58, r25	; 0x3a
	cmp->if_stats.rxbytes =  csp_hton32(ifc->rxbytes);
    5120:	f8 01       	movw	r30, r16
    5122:	62 a5       	ldd	r22, Z+42	; 0x2a
    5124:	73 a5       	ldd	r23, Z+43	; 0x2b
    5126:	84 a5       	ldd	r24, Z+44	; 0x2c
    5128:	95 a5       	ldd	r25, Z+45	; 0x2d
    512a:	6c d9       	rcall	.-3368   	; 0x4404 <csp_hton32>
    512c:	6b af       	std	Y+59, r22	; 0x3b
    512e:	7c af       	std	Y+60, r23	; 0x3c
    5130:	8d af       	std	Y+61, r24	; 0x3d
    5132:	9e af       	std	Y+62, r25	; 0x3e
	cmp->if_stats.irq = 	 csp_hton32(ifc->irq);
    5134:	f8 01       	movw	r30, r16
    5136:	66 a5       	ldd	r22, Z+46	; 0x2e
    5138:	77 a5       	ldd	r23, Z+47	; 0x2f
    513a:	80 a9       	ldd	r24, Z+48	; 0x30
    513c:	91 a9       	ldd	r25, Z+49	; 0x31
    513e:	62 d9       	rcall	.-3388   	; 0x4404 <csp_hton32>
    5140:	fe 01       	movw	r30, r28
    5142:	ff 96       	adiw	r30, 0x3f	; 63
    5144:	60 83       	st	Z, r22
    5146:	71 83       	std	Z+1, r23	; 0x01
    5148:	82 83       	std	Z+2, r24	; 0x02
    514a:	93 83       	std	Z+3, r25	; 0x03

	return CSP_ERR_NONE;
    514c:	80 e0       	ldi	r24, 0x00	; 0
    514e:	90 e0       	ldi	r25, 0x00	; 0
    5150:	02 c0       	rjmp	.+4      	; 0x5156 <csp_cmp_handler+0x1d6>

static int do_cmp_if_stats(struct csp_cmp_message *cmp) {

	csp_iface_t *ifc = csp_route_get_if_by_name(cmp->if_stats.interface);
	if (ifc == NULL)
		return CSP_ERR_INVAL;
    5152:	8e ef       	ldi	r24, 0xFE	; 254
    5154:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(route_set);
			break;

		case CSP_CMP_IF_STATS:
			ret = do_cmp_if_stats(cmp);
			packet->length = CMP_SIZE(if_stats);
    5156:	25 e3       	ldi	r18, 0x35	; 53
    5158:	30 e0       	ldi	r19, 0x00	; 0
    515a:	28 87       	std	Y+8, r18	; 0x08
    515c:	39 87       	std	Y+9, r19	; 0x09
			break;
    515e:	6a c0       	rjmp	.+212    	; 0x5234 <csp_cmp_handler+0x2b4>
	return CSP_ERR_NONE;
}

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
    5160:	68 89       	ldd	r22, Y+16	; 0x10
    5162:	79 89       	ldd	r23, Y+17	; 0x11
    5164:	8a 89       	ldd	r24, Y+18	; 0x12
    5166:	9b 89       	ldd	r25, Y+19	; 0x13
    5168:	4d d9       	rcall	.-3430   	; 0x4404 <csp_hton32>
    516a:	68 8b       	std	Y+16, r22	; 0x10
    516c:	79 8b       	std	Y+17, r23	; 0x11
    516e:	8a 8b       	std	Y+18, r24	; 0x12
    5170:	9b 8b       	std	Y+19, r25	; 0x13
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
    5172:	4c 89       	ldd	r20, Y+20	; 0x14
    5174:	49 3c       	cpi	r20, 0xC9	; 201
    5176:	40 f4       	brcc	.+16     	; 0x5188 <csp_cmp_handler+0x208>
		return CSP_ERR_INVAL;

	/* Dangerous, you better know what you are doing */
	memcpy(cmp->peek.data, (void *) (uintptr_t) cmp->peek.addr, cmp->peek.len);
    5178:	50 e0       	ldi	r21, 0x00	; 0
    517a:	ce 01       	movw	r24, r28
    517c:	45 96       	adiw	r24, 0x15	; 21
    517e:	0e 94 60 41 	call	0x82c0	; 0x82c0 <memcpy>

	return CSP_ERR_NONE;
    5182:	80 e0       	ldi	r24, 0x00	; 0
    5184:	90 e0       	ldi	r25, 0x00	; 0
    5186:	56 c0       	rjmp	.+172    	; 0x5234 <csp_cmp_handler+0x2b4>

static int do_cmp_peek(struct csp_cmp_message *cmp) {

	cmp->peek.addr = csp_hton32(cmp->peek.addr);
	if (cmp->peek.len > CSP_CMP_PEEK_MAX_LEN)
		return CSP_ERR_INVAL;
    5188:	8e ef       	ldi	r24, 0xFE	; 254
    518a:	9f ef       	ldi	r25, 0xFF	; 255
			packet->length = CMP_SIZE(if_stats);
			break;

		case CSP_CMP_PEEK:
			ret = do_cmp_peek(cmp);
			break;
    518c:	53 c0       	rjmp	.+166    	; 0x5234 <csp_cmp_handler+0x2b4>

}

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
    518e:	68 89       	ldd	r22, Y+16	; 0x10
    5190:	79 89       	ldd	r23, Y+17	; 0x11
    5192:	8a 89       	ldd	r24, Y+18	; 0x12
    5194:	9b 89       	ldd	r25, Y+19	; 0x13
    5196:	36 d9       	rcall	.-3476   	; 0x4404 <csp_hton32>
    5198:	dc 01       	movw	r26, r24
    519a:	cb 01       	movw	r24, r22
    519c:	88 8b       	std	Y+16, r24	; 0x10
    519e:	99 8b       	std	Y+17, r25	; 0x11
    51a0:	aa 8b       	std	Y+18, r26	; 0x12
    51a2:	bb 8b       	std	Y+19, r27	; 0x13
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
    51a4:	4c 89       	ldd	r20, Y+20	; 0x14
    51a6:	49 3c       	cpi	r20, 0xC9	; 201
    51a8:	48 f4       	brcc	.+18     	; 0x51bc <csp_cmp_handler+0x23c>
		return CSP_ERR_INVAL;

	/* Extremely dangerous, you better know what you are doing */
	memcpy((void *) (uintptr_t) cmp->poke.addr, cmp->poke.data, cmp->poke.len);
    51aa:	50 e0       	ldi	r21, 0x00	; 0
    51ac:	be 01       	movw	r22, r28
    51ae:	6b 5e       	subi	r22, 0xEB	; 235
    51b0:	7f 4f       	sbci	r23, 0xFF	; 255
    51b2:	0e 94 60 41 	call	0x82c0	; 0x82c0 <memcpy>

	return CSP_ERR_NONE;
    51b6:	80 e0       	ldi	r24, 0x00	; 0
    51b8:	90 e0       	ldi	r25, 0x00	; 0
    51ba:	3c c0       	rjmp	.+120    	; 0x5234 <csp_cmp_handler+0x2b4>

static int do_cmp_poke(struct csp_cmp_message *cmp) {

	cmp->poke.addr = csp_hton32(cmp->poke.addr);
	if (cmp->poke.len > CSP_CMP_POKE_MAX_LEN)
		return CSP_ERR_INVAL;
    51bc:	8e ef       	ldi	r24, 0xFE	; 254
    51be:	9f ef       	ldi	r25, 0xFF	; 255
			ret = do_cmp_peek(cmp);
			break;

		case CSP_CMP_POKE:
			ret = do_cmp_poke(cmp);
			break;
    51c0:	39 c0       	rjmp	.+114    	; 0x5234 <csp_cmp_handler+0x2b4>

}

static int do_cmp_clock(struct csp_cmp_message *cmp) {

	cmp->clock.tv_sec = csp_ntoh32(cmp->clock.tv_sec);
    51c2:	68 89       	ldd	r22, Y+16	; 0x10
    51c4:	79 89       	ldd	r23, Y+17	; 0x11
    51c6:	8a 89       	ldd	r24, Y+18	; 0x12
    51c8:	9b 89       	ldd	r25, Y+19	; 0x13
    51ca:	51 d9       	rcall	.-3422   	; 0x446e <csp_ntoh32>
    51cc:	68 8b       	std	Y+16, r22	; 0x10
    51ce:	79 8b       	std	Y+17, r23	; 0x11
    51d0:	8a 8b       	std	Y+18, r24	; 0x12
    51d2:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_ntoh32(cmp->clock.tv_nsec);
    51d4:	6c 89       	ldd	r22, Y+20	; 0x14
    51d6:	7d 89       	ldd	r23, Y+21	; 0x15
    51d8:	8e 89       	ldd	r24, Y+22	; 0x16
    51da:	9f 89       	ldd	r25, Y+23	; 0x17
    51dc:	48 d9       	rcall	.-3440   	; 0x446e <csp_ntoh32>
    51de:	6c 8b       	std	Y+20, r22	; 0x14
    51e0:	7d 8b       	std	Y+21, r23	; 0x15
    51e2:	8e 8b       	std	Y+22, r24	; 0x16
    51e4:	9f 8b       	std	Y+23, r25	; 0x17

	if (cmp->clock.tv_sec != 0) {
    51e6:	88 89       	ldd	r24, Y+16	; 0x10
    51e8:	99 89       	ldd	r25, Y+17	; 0x11
    51ea:	aa 89       	ldd	r26, Y+18	; 0x12
    51ec:	bb 89       	ldd	r27, Y+19	; 0x13
    51ee:	89 2b       	or	r24, r25
    51f0:	8a 2b       	or	r24, r26
    51f2:	8b 2b       	or	r24, r27
    51f4:	21 f0       	breq	.+8      	; 0x51fe <csp_cmp_handler+0x27e>
		clock_set_time(&cmp->clock);
    51f6:	ce 01       	movw	r24, r28
    51f8:	40 96       	adiw	r24, 0x10	; 16
    51fa:	0e 94 34 0b 	call	0x1668	; 0x1668 <clock_set_time>
	}

	clock_get_time(&cmp->clock);
    51fe:	ce 01       	movw	r24, r28
    5200:	40 96       	adiw	r24, 0x10	; 16
    5202:	0e 94 33 0b 	call	0x1666	; 0x1666 <clock_get_time>
	cmp->clock.tv_sec = csp_hton32(cmp->clock.tv_sec);
    5206:	68 89       	ldd	r22, Y+16	; 0x10
    5208:	79 89       	ldd	r23, Y+17	; 0x11
    520a:	8a 89       	ldd	r24, Y+18	; 0x12
    520c:	9b 89       	ldd	r25, Y+19	; 0x13
    520e:	fa d8       	rcall	.-3596   	; 0x4404 <csp_hton32>
    5210:	68 8b       	std	Y+16, r22	; 0x10
    5212:	79 8b       	std	Y+17, r23	; 0x11
    5214:	8a 8b       	std	Y+18, r24	; 0x12
    5216:	9b 8b       	std	Y+19, r25	; 0x13
	cmp->clock.tv_nsec = csp_hton32(cmp->clock.tv_nsec);
    5218:	6c 89       	ldd	r22, Y+20	; 0x14
    521a:	7d 89       	ldd	r23, Y+21	; 0x15
    521c:	8e 89       	ldd	r24, Y+22	; 0x16
    521e:	9f 89       	ldd	r25, Y+23	; 0x17
    5220:	f1 d8       	rcall	.-3614   	; 0x4404 <csp_hton32>
    5222:	6c 8b       	std	Y+20, r22	; 0x14
    5224:	7d 8b       	std	Y+21, r23	; 0x15
    5226:	8e 8b       	std	Y+22, r24	; 0x16
    5228:	9f 8b       	std	Y+23, r25	; 0x17
		case CSP_CMP_POKE:
			ret = do_cmp_poke(cmp);
			break;

		case CSP_CMP_CLOCK:
			ret = do_cmp_clock(cmp);
    522a:	80 e0       	ldi	r24, 0x00	; 0
    522c:	90 e0       	ldi	r25, 0x00	; 0
			break;
    522e:	02 c0       	rjmp	.+4      	; 0x5234 <csp_cmp_handler+0x2b4>

		default:
			ret = CSP_ERR_INVAL;
    5230:	8e ef       	ldi	r24, 0xFE	; 254
    5232:	9f ef       	ldi	r25, 0xFF	; 255
			break;
	}

	cmp->type = CSP_CMP_REPLY;
    5234:	2f ef       	ldi	r18, 0xFF	; 255
    5236:	2e 87       	std	Y+14, r18	; 0x0e

	return ret;
    5238:	02 c0       	rjmp	.+4      	; 0x523e <csp_cmp_handler+0x2be>
	int ret = CSP_ERR_INVAL;
	struct csp_cmp_message * cmp = (struct csp_cmp_message *) packet->data;

	/* Ignore everything but requests */
	if (cmp->type != CSP_CMP_REQUEST)
		return ret;
    523a:	8e ef       	ldi	r24, 0xFE	; 254
    523c:	9f ef       	ldi	r25, 0xFF	; 255
	}

	cmp->type = CSP_CMP_REPLY;

	return ret;
}
    523e:	df 91       	pop	r29
    5240:	cf 91       	pop	r28
    5242:	1f 91       	pop	r17
    5244:	0f 91       	pop	r16
    5246:	08 95       	ret

00005248 <csp_service_handler>:

void csp_service_handler(csp_conn_t * conn, csp_packet_t * packet) {
    5248:	af 92       	push	r10
    524a:	bf 92       	push	r11
    524c:	cf 92       	push	r12
    524e:	df 92       	push	r13
    5250:	ef 92       	push	r14
    5252:	ff 92       	push	r15
    5254:	0f 93       	push	r16
    5256:	1f 93       	push	r17
    5258:	cf 93       	push	r28
    525a:	df 93       	push	r29
    525c:	8c 01       	movw	r16, r24
    525e:	eb 01       	movw	r28, r22

	switch (csp_conn_dport(conn)) {
    5260:	08 d8       	rcall	.-4080   	; 0x4272 <csp_conn_dport>
    5262:	87 30       	cpi	r24, 0x07	; 7
    5264:	91 05       	cpc	r25, r1
    5266:	08 f0       	brcs	.+2      	; 0x526a <csp_service_handler+0x22>
    5268:	90 c0       	rjmp	.+288    	; 0x538a <csp_service_handler+0x142>
    526a:	fc 01       	movw	r30, r24
    526c:	e0 5f       	subi	r30, 0xF0	; 240
    526e:	fe 4f       	sbci	r31, 0xFE	; 254
    5270:	0c 94 e0 3f 	jmp	0x7fc0	; 0x7fc0 <__tablejump2__>

	case CSP_CMP:
		/* Pass to CMP handler */
		if (csp_cmp_handler(conn, packet) != CSP_ERR_NONE) {
    5274:	be 01       	movw	r22, r28
    5276:	c8 01       	movw	r24, r16
    5278:	83 de       	rcall	.-762    	; 0x4f80 <csp_cmp_handler>
    527a:	89 2b       	or	r24, r25
    527c:	09 f4       	brne	.+2      	; 0x5280 <csp_service_handler+0x38>
    527e:	89 c0       	rjmp	.+274    	; 0x5392 <csp_service_handler+0x14a>
			csp_buffer_free(packet);
    5280:	ce 01       	movw	r24, r28
    5282:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <csp_buffer_free>
			return;
    5286:	92 c0       	rjmp	.+292    	; 0x53ac <csp_service_handler+0x164>
		break;

	case CSP_PS: {

		/* Start by allocating just the right amount of memory */
		int task_list_size = csp_sys_tasklist_size();
    5288:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <csp_sys_tasklist_size>
    528c:	7c 01       	movw	r14, r24
		char * pslist = csp_malloc(task_list_size);
    528e:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <csp_malloc>
    5292:	5c 01       	movw	r10, r24

		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
    5294:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <csp_sys_tasklist>
		int pslen = strnlen(pslist, task_list_size);
    5298:	b7 01       	movw	r22, r14
    529a:	c5 01       	movw	r24, r10
    529c:	0e 94 94 41 	call	0x8328	; 0x8328 <strnlen>
    52a0:	6c 01       	movw	r12, r24

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    52a2:	18 16       	cp	r1, r24
    52a4:	19 06       	cpc	r1, r25
    52a6:	0c f0       	brlt	.+2      	; 0x52aa <csp_service_handler+0x62>
    52a8:	74 c0       	rjmp	.+232    	; 0x5392 <csp_service_handler+0x14a>
		/* Retrieve the tasklist */
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
    52aa:	e1 2c       	mov	r14, r1
    52ac:	f1 2c       	mov	r15, r1
		while(i < pslen) {

			/* Allocate packet buffer, if need be */
			if (packet == NULL)
    52ae:	20 97       	sbiw	r28, 0x00	; 0
    52b0:	41 f4       	brne	.+16     	; 0x52c2 <csp_service_handler+0x7a>
				packet = csp_buffer_get(CSP_RPS_MTU);
    52b2:	84 ec       	ldi	r24, 0xC4	; 196
    52b4:	90 e0       	ldi	r25, 0x00	; 0
    52b6:	0e 94 07 1f 	call	0x3e0e	; 0x3e0e <csp_buffer_get>
    52ba:	ec 01       	movw	r28, r24
			if (packet == NULL)
    52bc:	00 97       	sbiw	r24, 0x00	; 0
    52be:	09 f4       	brne	.+2      	; 0x52c2 <csp_service_handler+0x7a>
    52c0:	75 c0       	rjmp	.+234    	; 0x53ac <csp_service_handler+0x164>
				break;

			/* Calculate length, either full MTU or the remainder */
			packet->length = (pslen - i > CSP_RPS_MTU) ? CSP_RPS_MTU : (pslen - i);
    52c2:	a6 01       	movw	r20, r12
    52c4:	4e 19       	sub	r20, r14
    52c6:	5f 09       	sbc	r21, r15
    52c8:	45 3c       	cpi	r20, 0xC5	; 197
    52ca:	51 05       	cpc	r21, r1
    52cc:	14 f0       	brlt	.+4      	; 0x52d2 <csp_service_handler+0x8a>
    52ce:	44 ec       	ldi	r20, 0xC4	; 196
    52d0:	50 e0       	ldi	r21, 0x00	; 0
    52d2:	48 87       	std	Y+8, r20	; 0x08
    52d4:	59 87       	std	Y+9, r21	; 0x09

			/* Send out the data */
			memcpy(packet->data, &pslist[i], packet->length);
    52d6:	b5 01       	movw	r22, r10
    52d8:	6e 0d       	add	r22, r14
    52da:	7f 1d       	adc	r23, r15
    52dc:	ce 01       	movw	r24, r28
    52de:	0e 96       	adiw	r24, 0x0e	; 14
    52e0:	0e 94 60 41 	call	0x82c0	; 0x82c0 <memcpy>
			i += packet->length;
    52e4:	88 85       	ldd	r24, Y+8	; 0x08
    52e6:	99 85       	ldd	r25, Y+9	; 0x09
    52e8:	e8 0e       	add	r14, r24
    52ea:	f9 1e       	adc	r15, r25
			if (!csp_send(conn, packet, 0))
    52ec:	20 e0       	ldi	r18, 0x00	; 0
    52ee:	30 e0       	ldi	r19, 0x00	; 0
    52f0:	a9 01       	movw	r20, r18
    52f2:	be 01       	movw	r22, r28
    52f4:	c8 01       	movw	r24, r16
    52f6:	47 da       	rcall	.-2930   	; 0x4786 <csp_send>
    52f8:	89 2b       	or	r24, r25
    52fa:	19 f4       	brne	.+6      	; 0x5302 <csp_service_handler+0xba>
				csp_buffer_free(packet);
    52fc:	ce 01       	movw	r24, r28
    52fe:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <csp_buffer_free>
		csp_sys_tasklist(pslist);
		int pslen = strnlen(pslist, task_list_size);

		/* Split the potentially very long string into packets */
		int i = 0;
		while(i < pslen) {
    5302:	ec 14       	cp	r14, r12
    5304:	fd 04       	cpc	r15, r13
    5306:	0c f0       	brlt	.+2      	; 0x530a <csp_service_handler+0xc2>
    5308:	51 c0       	rjmp	.+162    	; 0x53ac <csp_service_handler+0x164>
    530a:	c0 e0       	ldi	r28, 0x00	; 0
    530c:	d0 e0       	ldi	r29, 0x00	; 0
    530e:	cf cf       	rjmp	.-98     	; 0x52ae <csp_service_handler+0x66>
		}
		break;
	}

	case CSP_MEMFREE: {
		uint32_t total = csp_sys_memfree();
    5310:	0e 94 d8 1d 	call	0x3bb0	; 0x3bb0 <csp_sys_memfree>

		total = csp_hton32(total);
    5314:	77 d8       	rcall	.-3858   	; 0x4404 <csp_hton32>
		memcpy(packet->data, &total, sizeof(total));
    5316:	6e 87       	std	Y+14, r22	; 0x0e
    5318:	7f 87       	std	Y+15, r23	; 0x0f
    531a:	88 8b       	std	Y+16, r24	; 0x10
    531c:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(total);
    531e:	84 e0       	ldi	r24, 0x04	; 4
    5320:	90 e0       	ldi	r25, 0x00	; 0
    5322:	88 87       	std	Y+8, r24	; 0x08
    5324:	99 87       	std	Y+9, r25	; 0x09
    5326:	35 c0       	rjmp	.+106    	; 0x5392 <csp_service_handler+0x14a>

	case CSP_REBOOT: {
		uint32_t magic_word;
		memcpy(&magic_word, packet->data, sizeof(magic_word));

		magic_word = csp_ntoh32(magic_word);
    5328:	6e 85       	ldd	r22, Y+14	; 0x0e
    532a:	7f 85       	ldd	r23, Y+15	; 0x0f
    532c:	88 89       	ldd	r24, Y+16	; 0x10
    532e:	99 89       	ldd	r25, Y+17	; 0x11
    5330:	9e d8       	rcall	.-3780   	; 0x446e <csp_ntoh32>

		/* If the magic word is invalid, return */
		if (magic_word != 0x80078007) {
    5332:	67 30       	cpi	r22, 0x07	; 7
    5334:	70 48       	sbci	r23, 0x80	; 128
    5336:	87 40       	sbci	r24, 0x07	; 7
    5338:	90 48       	sbci	r25, 0x80	; 128
    533a:	21 f0       	breq	.+8      	; 0x5344 <csp_service_handler+0xfc>
			csp_buffer_free(packet);
    533c:	ce 01       	movw	r24, r28
    533e:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <csp_buffer_free>
			return;
    5342:	34 c0       	rjmp	.+104    	; 0x53ac <csp_service_handler+0x164>
		}

		/* Otherwise Reboot */
		csp_sys_reboot();
    5344:	0e 94 2f 1e 	call	0x3c5e	; 0x3c5e <csp_sys_reboot>
		
		csp_buffer_free(packet);
    5348:	ce 01       	movw	r24, r28
    534a:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <csp_buffer_free>
		return;
    534e:	2e c0       	rjmp	.+92     	; 0x53ac <csp_service_handler+0x164>
	}

	case CSP_BUF_FREE: {
		uint32_t size = csp_buffer_remaining();
    5350:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <csp_buffer_remaining>
    5354:	bc 01       	movw	r22, r24
    5356:	88 27       	eor	r24, r24
    5358:	77 fd       	sbrc	r23, 7
    535a:	80 95       	com	r24
    535c:	98 2f       	mov	r25, r24
		size = csp_hton32(size);
    535e:	52 d8       	rcall	.-3932   	; 0x4404 <csp_hton32>
		memcpy(packet->data, &size, sizeof(size));
    5360:	6e 87       	std	Y+14, r22	; 0x0e
    5362:	7f 87       	std	Y+15, r23	; 0x0f
    5364:	88 8b       	std	Y+16, r24	; 0x10
    5366:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(size);
    5368:	84 e0       	ldi	r24, 0x04	; 4
    536a:	90 e0       	ldi	r25, 0x00	; 0
    536c:	88 87       	std	Y+8, r24	; 0x08
    536e:	99 87       	std	Y+9, r25	; 0x09
    5370:	10 c0       	rjmp	.+32     	; 0x5392 <csp_service_handler+0x14a>
		break;
	}

	case CSP_UPTIME: {
		uint32_t time = csp_get_s();
    5372:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <csp_get_s>
		time = csp_hton32(time);
    5376:	46 d8       	rcall	.-3956   	; 0x4404 <csp_hton32>
		memcpy(packet->data, &time, sizeof(time));
    5378:	6e 87       	std	Y+14, r22	; 0x0e
    537a:	7f 87       	std	Y+15, r23	; 0x0f
    537c:	88 8b       	std	Y+16, r24	; 0x10
    537e:	99 8b       	std	Y+17, r25	; 0x11
		packet->length = sizeof(time);
    5380:	84 e0       	ldi	r24, 0x04	; 4
    5382:	90 e0       	ldi	r25, 0x00	; 0
    5384:	88 87       	std	Y+8, r24	; 0x08
    5386:	99 87       	std	Y+9, r25	; 0x09
    5388:	04 c0       	rjmp	.+8      	; 0x5392 <csp_service_handler+0x14a>
		break;
	}

	default:
		csp_buffer_free(packet);
    538a:	ce 01       	movw	r24, r28
    538c:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <csp_buffer_free>
		return;
    5390:	0d c0       	rjmp	.+26     	; 0x53ac <csp_service_handler+0x164>
	}

	if (packet != NULL) {
    5392:	20 97       	sbiw	r28, 0x00	; 0
    5394:	59 f0       	breq	.+22     	; 0x53ac <csp_service_handler+0x164>
		if (!csp_send(conn, packet, 0))
    5396:	20 e0       	ldi	r18, 0x00	; 0
    5398:	30 e0       	ldi	r19, 0x00	; 0
    539a:	a9 01       	movw	r20, r18
    539c:	be 01       	movw	r22, r28
    539e:	c8 01       	movw	r24, r16
    53a0:	f2 d9       	rcall	.-3100   	; 0x4786 <csp_send>
    53a2:	89 2b       	or	r24, r25
    53a4:	19 f4       	brne	.+6      	; 0x53ac <csp_service_handler+0x164>
			csp_buffer_free(packet);
    53a6:	ce 01       	movw	r24, r28
    53a8:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <csp_buffer_free>
	}

}
    53ac:	df 91       	pop	r29
    53ae:	cf 91       	pop	r28
    53b0:	1f 91       	pop	r17
    53b2:	0f 91       	pop	r16
    53b4:	ff 90       	pop	r15
    53b6:	ef 90       	pop	r14
    53b8:	df 90       	pop	r13
    53ba:	cf 90       	pop	r12
    53bc:	bf 90       	pop	r11
    53be:	af 90       	pop	r10
    53c0:	08 95       	ret

000053c2 <csp_i2c_tx>:
#include <csp/csp_interface.h>
#include <csp/csp_error.h>
#include <csp/interfaces/csp_if_i2c.h>
#include <csp/drivers/i2c.h>

int csp_i2c_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    53c2:	cf 92       	push	r12
    53c4:	df 92       	push	r13
    53c6:	ef 92       	push	r14
    53c8:	ff 92       	push	r15
    53ca:	cf 93       	push	r28
    53cc:	df 93       	push	r29
    53ce:	eb 01       	movw	r28, r22
    53d0:	69 01       	movw	r12, r18
    53d2:	7a 01       	movw	r14, r20

	/* Cast the CSP packet buffer into an i2c frame */
	i2c_frame_t * frame = (i2c_frame_t *) packet;

	/* Insert destination node into the i2c destination field */
	if (csp_route_get_nexthop_mac(packet->id.dst) == CSP_NODE_MAC) {
    53d4:	9c 85       	ldd	r25, Y+12	; 0x0c
    53d6:	92 95       	swap	r25
    53d8:	9f 70       	andi	r25, 0x0F	; 15
    53da:	8d 85       	ldd	r24, Y+13	; 0x0d
    53dc:	81 70       	andi	r24, 0x01	; 1
    53de:	82 95       	swap	r24
    53e0:	80 7f       	andi	r24, 0xF0	; 240
    53e2:	89 2b       	or	r24, r25
    53e4:	c9 dd       	rcall	.-1134   	; 0x4f78 <csp_route_get_nexthop_mac>
    53e6:	8f 3f       	cpi	r24, 0xFF	; 255
    53e8:	51 f4       	brne	.+20     	; 0x53fe <csp_i2c_tx+0x3c>
		frame->dest = packet->id.dst;
    53ea:	9c 85       	ldd	r25, Y+12	; 0x0c
    53ec:	92 95       	swap	r25
    53ee:	9f 70       	andi	r25, 0x0F	; 15
    53f0:	8d 85       	ldd	r24, Y+13	; 0x0d
    53f2:	81 70       	andi	r24, 0x01	; 1
    53f4:	82 95       	swap	r24
    53f6:	80 7f       	andi	r24, 0xF0	; 240
    53f8:	89 2b       	or	r24, r25
    53fa:	8e 83       	std	Y+6, r24	; 0x06
    53fc:	0a c0       	rjmp	.+20     	; 0x5412 <csp_i2c_tx+0x50>
	} else {
		frame->dest = csp_route_get_nexthop_mac(packet->id.dst);
    53fe:	9c 85       	ldd	r25, Y+12	; 0x0c
    5400:	92 95       	swap	r25
    5402:	9f 70       	andi	r25, 0x0F	; 15
    5404:	8d 85       	ldd	r24, Y+13	; 0x0d
    5406:	81 70       	andi	r24, 0x01	; 1
    5408:	82 95       	swap	r24
    540a:	80 7f       	andi	r24, 0xF0	; 240
    540c:	89 2b       	or	r24, r25
    540e:	b4 dd       	rcall	.-1176   	; 0x4f78 <csp_route_get_nexthop_mac>
    5410:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* Save the outgoing id in the buffer */
	packet->id.ext = csp_hton32(packet->id.ext);
    5412:	6a 85       	ldd	r22, Y+10	; 0x0a
    5414:	7b 85       	ldd	r23, Y+11	; 0x0b
    5416:	8c 85       	ldd	r24, Y+12	; 0x0c
    5418:	9d 85       	ldd	r25, Y+13	; 0x0d
    541a:	0e 94 02 22 	call	0x4404	; 0x4404 <csp_hton32>
    541e:	6a 87       	std	Y+10, r22	; 0x0a
    5420:	7b 87       	std	Y+11, r23	; 0x0b
    5422:	8c 87       	std	Y+12, r24	; 0x0c
    5424:	9d 87       	std	Y+13, r25	; 0x0d

	/* Add the CSP header to the I2C length field */
	frame->len += sizeof(packet->id);
    5426:	88 85       	ldd	r24, Y+8	; 0x08
    5428:	99 85       	ldd	r25, Y+9	; 0x09
    542a:	04 96       	adiw	r24, 0x04	; 4
    542c:	88 87       	std	Y+8, r24	; 0x08
    542e:	99 87       	std	Y+9, r25	; 0x09
	frame->len_rx = 0;
    5430:	1f 82       	std	Y+7, r1	; 0x07

	/* Some I2C drivers support X number of retries
	 * CSP don't care about this. If it doesn't work the first
	 * time, don'y use time on it.
	 */
	frame->retries = 0;
    5432:	19 82       	std	Y+1, r1	; 0x01

	/* enqueue the frame */
	if (i2c_send(0, frame, timeout) != E_NO_ERR)
    5434:	a6 01       	movw	r20, r12
    5436:	be 01       	movw	r22, r28
    5438:	80 e0       	ldi	r24, 0x00	; 0
    543a:	90 e0       	ldi	r25, 0x00	; 0
    543c:	0e 94 21 0b 	call	0x1642	; 0x1642 <i2c_send>
    5440:	01 96       	adiw	r24, 0x01	; 1
    5442:	19 f0       	breq	.+6      	; 0x544a <csp_i2c_tx+0x88>
		return CSP_ERR_DRIVER;
    5444:	85 ef       	ldi	r24, 0xF5	; 245
    5446:	9f ef       	ldi	r25, 0xFF	; 255
    5448:	02 c0       	rjmp	.+4      	; 0x544e <csp_i2c_tx+0x8c>

	return CSP_ERR_NONE;
    544a:	80 e0       	ldi	r24, 0x00	; 0
    544c:	90 e0       	ldi	r25, 0x00	; 0

}
    544e:	df 91       	pop	r29
    5450:	cf 91       	pop	r28
    5452:	ff 90       	pop	r15
    5454:	ef 90       	pop	r14
    5456:	df 90       	pop	r13
    5458:	cf 90       	pop	r12
    545a:	08 95       	ret

0000545c <csp_i2c_rx>:
 * When a frame is received, cast it to a csp_packet
 * and send it directly to the CSP new packet function.
 * Context: ISR only
 * @param frame
 */
void csp_i2c_rx(i2c_frame_t * frame, void * pxTaskWoken) {
    545c:	0f 93       	push	r16
    545e:	1f 93       	push	r17
    5460:	cf 93       	push	r28
    5462:	df 93       	push	r29
    5464:	ec 01       	movw	r28, r24
    5466:	8b 01       	movw	r16, r22

	static csp_packet_t * packet;

	/* Validate input */
	if (frame == NULL)
    5468:	00 97       	sbiw	r24, 0x00	; 0
    546a:	79 f1       	breq	.+94     	; 0x54ca <csp_i2c_rx+0x6e>
		return;

	if ((frame->len < 4) || (frame->len > I2C_MTU)) {
    546c:	88 85       	ldd	r24, Y+8	; 0x08
    546e:	99 85       	ldd	r25, Y+9	; 0x09
    5470:	04 97       	sbiw	r24, 0x04	; 4
    5472:	8c 3f       	cpi	r24, 0xFC	; 252
    5474:	91 05       	cpc	r25, r1
    5476:	88 f0       	brcs	.+34     	; 0x549a <csp_i2c_rx+0x3e>
		csp_if_i2c.frame++;
    5478:	e8 e2       	ldi	r30, 0x28	; 40
    547a:	f0 e2       	ldi	r31, 0x20	; 32
    547c:	80 81       	ld	r24, Z
    547e:	91 81       	ldd	r25, Z+1	; 0x01
    5480:	a2 81       	ldd	r26, Z+2	; 0x02
    5482:	b3 81       	ldd	r27, Z+3	; 0x03
    5484:	01 96       	adiw	r24, 0x01	; 1
    5486:	a1 1d       	adc	r26, r1
    5488:	b1 1d       	adc	r27, r1
    548a:	80 83       	st	Z, r24
    548c:	91 83       	std	Z+1, r25	; 0x01
    548e:	a2 83       	std	Z+2, r26	; 0x02
    5490:	b3 83       	std	Z+3, r27	; 0x03
		csp_buffer_free_isr(frame);
    5492:	ce 01       	movw	r24, r28
    5494:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <csp_buffer_free_isr>
		return;
    5498:	18 c0       	rjmp	.+48     	; 0x54ca <csp_i2c_rx+0x6e>
	}

	/* Strip the CSP header off the length field before converting to CSP packet */
	frame->len -= sizeof(csp_id_t);
    549a:	88 87       	std	Y+8, r24	; 0x08
    549c:	99 87       	std	Y+9, r25	; 0x09

	/* Convert the packet from network to host order */
	packet = (csp_packet_t *) frame;
    549e:	c0 93 ff 3a 	sts	0x3AFF, r28
    54a2:	d0 93 00 3b 	sts	0x3B00, r29
	packet->id.ext = csp_ntoh32(packet->id.ext);
    54a6:	6a 85       	ldd	r22, Y+10	; 0x0a
    54a8:	7b 85       	ldd	r23, Y+11	; 0x0b
    54aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    54ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    54ae:	0e 94 37 22 	call	0x446e	; 0x446e <csp_ntoh32>
    54b2:	6a 87       	std	Y+10, r22	; 0x0a
    54b4:	7b 87       	std	Y+11, r23	; 0x0b
    54b6:	8c 87       	std	Y+12, r24	; 0x0c
    54b8:	9d 87       	std	Y+13, r25	; 0x0d

	/* Receive the packet in CSP */
	csp_new_packet(packet, &csp_if_i2c, pxTaskWoken);
    54ba:	a8 01       	movw	r20, r16
    54bc:	66 e0       	ldi	r22, 0x06	; 6
    54be:	70 e2       	ldi	r23, 0x20	; 32
    54c0:	80 91 ff 3a 	lds	r24, 0x3AFF
    54c4:	90 91 00 3b 	lds	r25, 0x3B00
    54c8:	e5 dc       	rcall	.-1590   	; 0x4e94 <csp_new_packet>

}
    54ca:	df 91       	pop	r29
    54cc:	cf 91       	pop	r28
    54ce:	1f 91       	pop	r17
    54d0:	0f 91       	pop	r16
    54d2:	08 95       	ret

000054d4 <csp_i2c_init>:

int csp_i2c_init(uint8_t addr, int handle, int speed) {
    54d4:	cf 92       	push	r12
    54d6:	df 92       	push	r13
    54d8:	ef 92       	push	r14
    54da:	ff 92       	push	r15
    54dc:	0f 93       	push	r16
    54de:	1f 93       	push	r17
    54e0:	e8 2f       	mov	r30, r24
    54e2:	cb 01       	movw	r24, r22
    54e4:	9a 01       	movw	r18, r20

	/* Create i2c_handle */
	if (i2c_init(handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
    54e6:	0f 2e       	mov	r0, r31
    54e8:	fe e2       	ldi	r31, 0x2E	; 46
    54ea:	cf 2e       	mov	r12, r31
    54ec:	fa e2       	ldi	r31, 0x2A	; 42
    54ee:	df 2e       	mov	r13, r31
    54f0:	f0 2d       	mov	r31, r0
    54f2:	0f 2e       	mov	r0, r31
    54f4:	fa e0       	ldi	r31, 0x0A	; 10
    54f6:	ef 2e       	mov	r14, r31
    54f8:	f1 2c       	mov	r15, r1
    54fa:	f0 2d       	mov	r31, r0
    54fc:	0a e0       	ldi	r16, 0x0A	; 10
    54fe:	10 e0       	ldi	r17, 0x00	; 0
    5500:	4e 2f       	mov	r20, r30
    5502:	60 e0       	ldi	r22, 0x00	; 0
    5504:	70 e0       	ldi	r23, 0x00	; 0
    5506:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <i2c_init>
    550a:	01 96       	adiw	r24, 0x01	; 1
    550c:	31 f4       	brne	.+12     	; 0x551a <csp_i2c_init+0x46>
		return CSP_ERR_DRIVER;

	/* Regsiter interface */
	csp_route_add_if(&csp_if_i2c);
    550e:	86 e0       	ldi	r24, 0x06	; 6
    5510:	90 e2       	ldi	r25, 0x20	; 32
    5512:	df da       	rcall	.-2626   	; 0x4ad2 <csp_route_add_if>

	return CSP_ERR_NONE;
    5514:	80 e0       	ldi	r24, 0x00	; 0
    5516:	90 e0       	ldi	r25, 0x00	; 0
    5518:	02 c0       	rjmp	.+4      	; 0x551e <csp_i2c_init+0x4a>

int csp_i2c_init(uint8_t addr, int handle, int speed) {

	/* Create i2c_handle */
	if (i2c_init(handle, I2C_MASTER, addr, speed, 10, 10, csp_i2c_rx) != E_NO_ERR)
		return CSP_ERR_DRIVER;
    551a:	85 ef       	ldi	r24, 0xF5	; 245
    551c:	9f ef       	ldi	r25, 0xFF	; 255
	/* Regsiter interface */
	csp_route_add_if(&csp_if_i2c);

	return CSP_ERR_NONE;

}
    551e:	1f 91       	pop	r17
    5520:	0f 91       	pop	r16
    5522:	ff 90       	pop	r15
    5524:	ef 90       	pop	r14
    5526:	df 90       	pop	r13
    5528:	cf 90       	pop	r12
    552a:	08 95       	ret

0000552c <csp_lo_tx>:
 * Loopback interface transmit function
 * @param packet Packet to transmit
 * @param timeout Timout in ms
 * @return 1 if packet was successfully transmitted, 0 on error
 */
int csp_lo_tx(csp_iface_t * interface, csp_packet_t * packet, uint32_t timeout) {
    552c:	cb 01       	movw	r24, r22

	/* Send back into CSP, notice calling from task so last argument must be NULL! */
	csp_new_packet(packet, &csp_if_lo, NULL);
    552e:	40 e0       	ldi	r20, 0x00	; 0
    5530:	50 e0       	ldi	r21, 0x00	; 0
    5532:	6a e3       	ldi	r22, 0x3A	; 58
    5534:	70 e2       	ldi	r23, 0x20	; 32
    5536:	ae dc       	rcall	.-1700   	; 0x4e94 <csp_new_packet>

	return CSP_ERR_NONE;

}
    5538:	80 e0       	ldi	r24, 0x00	; 0
    553a:	90 e0       	ldi	r25, 0x00	; 0
    553c:	08 95       	ret

0000553e <csp_udp_new_packet>:
#include <csp/csp.h>
#include <csp/arch/csp_queue.h>
#include "../csp_port.h"
#include "../csp_conn.h"

void csp_udp_new_packet(csp_conn_t * conn, csp_packet_t * packet) {
    553e:	0f 93       	push	r16
    5540:	1f 93       	push	r17
    5542:	cf 93       	push	r28
    5544:	df 93       	push	r29
    5546:	1f 92       	push	r1
    5548:	1f 92       	push	r1
    554a:	cd b7       	in	r28, 0x3d	; 61
    554c:	de b7       	in	r29, 0x3e	; 62
    554e:	89 83       	std	Y+1, r24	; 0x01
    5550:	9a 83       	std	Y+2, r25	; 0x02
    5552:	8b 01       	movw	r16, r22

	/* Enqueue */
	if (csp_conn_enqueue_packet(conn, packet) < 0) {
    5554:	0e 94 b6 1f 	call	0x3f6c	; 0x3f6c <csp_conn_enqueue_packet>
    5558:	99 23       	and	r25, r25
    555a:	24 f4       	brge	.+8      	; 0x5564 <csp_udp_new_packet+0x26>
		csp_log_error("Connection buffer queue full!\r\n");
		csp_buffer_free(packet);
    555c:	c8 01       	movw	r24, r16
    555e:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <csp_buffer_free>
		return;
    5562:	19 c0       	rjmp	.+50     	; 0x5596 <csp_udp_new_packet+0x58>
	}

	/* Try to queue up the new connection pointer */
	if (conn->socket != NULL) {
    5564:	e9 81       	ldd	r30, Y+1	; 0x01
    5566:	fa 81       	ldd	r31, Y+2	; 0x02
    5568:	86 85       	ldd	r24, Z+14	; 0x0e
    556a:	97 85       	ldd	r25, Z+15	; 0x0f
    556c:	00 97       	sbiw	r24, 0x00	; 0
    556e:	99 f0       	breq	.+38     	; 0x5596 <csp_udp_new_packet+0x58>
		if (csp_queue_enqueue(conn->socket, &conn, 0) != CSP_QUEUE_OK) {
    5570:	20 e0       	ldi	r18, 0x00	; 0
    5572:	30 e0       	ldi	r19, 0x00	; 0
    5574:	a9 01       	movw	r20, r18
    5576:	be 01       	movw	r22, r28
    5578:	6f 5f       	subi	r22, 0xFF	; 255
    557a:	7f 4f       	sbci	r23, 0xFF	; 255
    557c:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <csp_queue_enqueue>
    5580:	01 97       	sbiw	r24, 0x01	; 1
    5582:	29 f0       	breq	.+10     	; 0x558e <csp_udp_new_packet+0x50>
			csp_log_warn("Warning socket connection queue full\r\n");
			csp_close(conn);
    5584:	89 81       	ldd	r24, Y+1	; 0x01
    5586:	9a 81       	ldd	r25, Y+2	; 0x02
    5588:	0e 94 14 21 	call	0x4228	; 0x4228 <csp_close>
			return;
    558c:	04 c0       	rjmp	.+8      	; 0x5596 <csp_udp_new_packet+0x58>
		}

		/* Ensure that this connection will not be posted to this socket again */
		conn->socket = NULL;
    558e:	e9 81       	ldd	r30, Y+1	; 0x01
    5590:	fa 81       	ldd	r31, Y+2	; 0x02
    5592:	16 86       	std	Z+14, r1	; 0x0e
    5594:	17 86       	std	Z+15, r1	; 0x0f
	}

}
    5596:	0f 90       	pop	r0
    5598:	0f 90       	pop	r0
    559a:	df 91       	pop	r29
    559c:	cf 91       	pop	r28
    559e:	1f 91       	pop	r17
    55a0:	0f 91       	pop	r16
    55a2:	08 95       	ret

000055a4 <main>:
#include "mainTask.h"
#include "cspTask.h"
#include "spi_memory_23lcxx.h"


int main(void) {
    55a4:	af 92       	push	r10
    55a6:	bf 92       	push	r11
    55a8:	cf 92       	push	r12
    55aa:	df 92       	push	r13
    55ac:	ef 92       	push	r14
    55ae:	ff 92       	push	r15
    55b0:	0f 93       	push	r16
	
	// initialize the xMega peripherals
	boardInit();
    55b2:	0e 94 bb 38 	call	0x7176	; 0x7176 <boardInit>
	
	// Initialize the CSP buffers
	csp_buffer_init(CSP_BUFFER_COUNT, CSP_BUFFER_SIZE);
    55b6:	66 e5       	ldi	r22, 0x56	; 86
    55b8:	70 e0       	ldi	r23, 0x00	; 0
    55ba:	83 e0       	ldi	r24, 0x03	; 3
    55bc:	90 e0       	ldi	r25, 0x00	; 0
    55be:	0e 94 7d 1e 	call	0x3cfa	; 0x3cfa <csp_buffer_init>
			
	// Initialize the CSP
	csp_init(CSP_MY_ADDRESS);
    55c2:	86 e0       	ldi	r24, 0x06	; 6
    55c4:	0e 94 76 22 	call	0x44ec	; 0x44ec <csp_init>
	
	// Initialize the CSP I2C interface
	csp_i2c_init(CSP_I2C_SLAVE_ADDRESS, 0, CSP_I2C_BAUDSETTING);
    55c8:	4d e4       	ldi	r20, 0x4D	; 77
    55ca:	50 e0       	ldi	r21, 0x00	; 0
    55cc:	60 e0       	ldi	r22, 0x00	; 0
    55ce:	70 e0       	ldi	r23, 0x00	; 0
    55d0:	86 e0       	ldi	r24, 0x06	; 6
    55d2:	80 df       	rcall	.-256    	; 0x54d4 <csp_i2c_init>
					
	// Add route to OBC via i2c
	csp_route_set(CSP_OBC_ADDRESS, &csp_if_i2c, CSP_I2C_OBC_ADDRESS);
    55d4:	41 e0       	ldi	r20, 0x01	; 1
    55d6:	66 e0       	ldi	r22, 0x06	; 6
    55d8:	70 e2       	ldi	r23, 0x20	; 32
    55da:	81 e0       	ldi	r24, 0x01	; 1
    55dc:	a3 da       	rcall	.-2746   	; 0x4b24 <csp_route_set>
					
	// Start router task
	csp_route_start_task(CSP_ROUTER_STACK, CSP_ROUTER_PRIORITY);
    55de:	61 e0       	ldi	r22, 0x01	; 1
    55e0:	70 e0       	ldi	r23, 0x00	; 0
    55e2:	8f ef       	ldi	r24, 0xFF	; 255
    55e4:	90 e0       	ldi	r25, 0x00	; 0
    55e6:	34 da       	rcall	.-2968   	; 0x4a50 <csp_route_start_task>
	//xTaskCreate(blink, (signed char*) "blink", 64, NULL, configNORMAL_PRIORITY, NULL);
		
	/* -------------------------------------------------------------------- */
	/*	Starts task that handles incoming communication		 				*/
	/* -------------------------------------------------------------------- */
	xTaskCreate(cspTask, (signed char*) "cspTask", 256, NULL, 0, NULL);
    55e8:	a1 2c       	mov	r10, r1
    55ea:	b1 2c       	mov	r11, r1
    55ec:	c1 2c       	mov	r12, r1
    55ee:	d1 2c       	mov	r13, r1
    55f0:	e1 2c       	mov	r14, r1
    55f2:	f1 2c       	mov	r15, r1
    55f4:	00 e0       	ldi	r16, 0x00	; 0
    55f6:	20 e0       	ldi	r18, 0x00	; 0
    55f8:	30 e0       	ldi	r19, 0x00	; 0
    55fa:	40 e0       	ldi	r20, 0x00	; 0
    55fc:	51 e0       	ldi	r21, 0x01	; 1
    55fe:	6a eb       	ldi	r22, 0xBA	; 186
    5600:	70 e2       	ldi	r23, 0x20	; 32
    5602:	81 ef       	ldi	r24, 0xF1	; 241
    5604:	99 e0       	ldi	r25, 0x09	; 9
    5606:	0e 94 9d 14 	call	0x293a	; 0x293a <xTaskGenericCreate>
	
	/* -------------------------------------------------------------------- */
	/*	Starts task that handles outgoing communication		 				*/
	/* -------------------------------------------------------------------- */
	xTaskCreate(mainTask, (signed char*) "mainTask", 512, NULL, 0, NULL);
    560a:	20 e0       	ldi	r18, 0x00	; 0
    560c:	30 e0       	ldi	r19, 0x00	; 0
    560e:	40 e0       	ldi	r20, 0x00	; 0
    5610:	52 e0       	ldi	r21, 0x02	; 2
    5612:	62 ec       	ldi	r22, 0xC2	; 194
    5614:	70 e2       	ldi	r23, 0x20	; 32
    5616:	87 ec       	ldi	r24, 0xC7	; 199
    5618:	9f e2       	ldi	r25, 0x2F	; 47
    561a:	0e 94 9d 14 	call	0x293a	; 0x293a <xTaskGenericCreate>
	
	/* -------------------------------------------------------------------- */
	/*	Starts the scheduler and all previously created tasks				*/
	/* -------------------------------------------------------------------- */
	vTaskStartScheduler();
    561e:	0e 94 f2 15 	call	0x2be4	; 0x2be4 <vTaskStartScheduler>
	
	return 0;
    5622:	80 e0       	ldi	r24, 0x00	; 0
    5624:	90 e0       	ldi	r25, 0x00	; 0
    5626:	0f 91       	pop	r16
    5628:	ff 90       	pop	r15
    562a:	ef 90       	pop	r14
    562c:	df 90       	pop	r13
    562e:	cf 90       	pop	r12
    5630:	bf 90       	pop	r11
    5632:	af 90       	pop	r10
    5634:	08 95       	ret

00005636 <processAll>:
extern unsigned int count_TCD0;

/* -------------------------------------------------------------------- */
/*	Send to the PC/OBC raw sampled signal								*/
/* -------------------------------------------------------------------- */
int processAll(csp_packet_t * inPacket) {
    5636:	8f 92       	push	r8
    5638:	9f 92       	push	r9
    563a:	af 92       	push	r10
    563c:	bf 92       	push	r11
    563e:	cf 92       	push	r12
    5640:	df 92       	push	r13
    5642:	ef 92       	push	r14
    5644:	ff 92       	push	r15
    5646:	0f 93       	push	r16
    5648:	1f 93       	push	r17
    564a:	cf 93       	push	r28
    564c:	df 93       	push	r29
    564e:	cd b7       	in	r28, 0x3d	; 61
    5650:	de b7       	in	r29, 0x3e	; 62
    5652:	64 97       	sbiw	r28, 0x14	; 20
    5654:	cd bf       	out	0x3d, r28	; 61
    5656:	de bf       	out	0x3e, r29	; 62
    5658:	7c 01       	movw	r14, r24
	char msg[20];
	
	count_TCD0 = 0;
    565a:	10 92 da 3d 	sts	0x3DDA, r1
    565e:	10 92 db 3d 	sts	0x3DDB, r1
	sampling = true;
    5662:	81 e0       	ldi	r24, 0x01	; 1
    5664:	80 93 03 3b 	sts	0x3B03, r24
	
	vTaskDelay(2000);
    5668:	80 ed       	ldi	r24, 0xD0	; 208
    566a:	97 e0       	ldi	r25, 0x07	; 7
    566c:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <vTaskDelay>
	while(sampling==true);
    5670:	80 91 03 3b 	lds	r24, 0x3B03
    5674:	81 11       	cpse	r24, r1
    5676:	ff cf       	rjmp	.-2      	; 0x5676 <processAll+0x40>

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->OUTTGL = arch_ioport_pin_to_mask(pin);
    5678:	00 e8       	ldi	r16, 0x80	; 128
    567a:	16 e0       	ldi	r17, 0x06	; 6
    567c:	68 94       	set
    567e:	dd 24       	eor	r13, r13
    5680:	d3 f8       	bld	r13, 3
    5682:	d8 01       	movw	r26, r16
    5684:	17 96       	adiw	r26, 0x07	; 7
    5686:	dc 92       	st	X, r13
	
	power_switch_toggle();
	
	decimate_and_store();
    5688:	0e 94 9f 0b 	call	0x173e	; 0x173e <decimate_and_store>
	FFT_calculate();
    568c:	0e 94 33 0c 	call	0x1866	; 0x1866 <FFT_calculate>
    5690:	f8 01       	movw	r30, r16
    5692:	d7 82       	std	Z+7, r13	; 0x07
	
	power_switch_toggle();
	
	sprintf(msg,"Sampling and computing done\n");
    5694:	8d e1       	ldi	r24, 0x1D	; 29
    5696:	eb ec       	ldi	r30, 0xCB	; 203
    5698:	f0 e2       	ldi	r31, 0x20	; 32
    569a:	8e 01       	movw	r16, r28
    569c:	0f 5f       	subi	r16, 0xFF	; 255
    569e:	1f 4f       	sbci	r17, 0xFF	; 255
    56a0:	d8 01       	movw	r26, r16
    56a2:	01 90       	ld	r0, Z+
    56a4:	0d 92       	st	X+, r0
    56a6:	8a 95       	dec	r24
    56a8:	e1 f7       	brne	.-8      	; 0x56a2 <processAll+0x6c>
	strcpy(outcomingPacket->data, msg);
    56aa:	80 91 89 3c 	lds	r24, 0x3C89
    56ae:	90 91 8a 3c 	lds	r25, 0x3C8A
    56b2:	b8 01       	movw	r22, r16
    56b4:	0e 96       	adiw	r24, 0x0e	; 14
    56b6:	0e 94 70 41 	call	0x82e0	; 0x82e0 <strcpy>
	outcomingPacket->length = strlen(msg);
    56ba:	c0 90 89 3c 	lds	r12, 0x3C89
    56be:	d0 90 8a 3c 	lds	r13, 0x3C8A
    56c2:	f8 01       	movw	r30, r16
    56c4:	01 90       	ld	r0, Z+
    56c6:	00 20       	and	r0, r0
    56c8:	e9 f7       	brne	.-6      	; 0x56c4 <processAll+0x8e>
    56ca:	31 97       	sbiw	r30, 0x01	; 1
    56cc:	e0 1b       	sub	r30, r16
    56ce:	f1 0b       	sbc	r31, r17
    56d0:	d6 01       	movw	r26, r12
    56d2:	18 96       	adiw	r26, 0x08	; 8
    56d4:	ed 93       	st	X+, r30
    56d6:	fc 93       	st	X, r31
    56d8:	19 97       	sbiw	r26, 0x09	; 9
	
	/* Send packet */
	csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 1000);
    56da:	f7 01       	movw	r30, r14
    56dc:	43 85       	ldd	r20, Z+11	; 0x0b
    56de:	84 2f       	mov	r24, r20
    56e0:	82 95       	swap	r24
    56e2:	86 95       	lsr	r24
    56e4:	86 95       	lsr	r24
    56e6:	83 70       	andi	r24, 0x03	; 3
    56e8:	24 85       	ldd	r18, Z+12	; 0x0c
    56ea:	2f 70       	andi	r18, 0x0F	; 15
    56ec:	22 0f       	add	r18, r18
    56ee:	22 0f       	add	r18, r18
    56f0:	28 2b       	or	r18, r24
    56f2:	4f 73       	andi	r20, 0x3F	; 63
    56f4:	65 85       	ldd	r22, Z+13	; 0x0d
    56f6:	66 95       	lsr	r22
    56f8:	6f 71       	andi	r22, 0x1F	; 31
    56fa:	0f 2e       	mov	r0, r31
    56fc:	f8 ee       	ldi	r31, 0xE8	; 232
    56fe:	8f 2e       	mov	r8, r31
    5700:	f3 e0       	ldi	r31, 0x03	; 3
    5702:	9f 2e       	mov	r9, r31
    5704:	a1 2c       	mov	r10, r1
    5706:	b1 2c       	mov	r11, r1
    5708:	f0 2d       	mov	r31, r0
    570a:	e1 2c       	mov	r14, r1
    570c:	f1 2c       	mov	r15, r1
    570e:	87 01       	movw	r16, r14
    5710:	82 e0       	ldi	r24, 0x02	; 2
    5712:	63 d8       	rcall	.-3898   	; 0x47da <csp_sendto>

	vTaskDelay(10);
    5714:	8a e0       	ldi	r24, 0x0A	; 10
    5716:	90 e0       	ldi	r25, 0x00	; 0
    5718:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <vTaskDelay>
	
	
	return 0;
}
    571c:	80 e0       	ldi	r24, 0x00	; 0
    571e:	90 e0       	ldi	r25, 0x00	; 0
    5720:	64 96       	adiw	r28, 0x14	; 20
    5722:	cd bf       	out	0x3d, r28	; 61
    5724:	de bf       	out	0x3e, r29	; 62
    5726:	df 91       	pop	r29
    5728:	cf 91       	pop	r28
    572a:	1f 91       	pop	r17
    572c:	0f 91       	pop	r16
    572e:	ff 90       	pop	r15
    5730:	ef 90       	pop	r14
    5732:	df 90       	pop	r13
    5734:	cf 90       	pop	r12
    5736:	bf 90       	pop	r11
    5738:	af 90       	pop	r10
    573a:	9f 90       	pop	r9
    573c:	8f 90       	pop	r8
    573e:	08 95       	ret

00005740 <sendSignal>:

/* -------------------------------------------------------------------- */
/*	Send to the PC/OBC raw sampled signal								*/
/* -------------------------------------------------------------------- */
int sendSignal(csp_packet_t * inPacket) {
    5740:	2f 92       	push	r2
    5742:	3f 92       	push	r3
    5744:	4f 92       	push	r4
    5746:	5f 92       	push	r5
    5748:	6f 92       	push	r6
    574a:	7f 92       	push	r7
    574c:	8f 92       	push	r8
    574e:	9f 92       	push	r9
    5750:	af 92       	push	r10
    5752:	bf 92       	push	r11
    5754:	cf 92       	push	r12
    5756:	df 92       	push	r13
    5758:	ef 92       	push	r14
    575a:	ff 92       	push	r15
    575c:	0f 93       	push	r16
    575e:	1f 93       	push	r17
    5760:	cf 93       	push	r28
    5762:	df 93       	push	r29
    5764:	cd b7       	in	r28, 0x3d	; 61
    5766:	de b7       	in	r29, 0x3e	; 62
    5768:	a2 97       	sbiw	r28, 0x22	; 34
    576a:	cd bf       	out	0x3d, r28	; 61
    576c:	de bf       	out	0x3e, r29	; 62
    576e:	89 a3       	std	Y+33, r24	; 0x21
    5770:	9a a3       	std	Y+34, r25	; 0x22
	unsigned int i;
	int point;

	char msg[30];
	memset(msg,0,30);
    5772:	fe 01       	movw	r30, r28
    5774:	31 96       	adiw	r30, 0x01	; 1
    5776:	8e e1       	ldi	r24, 0x1E	; 30
    5778:	df 01       	movw	r26, r30
    577a:	1d 92       	st	X+, r1
    577c:	8a 95       	dec	r24
    577e:	e9 f7       	brne	.-6      	; 0x577a <sendSignal+0x3a>
    5780:	88 e0       	ldi	r24, 0x08	; 8
    5782:	e0 e8       	ldi	r30, 0x80	; 128
    5784:	f6 e0       	ldi	r31, 0x06	; 6
    5786:	87 83       	std	Z+7, r24	; 0x07
		
	power_switch_toggle();
	
	TC0_ConfigClockSource(&TCC0, TC_CLKSEL_OFF_gc);	// STOP RTOS
    5788:	60 e0       	ldi	r22, 0x00	; 0
    578a:	80 e0       	ldi	r24, 0x00	; 0
    578c:	98 e0       	ldi	r25, 0x08	; 8
    578e:	e5 d4       	rcall	.+2506   	; 0x615a <TC0_ConfigClockSource>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5790:	e5 e5       	ldi	r30, 0x55	; 85
    5792:	f0 e4       	ldi	r31, 0x40	; 64
    5794:	31 97       	sbiw	r30, 0x01	; 1
    5796:	f1 f7       	brne	.-4      	; 0x5794 <sendSignal+0x54>
    5798:	00 c0       	rjmp	.+0      	; 0x579a <sendSignal+0x5a>
    579a:	00 00       	nop
	_delay_ms(4);
	
	sprintf(msg,"Sampled signal\n");
    579c:	80 e1       	ldi	r24, 0x10	; 16
    579e:	e8 ee       	ldi	r30, 0xE8	; 232
    57a0:	f0 e2       	ldi	r31, 0x20	; 32
    57a2:	8e 01       	movw	r16, r28
    57a4:	0f 5f       	subi	r16, 0xFF	; 255
    57a6:	1f 4f       	sbci	r17, 0xFF	; 255
    57a8:	d8 01       	movw	r26, r16
    57aa:	01 90       	ld	r0, Z+
    57ac:	0d 92       	st	X+, r0
    57ae:	8a 95       	dec	r24
    57b0:	e1 f7       	brne	.-8      	; 0x57aa <sendSignal+0x6a>
	strcpy(outcomingPacket->data, msg);
    57b2:	80 91 89 3c 	lds	r24, 0x3C89
    57b6:	90 91 8a 3c 	lds	r25, 0x3C8A
    57ba:	b8 01       	movw	r22, r16
    57bc:	0e 96       	adiw	r24, 0x0e	; 14
    57be:	0e 94 70 41 	call	0x82e0	; 0x82e0 <strcpy>
	outcomingPacket->length = strlen(msg);
    57c2:	c0 90 89 3c 	lds	r12, 0x3C89
    57c6:	d0 90 8a 3c 	lds	r13, 0x3C8A
    57ca:	f8 01       	movw	r30, r16
    57cc:	01 90       	ld	r0, Z+
    57ce:	00 20       	and	r0, r0
    57d0:	e9 f7       	brne	.-6      	; 0x57cc <sendSignal+0x8c>
    57d2:	31 97       	sbiw	r30, 0x01	; 1
    57d4:	e0 1b       	sub	r30, r16
    57d6:	f1 0b       	sbc	r31, r17
    57d8:	d6 01       	movw	r26, r12
    57da:	18 96       	adiw	r26, 0x08	; 8
    57dc:	ed 93       	st	X+, r30
    57de:	fc 93       	st	X, r31
    57e0:	19 97       	sbiw	r26, 0x09	; 9
			
	/* Send packet */
	csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 100);
    57e2:	e9 a1       	ldd	r30, Y+33	; 0x21
    57e4:	fa a1       	ldd	r31, Y+34	; 0x22
    57e6:	43 85       	ldd	r20, Z+11	; 0x0b
    57e8:	84 2f       	mov	r24, r20
    57ea:	82 95       	swap	r24
    57ec:	86 95       	lsr	r24
    57ee:	86 95       	lsr	r24
    57f0:	83 70       	andi	r24, 0x03	; 3
    57f2:	24 85       	ldd	r18, Z+12	; 0x0c
    57f4:	2f 70       	andi	r18, 0x0F	; 15
    57f6:	22 0f       	add	r18, r18
    57f8:	22 0f       	add	r18, r18
    57fa:	28 2b       	or	r18, r24
    57fc:	4f 73       	andi	r20, 0x3F	; 63
    57fe:	65 85       	ldd	r22, Z+13	; 0x0d
    5800:	66 95       	lsr	r22
    5802:	6f 71       	andi	r22, 0x1F	; 31
    5804:	0f 2e       	mov	r0, r31
    5806:	f4 e6       	ldi	r31, 0x64	; 100
    5808:	8f 2e       	mov	r8, r31
    580a:	91 2c       	mov	r9, r1
    580c:	a1 2c       	mov	r10, r1
    580e:	b1 2c       	mov	r11, r1
    5810:	f0 2d       	mov	r31, r0
    5812:	e1 2c       	mov	r14, r1
    5814:	f1 2c       	mov	r15, r1
    5816:	87 01       	movw	r16, r14
    5818:	82 e0       	ldi	r24, 0x02	; 2
    581a:	0e 94 ed 23 	call	0x47da	; 0x47da <csp_sendto>
    581e:	85 e5       	ldi	r24, 0x55	; 85
    5820:	90 e4       	ldi	r25, 0x40	; 64
    5822:	01 97       	sbiw	r24, 0x01	; 1
    5824:	f1 f7       	brne	.-4      	; 0x5822 <sendSignal+0xe2>
    5826:	00 c0       	rjmp	.+0      	; 0x5828 <sendSignal+0xe8>
    5828:	00 00       	nop
    582a:	61 2c       	mov	r6, r1
    582c:	71 2c       	mov	r7, r1
    582e:	21 2c       	mov	r2, r1
    5830:	31 2c       	mov	r3, r1
    5832:	21 01       	movw	r4, r2
			
	for (i=0;i<MEM_SIGNAL_LENGTH;i++)
	{
		point = spi_mem_read_word(i*2 + MEM_SIGNAL_BEGIN);
		
		sprintf(msg,"%i;%d\n",i*5,point);
    5834:	de 01       	movw	r26, r28
    5836:	11 96       	adiw	r26, 0x01	; 1
    5838:	af 8f       	std	Y+31, r26	; 0x1f
    583a:	b8 a3       	std	Y+32, r27	; 0x20

	_delay_ms(4);
			
	for (i=0;i<MEM_SIGNAL_LENGTH;i++)
	{
		point = spi_mem_read_word(i*2 + MEM_SIGNAL_BEGIN);
    583c:	c2 01       	movw	r24, r4
    583e:	b1 01       	movw	r22, r2
    5840:	0e 94 ca 35 	call	0x6b94	; 0x6b94 <spi_mem_read_word>
		
		sprintf(msg,"%i;%d\n",i*5,point);
    5844:	9f 93       	push	r25
    5846:	8f 93       	push	r24
    5848:	7f 92       	push	r7
    584a:	6f 92       	push	r6
    584c:	a8 ef       	ldi	r26, 0xF8	; 248
    584e:	b0 e2       	ldi	r27, 0x20	; 32
    5850:	bf 93       	push	r27
    5852:	af 93       	push	r26
    5854:	f8 a1       	ldd	r31, Y+32	; 0x20
    5856:	ff 93       	push	r31
    5858:	8f 8d       	ldd	r24, Y+31	; 0x1f
    585a:	8f 93       	push	r24
    585c:	0e 94 d1 41 	call	0x83a2	; 0x83a2 <sprintf>
		strcpy(outcomingPacket->data, msg);
    5860:	80 91 89 3c 	lds	r24, 0x3C89
    5864:	90 91 8a 3c 	lds	r25, 0x3C8A
    5868:	be 01       	movw	r22, r28
    586a:	6f 5f       	subi	r22, 0xFF	; 255
    586c:	7f 4f       	sbci	r23, 0xFF	; 255
    586e:	0e 96       	adiw	r24, 0x0e	; 14
    5870:	0e 94 70 41 	call	0x82e0	; 0x82e0 <strcpy>
		outcomingPacket->length = strlen(msg);
    5874:	c0 90 89 3c 	lds	r12, 0x3C89
    5878:	d0 90 8a 3c 	lds	r13, 0x3C8A
    587c:	ef 8d       	ldd	r30, Y+31	; 0x1f
    587e:	f8 a1       	ldd	r31, Y+32	; 0x20
    5880:	01 90       	ld	r0, Z+
    5882:	00 20       	and	r0, r0
    5884:	e9 f7       	brne	.-6      	; 0x5880 <sendSignal+0x140>
    5886:	31 97       	sbiw	r30, 0x01	; 1
    5888:	af 8d       	ldd	r26, Y+31	; 0x1f
    588a:	b8 a1       	ldd	r27, Y+32	; 0x20
    588c:	ea 1b       	sub	r30, r26
    588e:	fb 0b       	sbc	r31, r27
    5890:	d6 01       	movw	r26, r12
    5892:	18 96       	adiw	r26, 0x08	; 8
    5894:	ed 93       	st	X+, r30
    5896:	fc 93       	st	X, r31
    5898:	19 97       	sbiw	r26, 0x09	; 9
		
		/* Send packet */
		if (csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 100) == CSP_ERR_NONE) {
    589a:	e9 a1       	ldd	r30, Y+33	; 0x21
    589c:	fa a1       	ldd	r31, Y+34	; 0x22
    589e:	43 85       	ldd	r20, Z+11	; 0x0b
    58a0:	84 2f       	mov	r24, r20
    58a2:	82 95       	swap	r24
    58a4:	86 95       	lsr	r24
    58a6:	86 95       	lsr	r24
    58a8:	83 70       	andi	r24, 0x03	; 3
    58aa:	24 85       	ldd	r18, Z+12	; 0x0c
    58ac:	2f 70       	andi	r18, 0x0F	; 15
    58ae:	22 0f       	add	r18, r18
    58b0:	22 0f       	add	r18, r18
    58b2:	28 2b       	or	r18, r24
    58b4:	4f 73       	andi	r20, 0x3F	; 63
    58b6:	65 85       	ldd	r22, Z+13	; 0x0d
    58b8:	66 95       	lsr	r22
    58ba:	6f 71       	andi	r22, 0x1F	; 31
    58bc:	0f 2e       	mov	r0, r31
    58be:	f4 e6       	ldi	r31, 0x64	; 100
    58c0:	8f 2e       	mov	r8, r31
    58c2:	91 2c       	mov	r9, r1
    58c4:	a1 2c       	mov	r10, r1
    58c6:	b1 2c       	mov	r11, r1
    58c8:	f0 2d       	mov	r31, r0
    58ca:	e1 2c       	mov	r14, r1
    58cc:	f1 2c       	mov	r15, r1
    58ce:	87 01       	movw	r16, r14
    58d0:	82 e0       	ldi	r24, 0x02	; 2
    58d2:	0e 94 ed 23 	call	0x47da	; 0x47da <csp_sendto>
    58d6:	8a e2       	ldi	r24, 0x2A	; 42
    58d8:	90 e2       	ldi	r25, 0x20	; 32
    58da:	01 97       	sbiw	r24, 0x01	; 1
    58dc:	f1 f7       	brne	.-4      	; 0x58da <sendSignal+0x19a>
    58de:	00 c0       	rjmp	.+0      	; 0x58e0 <sendSignal+0x1a0>
    58e0:	00 00       	nop
    58e2:	92 e0       	ldi	r25, 0x02	; 2
    58e4:	29 0e       	add	r2, r25
    58e6:	31 1c       	adc	r3, r1
    58e8:	41 1c       	adc	r4, r1
    58ea:	51 1c       	adc	r5, r1
    58ec:	a5 e0       	ldi	r26, 0x05	; 5
    58ee:	6a 0e       	add	r6, r26
    58f0:	71 1c       	adc	r7, r1
	/* Send packet */
	csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 100);

	_delay_ms(4);
			
	for (i=0;i<MEM_SIGNAL_LENGTH;i++)
    58f2:	cd bf       	out	0x3d, r28	; 61
    58f4:	de bf       	out	0x3e, r29	; 62
    58f6:	61 14       	cp	r6, r1
    58f8:	f8 e2       	ldi	r31, 0x28	; 40
    58fa:	7f 06       	cpc	r7, r31
    58fc:	09 f0       	breq	.+2      	; 0x5900 <sendSignal+0x1c0>
    58fe:	9e cf       	rjmp	.-196    	; 0x583c <sendSignal+0xfc>
		}
		_delay_ms(2);
		//vTaskDelay(7);
	}
	
	TC0_ConfigClockSource(&TCC0, TC_CLKSEL_DIV64_gc);	// Continue RTOS
    5900:	65 e0       	ldi	r22, 0x05	; 5
    5902:	80 e0       	ldi	r24, 0x00	; 0
    5904:	98 e0       	ldi	r25, 0x08	; 8
    5906:	29 d4       	rcall	.+2130   	; 0x615a <TC0_ConfigClockSource>
	
	return 0;
}
    5908:	80 e0       	ldi	r24, 0x00	; 0
    590a:	90 e0       	ldi	r25, 0x00	; 0
    590c:	a2 96       	adiw	r28, 0x22	; 34
    590e:	cd bf       	out	0x3d, r28	; 61
    5910:	de bf       	out	0x3e, r29	; 62
    5912:	df 91       	pop	r29
    5914:	cf 91       	pop	r28
    5916:	1f 91       	pop	r17
    5918:	0f 91       	pop	r16
    591a:	ff 90       	pop	r15
    591c:	ef 90       	pop	r14
    591e:	df 90       	pop	r13
    5920:	cf 90       	pop	r12
    5922:	bf 90       	pop	r11
    5924:	af 90       	pop	r10
    5926:	9f 90       	pop	r9
    5928:	8f 90       	pop	r8
    592a:	7f 90       	pop	r7
    592c:	6f 90       	pop	r6
    592e:	5f 90       	pop	r5
    5930:	4f 90       	pop	r4
    5932:	3f 90       	pop	r3
    5934:	2f 90       	pop	r2
    5936:	08 95       	ret

00005938 <sendFFT>:

/* -------------------------------------------------------------------- */
/*	Send to the PC/OBC raw sampled signal								*/
/* -------------------------------------------------------------------- */
int sendFFT(csp_packet_t * inPacket) {
    5938:	2f 92       	push	r2
    593a:	3f 92       	push	r3
    593c:	4f 92       	push	r4
    593e:	5f 92       	push	r5
    5940:	6f 92       	push	r6
    5942:	7f 92       	push	r7
    5944:	8f 92       	push	r8
    5946:	9f 92       	push	r9
    5948:	af 92       	push	r10
    594a:	bf 92       	push	r11
    594c:	cf 92       	push	r12
    594e:	df 92       	push	r13
    5950:	ef 92       	push	r14
    5952:	ff 92       	push	r15
    5954:	0f 93       	push	r16
    5956:	1f 93       	push	r17
    5958:	cf 93       	push	r28
    595a:	df 93       	push	r29
    595c:	cd b7       	in	r28, 0x3d	; 61
    595e:	de b7       	in	r29, 0x3e	; 62
    5960:	ac 97       	sbiw	r28, 0x2c	; 44
    5962:	cd bf       	out	0x3d, r28	; 61
    5964:	de bf       	out	0x3e, r29	; 62
    5966:	8b a7       	std	Y+43, r24	; 0x2b
    5968:	9c a7       	std	Y+44, r25	; 0x2c
	complex point;
	int data;
	long f_axis;

	char msg[30];
	memset(msg,0,30);
    596a:	fe 01       	movw	r30, r28
    596c:	39 96       	adiw	r30, 0x09	; 9
    596e:	8e e1       	ldi	r24, 0x1E	; 30
    5970:	df 01       	movw	r26, r30
    5972:	1d 92       	st	X+, r1
    5974:	8a 95       	dec	r24
    5976:	e9 f7       	brne	.-6      	; 0x5972 <sendFFT+0x3a>
	
	TC0_ConfigClockSource(&TCC0, TC_CLKSEL_OFF_gc);	// STOP RTOS
    5978:	60 e0       	ldi	r22, 0x00	; 0
    597a:	80 e0       	ldi	r24, 0x00	; 0
    597c:	98 e0       	ldi	r25, 0x08	; 8
    597e:	ed d3       	rcall	.+2010   	; 0x615a <TC0_ConfigClockSource>
    5980:	eb e6       	ldi	r30, 0x6B	; 107
    5982:	f0 e5       	ldi	r31, 0x50	; 80
    5984:	31 97       	sbiw	r30, 0x01	; 1
    5986:	f1 f7       	brne	.-4      	; 0x5984 <sendFFT+0x4c>
    5988:	00 00       	nop
    598a:	88 e0       	ldi	r24, 0x08	; 8
    598c:	e0 e8       	ldi	r30, 0x80	; 128
    598e:	f6 e0       	ldi	r31, 0x06	; 6
    5990:	87 83       	std	Z+7, r24	; 0x07
	_delay_ms(5);
	
	power_switch_toggle();
	
	sprintf(msg,"Sampled signal\n");
    5992:	7e 01       	movw	r14, r28
    5994:	f9 e0       	ldi	r31, 0x09	; 9
    5996:	ef 0e       	add	r14, r31
    5998:	f1 1c       	adc	r15, r1
    599a:	80 e1       	ldi	r24, 0x10	; 16
    599c:	e8 ee       	ldi	r30, 0xE8	; 232
    599e:	f0 e2       	ldi	r31, 0x20	; 32
    59a0:	d7 01       	movw	r26, r14
    59a2:	01 90       	ld	r0, Z+
    59a4:	0d 92       	st	X+, r0
    59a6:	8a 95       	dec	r24
    59a8:	e1 f7       	brne	.-8      	; 0x59a2 <sendFFT+0x6a>
	strcpy(outcomingPacket->data, msg);
    59aa:	80 91 89 3c 	lds	r24, 0x3C89
    59ae:	90 91 8a 3c 	lds	r25, 0x3C8A
    59b2:	b7 01       	movw	r22, r14
    59b4:	0e 96       	adiw	r24, 0x0e	; 14
    59b6:	0e 94 70 41 	call	0x82e0	; 0x82e0 <strcpy>
	outcomingPacket->length = strlen(msg);
    59ba:	c0 90 89 3c 	lds	r12, 0x3C89
    59be:	d0 90 8a 3c 	lds	r13, 0x3C8A
    59c2:	f7 01       	movw	r30, r14
    59c4:	01 90       	ld	r0, Z+
    59c6:	00 20       	and	r0, r0
    59c8:	e9 f7       	brne	.-6      	; 0x59c4 <sendFFT+0x8c>
    59ca:	31 97       	sbiw	r30, 0x01	; 1
    59cc:	ee 19       	sub	r30, r14
    59ce:	ff 09       	sbc	r31, r15
    59d0:	d6 01       	movw	r26, r12
    59d2:	18 96       	adiw	r26, 0x08	; 8
    59d4:	ed 93       	st	X+, r30
    59d6:	fc 93       	st	X, r31
    59d8:	19 97       	sbiw	r26, 0x09	; 9
	
	
	/* Send packet */
		csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 15);
    59da:	eb a5       	ldd	r30, Y+43	; 0x2b
    59dc:	fc a5       	ldd	r31, Y+44	; 0x2c
    59de:	43 85       	ldd	r20, Z+11	; 0x0b
    59e0:	84 2f       	mov	r24, r20
    59e2:	82 95       	swap	r24
    59e4:	86 95       	lsr	r24
    59e6:	86 95       	lsr	r24
    59e8:	83 70       	andi	r24, 0x03	; 3
    59ea:	24 85       	ldd	r18, Z+12	; 0x0c
    59ec:	2f 70       	andi	r18, 0x0F	; 15
    59ee:	22 0f       	add	r18, r18
    59f0:	22 0f       	add	r18, r18
    59f2:	28 2b       	or	r18, r24
    59f4:	4f 73       	andi	r20, 0x3F	; 63
    59f6:	65 85       	ldd	r22, Z+13	; 0x0d
    59f8:	66 95       	lsr	r22
    59fa:	6f 71       	andi	r22, 0x1F	; 31
    59fc:	0f 2e       	mov	r0, r31
    59fe:	ff e0       	ldi	r31, 0x0F	; 15
    5a00:	8f 2e       	mov	r8, r31
    5a02:	91 2c       	mov	r9, r1
    5a04:	a1 2c       	mov	r10, r1
    5a06:	b1 2c       	mov	r11, r1
    5a08:	f0 2d       	mov	r31, r0
    5a0a:	e1 2c       	mov	r14, r1
    5a0c:	f1 2c       	mov	r15, r1
    5a0e:	87 01       	movw	r16, r14
    5a10:	82 e0       	ldi	r24, 0x02	; 2
    5a12:	0e 94 ed 23 	call	0x47da	; 0x47da <csp_sendto>
    5a16:	41 2c       	mov	r4, r1
    5a18:	51 2c       	mov	r5, r1
    5a1a:	32 01       	movw	r6, r4
    5a1c:	80 e0       	ldi	r24, 0x00	; 0
    5a1e:	98 e1       	ldi	r25, 0x18	; 24
    5a20:	a0 e0       	ldi	r26, 0x00	; 0
    5a22:	b0 e0       	ldi	r27, 0x00	; 0
    5a24:	8f a3       	std	Y+39, r24	; 0x27
    5a26:	98 a7       	std	Y+40, r25	; 0x28
    5a28:	a9 a7       	std	Y+41, r26	; 0x29
    5a2a:	ba a7       	std	Y+42, r27	; 0x2a
		data2 =  log(point.real+point.imag)*10;
		data = (int) data2;
		
		f_axis = (((long) i)*10000)/NO_POINTS;
		
		memset(msg,0,30);
    5a2c:	1e 01       	movw	r2, r28
    5a2e:	99 e0       	ldi	r25, 0x09	; 9
    5a30:	29 0e       	add	r2, r25
    5a32:	31 1c       	adc	r3, r1
		csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 15);

	
	for (i=0;i<NO_POINTS/2;i++)
	{
		point = spi_mem_read_complex(i*8 + MEM_FFT_BEGIN);
    5a34:	6f a1       	ldd	r22, Y+39	; 0x27
    5a36:	78 a5       	ldd	r23, Y+40	; 0x28
    5a38:	89 a5       	ldd	r24, Y+41	; 0x29
    5a3a:	9a a5       	ldd	r25, Y+42	; 0x2a
    5a3c:	0e 94 fc 35 	call	0x6bf8	; 0x6bf8 <spi_mem_read_complex>
    5a40:	29 83       	std	Y+1, r18	; 0x01
    5a42:	3a 83       	std	Y+2, r19	; 0x02
    5a44:	4b 83       	std	Y+3, r20	; 0x03
    5a46:	5c 83       	std	Y+4, r21	; 0x04
    5a48:	6d 83       	std	Y+5, r22	; 0x05
    5a4a:	7e 83       	std	Y+6, r23	; 0x06
    5a4c:	8f 83       	std	Y+7, r24	; 0x07
    5a4e:	98 87       	std	Y+8, r25	; 0x08
    5a50:	69 81       	ldd	r22, Y+1	; 0x01
    5a52:	7a 81       	ldd	r23, Y+2	; 0x02
    5a54:	8b 81       	ldd	r24, Y+3	; 0x03
    5a56:	9c 81       	ldd	r25, Y+4	; 0x04
    5a58:	cd 80       	ldd	r12, Y+5	; 0x05
    5a5a:	de 80       	ldd	r13, Y+6	; 0x06
    5a5c:	ef 80       	ldd	r14, Y+7	; 0x07
    5a5e:	f8 84       	ldd	r15, Y+8	; 0x08
		point.real *= point.real;
    5a60:	9b 01       	movw	r18, r22
    5a62:	ac 01       	movw	r20, r24
    5a64:	0e 94 94 3b 	call	0x7728	; 0x7728 <__mulsf3>
    5a68:	4b 01       	movw	r8, r22
    5a6a:	5c 01       	movw	r10, r24
		point.imag *=  point.imag;
    5a6c:	a7 01       	movw	r20, r14
    5a6e:	96 01       	movw	r18, r12
    5a70:	c7 01       	movw	r24, r14
    5a72:	b6 01       	movw	r22, r12
    5a74:	0e 94 94 3b 	call	0x7728	; 0x7728 <__mulsf3>
    5a78:	9b 01       	movw	r18, r22
    5a7a:	ac 01       	movw	r20, r24
		data2 =  log(point.real+point.imag)*10;
    5a7c:	c5 01       	movw	r24, r10
    5a7e:	b4 01       	movw	r22, r8
    5a80:	0e 94 2c 3a 	call	0x7458	; 0x7458 <__addsf3>
    5a84:	0e 94 54 3b 	call	0x76a8	; 0x76a8 <log>
		data = (int) data2;
		
		f_axis = (((long) i)*10000)/NO_POINTS;
		
		memset(msg,0,30);
    5a88:	d1 01       	movw	r26, r2
    5a8a:	ee e1       	ldi	r30, 0x1E	; 30
    5a8c:	1d 92       	st	X+, r1
    5a8e:	ea 95       	dec	r30
    5a90:	e9 f7       	brne	.-6      	; 0x5a8c <sendFFT+0x154>
	for (i=0;i<NO_POINTS/2;i++)
	{
		point = spi_mem_read_complex(i*8 + MEM_FFT_BEGIN);
		point.real *= point.real;
		point.imag *=  point.imag;
		data2 =  log(point.real+point.imag)*10;
    5a92:	20 e0       	ldi	r18, 0x00	; 0
    5a94:	30 e0       	ldi	r19, 0x00	; 0
    5a96:	40 e2       	ldi	r20, 0x20	; 32
    5a98:	51 e4       	ldi	r21, 0x41	; 65
    5a9a:	0e 94 94 3b 	call	0x7728	; 0x7728 <__mulsf3>
		data = (int) data2;
    5a9e:	0e 94 90 3a 	call	0x7520	; 0x7520 <__fixsfsi>
		
		f_axis = (((long) i)*10000)/NO_POINTS;
		
		memset(msg,0,30);
		
		sprintf(msg,"%i;%d\n",(int) f_axis, data);
    5aa2:	7f 93       	push	r23
    5aa4:	6f 93       	push	r22
		point.real *= point.real;
		point.imag *=  point.imag;
		data2 =  log(point.real+point.imag)*10;
		data = (int) data2;
		
		f_axis = (((long) i)*10000)/NO_POINTS;
    5aa6:	d3 01       	movw	r26, r6
    5aa8:	c2 01       	movw	r24, r4
    5aaa:	77 20       	and	r7, r7
    5aac:	24 f4       	brge	.+8      	; 0x5ab6 <sendFFT+0x17e>
    5aae:	81 50       	subi	r24, 0x01	; 1
    5ab0:	9e 4f       	sbci	r25, 0xFE	; 254
    5ab2:	af 4f       	sbci	r26, 0xFF	; 255
    5ab4:	bf 4f       	sbci	r27, 0xFF	; 255
    5ab6:	07 2e       	mov	r0, r23
    5ab8:	79 e0       	ldi	r23, 0x09	; 9
    5aba:	b5 95       	asr	r27
    5abc:	a7 95       	ror	r26
    5abe:	97 95       	ror	r25
    5ac0:	87 95       	ror	r24
    5ac2:	7a 95       	dec	r23
    5ac4:	d1 f7       	brne	.-12     	; 0x5aba <sendFFT+0x182>
    5ac6:	70 2d       	mov	r23, r0
		
		memset(msg,0,30);
		
		sprintf(msg,"%i;%d\n",(int) f_axis, data);
    5ac8:	9f 93       	push	r25
    5aca:	8f 93       	push	r24
    5acc:	a8 ef       	ldi	r26, 0xF8	; 248
    5ace:	b0 e2       	ldi	r27, 0x20	; 32
    5ad0:	bf 93       	push	r27
    5ad2:	af 93       	push	r26
    5ad4:	3f 92       	push	r3
    5ad6:	2f 92       	push	r2
    5ad8:	0e 94 d1 41 	call	0x83a2	; 0x83a2 <sprintf>
		strcpy(outcomingPacket->data, msg);
    5adc:	80 91 89 3c 	lds	r24, 0x3C89
    5ae0:	90 91 8a 3c 	lds	r25, 0x3C8A
    5ae4:	b1 01       	movw	r22, r2
    5ae6:	0e 96       	adiw	r24, 0x0e	; 14
    5ae8:	0e 94 70 41 	call	0x82e0	; 0x82e0 <strcpy>
		outcomingPacket->length = strlen(msg);
    5aec:	c0 90 89 3c 	lds	r12, 0x3C89
    5af0:	d0 90 8a 3c 	lds	r13, 0x3C8A
    5af4:	f1 01       	movw	r30, r2
    5af6:	01 90       	ld	r0, Z+
    5af8:	00 20       	and	r0, r0
    5afa:	e9 f7       	brne	.-6      	; 0x5af6 <sendFFT+0x1be>
    5afc:	31 97       	sbiw	r30, 0x01	; 1
    5afe:	e2 19       	sub	r30, r2
    5b00:	f3 09       	sbc	r31, r3
    5b02:	d6 01       	movw	r26, r12
    5b04:	18 96       	adiw	r26, 0x08	; 8
    5b06:	ed 93       	st	X+, r30
    5b08:	fc 93       	st	X, r31
    5b0a:	19 97       	sbiw	r26, 0x09	; 9
		
		/* Send packet */
		if (csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 10) == CSP_ERR_NONE) {
    5b0c:	eb a5       	ldd	r30, Y+43	; 0x2b
    5b0e:	fc a5       	ldd	r31, Y+44	; 0x2c
    5b10:	43 85       	ldd	r20, Z+11	; 0x0b
    5b12:	84 2f       	mov	r24, r20
    5b14:	82 95       	swap	r24
    5b16:	86 95       	lsr	r24
    5b18:	86 95       	lsr	r24
    5b1a:	83 70       	andi	r24, 0x03	; 3
    5b1c:	24 85       	ldd	r18, Z+12	; 0x0c
    5b1e:	2f 70       	andi	r18, 0x0F	; 15
    5b20:	22 0f       	add	r18, r18
    5b22:	22 0f       	add	r18, r18
    5b24:	28 2b       	or	r18, r24
    5b26:	4f 73       	andi	r20, 0x3F	; 63
    5b28:	65 85       	ldd	r22, Z+13	; 0x0d
    5b2a:	66 95       	lsr	r22
    5b2c:	6f 71       	andi	r22, 0x1F	; 31
    5b2e:	0f 2e       	mov	r0, r31
    5b30:	fa e0       	ldi	r31, 0x0A	; 10
    5b32:	8f 2e       	mov	r8, r31
    5b34:	91 2c       	mov	r9, r1
    5b36:	a1 2c       	mov	r10, r1
    5b38:	b1 2c       	mov	r11, r1
    5b3a:	f0 2d       	mov	r31, r0
    5b3c:	e1 2c       	mov	r14, r1
    5b3e:	f1 2c       	mov	r15, r1
    5b40:	87 01       	movw	r16, r14
    5b42:	82 e0       	ldi	r24, 0x02	; 2
    5b44:	0e 94 ed 23 	call	0x47da	; 0x47da <csp_sendto>
    5b48:	cd bf       	out	0x3d, r28	; 61
    5b4a:	de bf       	out	0x3e, r29	; 62
    5b4c:	89 2b       	or	r24, r25
    5b4e:	19 f4       	brne	.+6      	; 0x5b56 <sendFFT+0x21e>
    5b50:	38 e0       	ldi	r19, 0x08	; 8
    5b52:	30 93 87 06 	sts	0x0687, r19
    5b56:	85 e5       	ldi	r24, 0x55	; 85
    5b58:	90 e4       	ldi	r25, 0x40	; 64
    5b5a:	01 97       	sbiw	r24, 0x01	; 1
    5b5c:	f1 f7       	brne	.-4      	; 0x5b5a <sendFFT+0x222>
    5b5e:	00 c0       	rjmp	.+0      	; 0x5b60 <sendFFT+0x228>
    5b60:	00 00       	nop
    5b62:	8f a1       	ldd	r24, Y+39	; 0x27
    5b64:	98 a5       	ldd	r25, Y+40	; 0x28
    5b66:	a9 a5       	ldd	r26, Y+41	; 0x29
    5b68:	ba a5       	ldd	r27, Y+42	; 0x2a
    5b6a:	08 96       	adiw	r24, 0x08	; 8
    5b6c:	a1 1d       	adc	r26, r1
    5b6e:	b1 1d       	adc	r27, r1
    5b70:	8f a3       	std	Y+39, r24	; 0x27
    5b72:	98 a7       	std	Y+40, r25	; 0x28
    5b74:	a9 a7       	std	Y+41, r26	; 0x29
    5b76:	ba a7       	std	Y+42, r27	; 0x2a
    5b78:	90 e1       	ldi	r25, 0x10	; 16
    5b7a:	49 0e       	add	r4, r25
    5b7c:	97 e2       	ldi	r25, 0x27	; 39
    5b7e:	59 1e       	adc	r5, r25
    5b80:	61 1c       	adc	r6, r1
    5b82:	71 1c       	adc	r7, r1
	
	/* Send packet */
		csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 15);

	
	for (i=0;i<NO_POINTS/2;i++)
    5b84:	8f a1       	ldd	r24, Y+39	; 0x27
    5b86:	98 a5       	ldd	r25, Y+40	; 0x28
    5b88:	a9 a5       	ldd	r26, Y+41	; 0x29
    5b8a:	ba a5       	ldd	r27, Y+42	; 0x2a
    5b8c:	81 15       	cp	r24, r1
    5b8e:	90 42       	sbci	r25, 0x20	; 32
    5b90:	a1 05       	cpc	r26, r1
    5b92:	b1 05       	cpc	r27, r1
    5b94:	09 f0       	breq	.+2      	; 0x5b98 <sendFFT+0x260>
    5b96:	4e cf       	rjmp	.-356    	; 0x5a34 <sendFFT+0xfc>
			/* Send failed */
		}
		_delay_ms(4);
	}

	TC0_ConfigClockSource(&TCC0, TC_CLKSEL_DIV64_gc);	// continue RTOS
    5b98:	65 e0       	ldi	r22, 0x05	; 5
    5b9a:	80 e0       	ldi	r24, 0x00	; 0
    5b9c:	98 e0       	ldi	r25, 0x08	; 8
    5b9e:	dd d2       	rcall	.+1466   	; 0x615a <TC0_ConfigClockSource>
	
	return 0;
}
    5ba0:	80 e0       	ldi	r24, 0x00	; 0
    5ba2:	90 e0       	ldi	r25, 0x00	; 0
    5ba4:	ac 96       	adiw	r28, 0x2c	; 44
    5ba6:	cd bf       	out	0x3d, r28	; 61
    5ba8:	de bf       	out	0x3e, r29	; 62
    5baa:	df 91       	pop	r29
    5bac:	cf 91       	pop	r28
    5bae:	1f 91       	pop	r17
    5bb0:	0f 91       	pop	r16
    5bb2:	ff 90       	pop	r15
    5bb4:	ef 90       	pop	r14
    5bb6:	df 90       	pop	r13
    5bb8:	cf 90       	pop	r12
    5bba:	bf 90       	pop	r11
    5bbc:	af 90       	pop	r10
    5bbe:	9f 90       	pop	r9
    5bc0:	8f 90       	pop	r8
    5bc2:	7f 90       	pop	r7
    5bc4:	6f 90       	pop	r6
    5bc6:	5f 90       	pop	r5
    5bc8:	4f 90       	pop	r4
    5bca:	3f 90       	pop	r3
    5bcc:	2f 90       	pop	r2
    5bce:	08 95       	ret

00005bd0 <sendFreeHeapSpace>:

/* -------------------------------------------------------------------- */
/*	Reply the free heap space in human readable form					*/
/* -------------------------------------------------------------------- */
int sendFreeHeapSpace(csp_packet_t * inPacket) {
    5bd0:	8f 92       	push	r8
    5bd2:	9f 92       	push	r9
    5bd4:	af 92       	push	r10
    5bd6:	bf 92       	push	r11
    5bd8:	cf 92       	push	r12
    5bda:	df 92       	push	r13
    5bdc:	ef 92       	push	r14
    5bde:	ff 92       	push	r15
    5be0:	0f 93       	push	r16
    5be2:	1f 93       	push	r17
    5be4:	cf 93       	push	r28
    5be6:	df 93       	push	r29
    5be8:	cd b7       	in	r28, 0x3d	; 61
    5bea:	de b7       	in	r29, 0x3e	; 62
    5bec:	64 97       	sbiw	r28, 0x14	; 20
    5bee:	cd bf       	out	0x3d, r28	; 61
    5bf0:	de bf       	out	0x3e, r29	; 62
    5bf2:	8c 01       	movw	r16, r24
	char msg[20];
	int temp;
	memset(msg,0,20);
    5bf4:	fe 01       	movw	r30, r28
    5bf6:	31 96       	adiw	r30, 0x01	; 1
    5bf8:	84 e1       	ldi	r24, 0x14	; 20
    5bfa:	df 01       	movw	r26, r30
    5bfc:	1d 92       	st	X+, r1
    5bfe:	8a 95       	dec	r24
    5c00:	e9 f7       	brne	.-6      	; 0x5bfc <sendFreeHeapSpace+0x2c>
	
	TC0_ConfigClockSource(&TCC0, TC_CLKSEL_OFF_gc);	// STOP RTOS
    5c02:	60 e0       	ldi	r22, 0x00	; 0
    5c04:	80 e0       	ldi	r24, 0x00	; 0
    5c06:	98 e0       	ldi	r25, 0x08	; 8
    5c08:	a8 d2       	rcall	.+1360   	; 0x615a <TC0_ConfigClockSource>
	
	temp = ADT_get_temperature();
    5c0a:	1b d2       	rcall	.+1078   	; 0x6042 <ADT_get_temperature>
    5c0c:	fc 01       	movw	r30, r24
	
	sprintf(msg,"%i.%i\n",temp/128,(int)((((long)temp)*100)/128)%100);
    5c0e:	24 e6       	ldi	r18, 0x64	; 100
    5c10:	30 e0       	ldi	r19, 0x00	; 0
    5c12:	dc 01       	movw	r26, r24
    5c14:	0e 94 f5 3f 	call	0x7fea	; 0x7fea <__usmulhisi3>
    5c18:	6b 01       	movw	r12, r22
    5c1a:	7c 01       	movw	r14, r24
    5c1c:	99 23       	and	r25, r25
    5c1e:	2c f4       	brge	.+10     	; 0x5c2a <sendFreeHeapSpace+0x5a>
    5c20:	bf e7       	ldi	r27, 0x7F	; 127
    5c22:	cb 0e       	add	r12, r27
    5c24:	d1 1c       	adc	r13, r1
    5c26:	e1 1c       	adc	r14, r1
    5c28:	f1 1c       	adc	r15, r1
    5c2a:	d7 01       	movw	r26, r14
    5c2c:	c6 01       	movw	r24, r12
    5c2e:	68 94       	set
    5c30:	16 f8       	bld	r1, 6
    5c32:	b5 95       	asr	r27
    5c34:	a7 95       	ror	r26
    5c36:	97 95       	ror	r25
    5c38:	87 95       	ror	r24
    5c3a:	16 94       	lsr	r1
    5c3c:	d1 f7       	brne	.-12     	; 0x5c32 <sendFreeHeapSpace+0x62>
    5c3e:	64 e6       	ldi	r22, 0x64	; 100
    5c40:	70 e0       	ldi	r23, 0x00	; 0
    5c42:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <__divmodhi4>
    5c46:	9f 93       	push	r25
    5c48:	8f 93       	push	r24
    5c4a:	cf 01       	movw	r24, r30
    5c4c:	ff 23       	and	r31, r31
    5c4e:	14 f4       	brge	.+4      	; 0x5c54 <sendFreeHeapSpace+0x84>
    5c50:	81 58       	subi	r24, 0x81	; 129
    5c52:	9f 4f       	sbci	r25, 0xFF	; 255
    5c54:	88 0f       	add	r24, r24
    5c56:	89 2f       	mov	r24, r25
    5c58:	88 1f       	adc	r24, r24
    5c5a:	99 0b       	sbc	r25, r25
    5c5c:	9f 93       	push	r25
    5c5e:	8f 93       	push	r24
    5c60:	8f ef       	ldi	r24, 0xFF	; 255
    5c62:	90 e2       	ldi	r25, 0x20	; 32
    5c64:	9f 93       	push	r25
    5c66:	8f 93       	push	r24
    5c68:	fe 01       	movw	r30, r28
    5c6a:	31 96       	adiw	r30, 0x01	; 1
    5c6c:	7f 01       	movw	r14, r30
    5c6e:	ff 92       	push	r15
    5c70:	ef 93       	push	r30
    5c72:	0e 94 d1 41 	call	0x83a2	; 0x83a2 <sprintf>
	strcpy(outcomingPacket->data, msg);
    5c76:	80 91 89 3c 	lds	r24, 0x3C89
    5c7a:	90 91 8a 3c 	lds	r25, 0x3C8A
    5c7e:	b7 01       	movw	r22, r14
    5c80:	0e 96       	adiw	r24, 0x0e	; 14
    5c82:	0e 94 70 41 	call	0x82e0	; 0x82e0 <strcpy>
	outcomingPacket->length = strlen(msg);
    5c86:	c0 90 89 3c 	lds	r12, 0x3C89
    5c8a:	d0 90 8a 3c 	lds	r13, 0x3C8A
    5c8e:	f7 01       	movw	r30, r14
    5c90:	01 90       	ld	r0, Z+
    5c92:	00 20       	and	r0, r0
    5c94:	e9 f7       	brne	.-6      	; 0x5c90 <sendFreeHeapSpace+0xc0>
    5c96:	31 97       	sbiw	r30, 0x01	; 1
    5c98:	ee 19       	sub	r30, r14
    5c9a:	ff 09       	sbc	r31, r15
    5c9c:	d6 01       	movw	r26, r12
    5c9e:	18 96       	adiw	r26, 0x08	; 8
    5ca0:	ed 93       	st	X+, r30
    5ca2:	fc 93       	st	X, r31
    5ca4:	19 97       	sbiw	r26, 0x09	; 9
	csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 10);
    5ca6:	f8 01       	movw	r30, r16
    5ca8:	43 85       	ldd	r20, Z+11	; 0x0b
    5caa:	84 2f       	mov	r24, r20
    5cac:	82 95       	swap	r24
    5cae:	86 95       	lsr	r24
    5cb0:	86 95       	lsr	r24
    5cb2:	83 70       	andi	r24, 0x03	; 3
    5cb4:	24 85       	ldd	r18, Z+12	; 0x0c
    5cb6:	2f 70       	andi	r18, 0x0F	; 15
    5cb8:	22 0f       	add	r18, r18
    5cba:	22 0f       	add	r18, r18
    5cbc:	28 2b       	or	r18, r24
    5cbe:	4f 73       	andi	r20, 0x3F	; 63
    5cc0:	65 85       	ldd	r22, Z+13	; 0x0d
    5cc2:	66 95       	lsr	r22
    5cc4:	6f 71       	andi	r22, 0x1F	; 31
    5cc6:	0f 2e       	mov	r0, r31
    5cc8:	fa e0       	ldi	r31, 0x0A	; 10
    5cca:	8f 2e       	mov	r8, r31
    5ccc:	91 2c       	mov	r9, r1
    5cce:	a1 2c       	mov	r10, r1
    5cd0:	b1 2c       	mov	r11, r1
    5cd2:	f0 2d       	mov	r31, r0
    5cd4:	e1 2c       	mov	r14, r1
    5cd6:	f1 2c       	mov	r15, r1
    5cd8:	87 01       	movw	r16, r14
    5cda:	82 e0       	ldi	r24, 0x02	; 2
    5cdc:	0e 94 ed 23 	call	0x47da	; 0x47da <csp_sendto>
	
	TC0_ConfigClockSource(&TCC0, TC_CLKSEL_DIV64_gc);	// continue RTOS
    5ce0:	65 e0       	ldi	r22, 0x05	; 5
    5ce2:	80 e0       	ldi	r24, 0x00	; 0
    5ce4:	98 e0       	ldi	r25, 0x08	; 8
    5ce6:	39 d2       	rcall	.+1138   	; 0x615a <TC0_ConfigClockSource>
// 		/* Send failed */
// 
// 	}
		

	return 0;
    5ce8:	cd bf       	out	0x3d, r28	; 61
    5cea:	de bf       	out	0x3e, r29	; 62
}
    5cec:	80 e0       	ldi	r24, 0x00	; 0
    5cee:	90 e0       	ldi	r25, 0x00	; 0
    5cf0:	64 96       	adiw	r28, 0x14	; 20
    5cf2:	cd bf       	out	0x3d, r28	; 61
    5cf4:	de bf       	out	0x3e, r29	; 62
    5cf6:	df 91       	pop	r29
    5cf8:	cf 91       	pop	r28
    5cfa:	1f 91       	pop	r17
    5cfc:	0f 91       	pop	r16
    5cfe:	ff 90       	pop	r15
    5d00:	ef 90       	pop	r14
    5d02:	df 90       	pop	r13
    5d04:	cf 90       	pop	r12
    5d06:	bf 90       	pop	r11
    5d08:	af 90       	pop	r10
    5d0a:	9f 90       	pop	r9
    5d0c:	8f 90       	pop	r8
    5d0e:	08 95       	ret

00005d10 <houseKeeping>:

/* -------------------------------------------------------------------- */
/*	Reply with some status info message									*/
/* -------------------------------------------------------------------- */
int houseKeeping(csp_packet_t * inPacket) 
{
    5d10:	4f 92       	push	r4
    5d12:	5f 92       	push	r5
    5d14:	6f 92       	push	r6
    5d16:	7f 92       	push	r7
    5d18:	8f 92       	push	r8
    5d1a:	9f 92       	push	r9
    5d1c:	af 92       	push	r10
    5d1e:	bf 92       	push	r11
    5d20:	cf 92       	push	r12
    5d22:	df 92       	push	r13
    5d24:	ef 92       	push	r14
    5d26:	ff 92       	push	r15
    5d28:	0f 93       	push	r16
    5d2a:	1f 93       	push	r17
    5d2c:	cf 93       	push	r28
    5d2e:	df 93       	push	r29
    5d30:	cd b7       	in	r28, 0x3d	; 61
    5d32:	de b7       	in	r29, 0x3e	; 62
    5d34:	c0 55       	subi	r28, 0x50	; 80
    5d36:	d1 09       	sbc	r29, r1
    5d38:	cd bf       	out	0x3d, r28	; 61
    5d3a:	de bf       	out	0x3e, r29	; 62
    5d3c:	4c 01       	movw	r8, r24

cislo.imag = 1876.45;
cislo.real = -3.47;
	// put the info message into the packet
	char msg[64];
	memset(msg,0,64);
    5d3e:	5e 01       	movw	r10, r28
    5d40:	21 e1       	ldi	r18, 0x11	; 17
    5d42:	a2 0e       	add	r10, r18
    5d44:	b1 1c       	adc	r11, r1
    5d46:	80 e4       	ldi	r24, 0x40	; 64
    5d48:	d5 01       	movw	r26, r10
    5d4a:	1d 92       	st	X+, r1
    5d4c:	8a 95       	dec	r24
    5d4e:	e9 f7       	brne	.-6      	; 0x5d4a <houseKeeping+0x3a>
	
	TC0_ConfigClockSource(&TCC0, TC_CLKSEL_OFF_gc);	// STOP RTOS
    5d50:	60 e0       	ldi	r22, 0x00	; 0
    5d52:	80 e0       	ldi	r24, 0x00	; 0
    5d54:	98 e0       	ldi	r25, 0x08	; 8
    5d56:	01 d2       	rcall	.+1026   	; 0x615a <TC0_ConfigClockSource>
	
	spi_mem_write_complex(145,cislo);
    5d58:	8b e7       	ldi	r24, 0x7B	; 123
    5d5a:	94 e1       	ldi	r25, 0x14	; 20
    5d5c:	ae e5       	ldi	r26, 0x5E	; 94
    5d5e:	b0 ec       	ldi	r27, 0xC0	; 192
    5d60:	89 83       	std	Y+1, r24	; 0x01
    5d62:	9a 83       	std	Y+2, r25	; 0x02
    5d64:	ab 83       	std	Y+3, r26	; 0x03
    5d66:	bc 83       	std	Y+4, r27	; 0x04
    5d68:	86 e6       	ldi	r24, 0x66	; 102
    5d6a:	9e e8       	ldi	r25, 0x8E	; 142
    5d6c:	aa ee       	ldi	r26, 0xEA	; 234
    5d6e:	b4 e4       	ldi	r27, 0x44	; 68
    5d70:	8d 83       	std	Y+5, r24	; 0x05
    5d72:	9e 83       	std	Y+6, r25	; 0x06
    5d74:	af 83       	std	Y+7, r26	; 0x07
    5d76:	b8 87       	std	Y+8, r27	; 0x08
    5d78:	0f 2e       	mov	r0, r31
    5d7a:	fb e7       	ldi	r31, 0x7B	; 123
    5d7c:	ef 2e       	mov	r14, r31
    5d7e:	f0 2d       	mov	r31, r0
    5d80:	fa 80       	ldd	r15, Y+2	; 0x02
    5d82:	0b 81       	ldd	r16, Y+3	; 0x03
    5d84:	1c 81       	ldd	r17, Y+4	; 0x04
    5d86:	26 e6       	ldi	r18, 0x66	; 102
    5d88:	3e 81       	ldd	r19, Y+6	; 0x06
    5d8a:	4f 81       	ldd	r20, Y+7	; 0x07
    5d8c:	58 85       	ldd	r21, Y+8	; 0x08
    5d8e:	61 e9       	ldi	r22, 0x91	; 145
    5d90:	70 e0       	ldi	r23, 0x00	; 0
    5d92:	80 e0       	ldi	r24, 0x00	; 0
    5d94:	90 e0       	ldi	r25, 0x00	; 0
    5d96:	b7 d6       	rcall	.+3438   	; 0x6b06 <spi_mem_write_complex>
	cislo_read = spi_mem_read_complex(145);
    5d98:	61 e9       	ldi	r22, 0x91	; 145
    5d9a:	70 e0       	ldi	r23, 0x00	; 0
    5d9c:	80 e0       	ldi	r24, 0x00	; 0
    5d9e:	90 e0       	ldi	r25, 0x00	; 0
    5da0:	2b d7       	rcall	.+3670   	; 0x6bf8 <spi_mem_read_complex>
    5da2:	29 87       	std	Y+9, r18	; 0x09
    5da4:	3a 87       	std	Y+10, r19	; 0x0a
    5da6:	4b 87       	std	Y+11, r20	; 0x0b
    5da8:	5c 87       	std	Y+12, r21	; 0x0c
    5daa:	6d 87       	std	Y+13, r22	; 0x0d
    5dac:	7e 87       	std	Y+14, r23	; 0x0e
    5dae:	8f 87       	std	Y+15, r24	; 0x0f
    5db0:	98 8b       	std	Y+16, r25	; 0x10
	
	
 	spi_mem_write_word(0x789,aa);
    5db2:	42 e1       	ldi	r20, 0x12	; 18
    5db4:	5d e1       	ldi	r21, 0x1D	; 29
    5db6:	69 e8       	ldi	r22, 0x89	; 137
    5db8:	77 e0       	ldi	r23, 0x07	; 7
    5dba:	80 e0       	ldi	r24, 0x00	; 0
    5dbc:	90 e0       	ldi	r25, 0x00	; 0
    5dbe:	84 d6       	rcall	.+3336   	; 0x6ac8 <spi_mem_write_word>
 	bb = spi_mem_read_word(0x789);
    5dc0:	69 e8       	ldi	r22, 0x89	; 137
    5dc2:	77 e0       	ldi	r23, 0x07	; 7
    5dc4:	80 e0       	ldi	r24, 0x00	; 0
    5dc6:	90 e0       	ldi	r25, 0x00	; 0
    5dc8:	e5 d6       	rcall	.+3530   	; 0x6b94 <spi_mem_read_word>
	if (cislo_read.imag == cislo.imag)
	{
		bb += 2;
	}

	cc = adca_read_ch0();
    5dca:	0e 94 14 39 	call	0x7228	; 0x7228 <adca_read_ch0>
	

	
	sprintf(msg, "*** Board\n\rSoftware v1.0\n\rUptime: %id %ih %im %ds\n\r", (int16_t) hoursTimer/24, (int16_t) hoursTimer%24, (int16_t) secondsTimer/60, (int16_t) secondsTimer%60);
    5dce:	80 91 ea 3d 	lds	r24, 0x3DEA
    5dd2:	90 91 eb 3d 	lds	r25, 0x3DEB
    5dd6:	a0 91 ec 3d 	lds	r26, 0x3DEC
    5dda:	b0 91 ed 3d 	lds	r27, 0x3DED
    5dde:	40 90 ea 3d 	lds	r4, 0x3DEA
    5de2:	50 90 eb 3d 	lds	r5, 0x3DEB
    5de6:	60 90 ec 3d 	lds	r6, 0x3DEC
    5dea:	70 90 ed 3d 	lds	r7, 0x3DED
    5dee:	c0 90 dc 3d 	lds	r12, 0x3DDC
    5df2:	d0 90 dd 3d 	lds	r13, 0x3DDD
    5df6:	e0 90 de 3d 	lds	r14, 0x3DDE
    5dfa:	f0 90 df 3d 	lds	r15, 0x3DDF
    5dfe:	00 91 dc 3d 	lds	r16, 0x3DDC
    5e02:	10 91 dd 3d 	lds	r17, 0x3DDD
    5e06:	20 91 de 3d 	lds	r18, 0x3DDE
    5e0a:	30 91 df 3d 	lds	r19, 0x3DDF
    5e0e:	ec e3       	ldi	r30, 0x3C	; 60
    5e10:	f0 e0       	ldi	r31, 0x00	; 0
    5e12:	bf 01       	movw	r22, r30
    5e14:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <__divmodhi4>
    5e18:	9f 93       	push	r25
    5e1a:	8f 93       	push	r24
    5e1c:	c2 01       	movw	r24, r4
    5e1e:	bf 01       	movw	r22, r30
    5e20:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <__divmodhi4>
    5e24:	7f 93       	push	r23
    5e26:	6f 93       	push	r22
    5e28:	e8 e1       	ldi	r30, 0x18	; 24
    5e2a:	f0 e0       	ldi	r31, 0x00	; 0
    5e2c:	c6 01       	movw	r24, r12
    5e2e:	bf 01       	movw	r22, r30
    5e30:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <__divmodhi4>
    5e34:	9f 93       	push	r25
    5e36:	8f 93       	push	r24
    5e38:	c8 01       	movw	r24, r16
    5e3a:	bf 01       	movw	r22, r30
    5e3c:	0e 94 ab 3f 	call	0x7f56	; 0x7f56 <__divmodhi4>
    5e40:	7f 93       	push	r23
    5e42:	6f 93       	push	r22
    5e44:	86 e0       	ldi	r24, 0x06	; 6
    5e46:	91 e2       	ldi	r25, 0x21	; 33
    5e48:	9f 93       	push	r25
    5e4a:	8f 93       	push	r24
    5e4c:	bf 92       	push	r11
    5e4e:	af 92       	push	r10
    5e50:	0e 94 d1 41 	call	0x83a2	; 0x83a2 <sprintf>
	//sprintf(msg, "*** \n\r%1.3f, %1.3f \n\r%1.3f, %1.3f, %i, ADC=%i\n\r", cislo.real, cislo.imag, cislo_read.real, cislo_read.imag, bb, cc);

	strcpy(outcomingPacket->data, msg);
    5e54:	80 91 89 3c 	lds	r24, 0x3C89
    5e58:	90 91 8a 3c 	lds	r25, 0x3C8A
    5e5c:	b5 01       	movw	r22, r10
    5e5e:	0e 96       	adiw	r24, 0x0e	; 14
    5e60:	0e 94 70 41 	call	0x82e0	; 0x82e0 <strcpy>
	outcomingPacket->length = strlen(msg);
    5e64:	c0 90 89 3c 	lds	r12, 0x3C89
    5e68:	d0 90 8a 3c 	lds	r13, 0x3C8A
    5e6c:	f5 01       	movw	r30, r10
    5e6e:	01 90       	ld	r0, Z+
    5e70:	00 20       	and	r0, r0
    5e72:	e9 f7       	brne	.-6      	; 0x5e6e <houseKeeping+0x15e>
    5e74:	31 97       	sbiw	r30, 0x01	; 1
    5e76:	ea 19       	sub	r30, r10
    5e78:	fb 09       	sbc	r31, r11
    5e7a:	d6 01       	movw	r26, r12
    5e7c:	18 96       	adiw	r26, 0x08	; 8
    5e7e:	ed 93       	st	X+, r30
    5e80:	fc 93       	st	X, r31
    5e82:	19 97       	sbiw	r26, 0x09	; 9

	/* Send packet */
	if (csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, outcomingPacket, 50) == CSP_ERR_NONE) {
    5e84:	f4 01       	movw	r30, r8
    5e86:	43 85       	ldd	r20, Z+11	; 0x0b
    5e88:	84 2f       	mov	r24, r20
    5e8a:	82 95       	swap	r24
    5e8c:	86 95       	lsr	r24
    5e8e:	86 95       	lsr	r24
    5e90:	83 70       	andi	r24, 0x03	; 3
    5e92:	24 85       	ldd	r18, Z+12	; 0x0c
    5e94:	2f 70       	andi	r18, 0x0F	; 15
    5e96:	22 0f       	add	r18, r18
    5e98:	22 0f       	add	r18, r18
    5e9a:	28 2b       	or	r18, r24
    5e9c:	4f 73       	andi	r20, 0x3F	; 63
    5e9e:	65 85       	ldd	r22, Z+13	; 0x0d
    5ea0:	66 95       	lsr	r22
    5ea2:	6f 71       	andi	r22, 0x1F	; 31
    5ea4:	0f 2e       	mov	r0, r31
    5ea6:	f2 e3       	ldi	r31, 0x32	; 50
    5ea8:	8f 2e       	mov	r8, r31
    5eaa:	91 2c       	mov	r9, r1
    5eac:	a1 2c       	mov	r10, r1
    5eae:	b1 2c       	mov	r11, r1
    5eb0:	f0 2d       	mov	r31, r0
    5eb2:	e1 2c       	mov	r14, r1
    5eb4:	f1 2c       	mov	r15, r1
    5eb6:	87 01       	movw	r16, r14
    5eb8:	82 e0       	ldi	r24, 0x02	; 2
    5eba:	0e 94 ed 23 	call	0x47da	; 0x47da <csp_sendto>
    5ebe:	cd bf       	out	0x3d, r28	; 61
    5ec0:	de bf       	out	0x3e, r29	; 62
    5ec2:	89 2b       	or	r24, r25
    5ec4:	21 f4       	brne	.+8      	; 0x5ece <houseKeeping+0x1be>
    5ec6:	88 e0       	ldi	r24, 0x08	; 8
    5ec8:	e0 e8       	ldi	r30, 0x80	; 128
    5eca:	f6 e0       	ldi	r31, 0x06	; 6
    5ecc:	87 83       	std	Z+7, r24	; 0x07
    5ece:	37 e2       	ldi	r19, 0x27	; 39
    5ed0:	84 e1       	ldi	r24, 0x14	; 20
    5ed2:	9f e0       	ldi	r25, 0x0F	; 15
    5ed4:	31 50       	subi	r19, 0x01	; 1
    5ed6:	80 40       	sbci	r24, 0x00	; 0
    5ed8:	90 40       	sbci	r25, 0x00	; 0
    5eda:	e1 f7       	brne	.-8      	; 0x5ed4 <houseKeeping+0x1c4>
    5edc:	00 c0       	rjmp	.+0      	; 0x5ede <houseKeeping+0x1ce>
    5ede:	00 00       	nop
	} else {
		/* Send failed */
	}
	_delay_ms(300);

	TC0_ConfigClockSource(&TCC0, TC_CLKSEL_DIV64_gc);	// continue RTOS
    5ee0:	65 e0       	ldi	r22, 0x05	; 5
    5ee2:	80 e0       	ldi	r24, 0x00	; 0
    5ee4:	98 e0       	ldi	r25, 0x08	; 8
    5ee6:	39 d1       	rcall	.+626    	; 0x615a <TC0_ConfigClockSource>
	
	return 0;
}
    5ee8:	80 e0       	ldi	r24, 0x00	; 0
    5eea:	90 e0       	ldi	r25, 0x00	; 0
    5eec:	c0 5b       	subi	r28, 0xB0	; 176
    5eee:	df 4f       	sbci	r29, 0xFF	; 255
    5ef0:	cd bf       	out	0x3d, r28	; 61
    5ef2:	de bf       	out	0x3e, r29	; 62
    5ef4:	df 91       	pop	r29
    5ef6:	cf 91       	pop	r28
    5ef8:	1f 91       	pop	r17
    5efa:	0f 91       	pop	r16
    5efc:	ff 90       	pop	r15
    5efe:	ef 90       	pop	r14
    5f00:	df 90       	pop	r13
    5f02:	cf 90       	pop	r12
    5f04:	bf 90       	pop	r11
    5f06:	af 90       	pop	r10
    5f08:	9f 90       	pop	r9
    5f0a:	8f 90       	pop	r8
    5f0c:	7f 90       	pop	r7
    5f0e:	6f 90       	pop	r6
    5f10:	5f 90       	pop	r5
    5f12:	4f 90       	pop	r4
    5f14:	08 95       	ret

00005f16 <echoBack>:

/* -------------------------------------------------------------------- */
/*	Sends back the incoming packet										*/
/* -------------------------------------------------------------------- */
int echoBack(csp_packet_t * inPacket) {
    5f16:	8f 92       	push	r8
    5f18:	9f 92       	push	r9
    5f1a:	af 92       	push	r10
    5f1c:	bf 92       	push	r11
    5f1e:	cf 92       	push	r12
    5f20:	df 92       	push	r13
    5f22:	ef 92       	push	r14
    5f24:	ff 92       	push	r15
    5f26:	0f 93       	push	r16
    5f28:	1f 93       	push	r17
    5f2a:	fc 01       	movw	r30, r24

	/* Send packet */
	// reuses the incoming packet for the response
	if (csp_sendto(CSP_PRIO_NORM, inPacket->id.src, inPacket->id.sport, inPacket->id.dport, CSP_O_NONE, inPacket, 1000) == CSP_ERR_NONE) {
    5f2c:	43 85       	ldd	r20, Z+11	; 0x0b
    5f2e:	84 2f       	mov	r24, r20
    5f30:	82 95       	swap	r24
    5f32:	86 95       	lsr	r24
    5f34:	86 95       	lsr	r24
    5f36:	83 70       	andi	r24, 0x03	; 3
    5f38:	24 85       	ldd	r18, Z+12	; 0x0c
    5f3a:	2f 70       	andi	r18, 0x0F	; 15
    5f3c:	22 0f       	add	r18, r18
    5f3e:	22 0f       	add	r18, r18
    5f40:	28 2b       	or	r18, r24
    5f42:	4f 73       	andi	r20, 0x3F	; 63
    5f44:	65 85       	ldd	r22, Z+13	; 0x0d
    5f46:	66 95       	lsr	r22
    5f48:	6f 71       	andi	r22, 0x1F	; 31
    5f4a:	0f 2e       	mov	r0, r31
    5f4c:	f8 ee       	ldi	r31, 0xE8	; 232
    5f4e:	8f 2e       	mov	r8, r31
    5f50:	f3 e0       	ldi	r31, 0x03	; 3
    5f52:	9f 2e       	mov	r9, r31
    5f54:	a1 2c       	mov	r10, r1
    5f56:	b1 2c       	mov	r11, r1
    5f58:	f0 2d       	mov	r31, r0
    5f5a:	6f 01       	movw	r12, r30
    5f5c:	e1 2c       	mov	r14, r1
    5f5e:	f1 2c       	mov	r15, r1
    5f60:	87 01       	movw	r16, r14
    5f62:	82 e0       	ldi	r24, 0x02	; 2
    5f64:	0e 94 ed 23 	call	0x47da	; 0x47da <csp_sendto>
    5f68:	89 2b       	or	r24, r25
    5f6a:	21 f4       	brne	.+8      	; 0x5f74 <echoBack+0x5e>
    5f6c:	88 e0       	ldi	r24, 0x08	; 8
    5f6e:	e0 e8       	ldi	r30, 0x80	; 128
    5f70:	f6 e0       	ldi	r31, 0x06	; 6
    5f72:	87 83       	std	Z+7, r24	; 0x07
	} else {
		/* Send failed */
	}

	return 0;
}
    5f74:	80 e0       	ldi	r24, 0x00	; 0
    5f76:	90 e0       	ldi	r25, 0x00	; 0
    5f78:	1f 91       	pop	r17
    5f7a:	0f 91       	pop	r16
    5f7c:	ff 90       	pop	r15
    5f7e:	ef 90       	pop	r14
    5f80:	df 90       	pop	r13
    5f82:	cf 90       	pop	r12
    5f84:	bf 90       	pop	r11
    5f86:	af 90       	pop	r10
    5f88:	9f 90       	pop	r9
    5f8a:	8f 90       	pop	r8
    5f8c:	08 95       	ret

00005f8e <mainTask>:

/* -------------------------------------------------------------------- */
/*	The main task														*/
/* -------------------------------------------------------------------- */
void mainTask(void *p) {
    5f8e:	cf 93       	push	r28
    5f90:	df 93       	push	r29
    5f92:	00 d0       	rcall	.+0      	; 0x5f94 <mainTask+0x6>
    5f94:	cd b7       	in	r28, 0x3d	; 61
    5f96:	de b7       	in	r29, 0x3e	; 62
	
	/* The variable used to receive from the queue. */
	xCSPStackEvent_t xReceivedEvent;
	
	outcomingPacket = csp_buffer_get(CSP_PACKET_SIZE);
    5f98:	88 e4       	ldi	r24, 0x48	; 72
    5f9a:	90 e0       	ldi	r25, 0x00	; 0
    5f9c:	0e 94 07 1f 	call	0x3e0e	; 0x3e0e <csp_buffer_get>
    5fa0:	80 93 89 3c 	sts	0x3C89, r24
    5fa4:	90 93 8a 3c 	sts	0x3C8A, r25
	// infinite while loop of the program 
	while (1) {
		
		// the queue between cspTask and the main task
		// this is unblocking way how to read from the queue, the last parameter is "ticks to wait"
		if (xQueueReceive(xCSPEventQueue, &xReceivedEvent, 1)) {
    5fa8:	20 e0       	ldi	r18, 0x00	; 0
    5faa:	41 e0       	ldi	r20, 0x01	; 1
    5fac:	50 e0       	ldi	r21, 0x00	; 0
    5fae:	be 01       	movw	r22, r28
    5fb0:	6f 5f       	subi	r22, 0xFF	; 255
    5fb2:	7f 4f       	sbci	r23, 0xFF	; 255
    5fb4:	80 91 01 3b 	lds	r24, 0x3B01
    5fb8:	90 91 02 3b 	lds	r25, 0x3B02
    5fbc:	0e 94 6d 12 	call	0x24da	; 0x24da <xQueueGenericReceive>
    5fc0:	88 23       	and	r24, r24
    5fc2:	91 f3       	breq	.-28     	; 0x5fa8 <mainTask+0x1a>
		
			switch( xReceivedEvent.eEventType )
    5fc4:	89 81       	ldd	r24, Y+1	; 0x01
    5fc6:	82 30       	cpi	r24, 0x02	; 2
    5fc8:	a1 f0       	breq	.+40     	; 0x5ff2 <mainTask+0x64>
    5fca:	28 f4       	brcc	.+10     	; 0x5fd6 <mainTask+0x48>
    5fcc:	88 23       	and	r24, r24
    5fce:	69 f0       	breq	.+26     	; 0x5fea <mainTask+0x5c>
    5fd0:	81 30       	cpi	r24, 0x01	; 1
    5fd2:	39 f0       	breq	.+14     	; 0x5fe2 <mainTask+0x54>
    5fd4:	e9 cf       	rjmp	.-46     	; 0x5fa8 <mainTask+0x1a>
    5fd6:	84 30       	cpi	r24, 0x04	; 4
    5fd8:	a1 f0       	breq	.+40     	; 0x6002 <mainTask+0x74>
    5fda:	78 f0       	brcs	.+30     	; 0x5ffa <mainTask+0x6c>
    5fdc:	85 30       	cpi	r24, 0x05	; 5
    5fde:	a9 f0       	breq	.+42     	; 0x600a <mainTask+0x7c>
    5fe0:	e3 cf       	rjmp	.-58     	; 0x5fa8 <mainTask+0x1a>
			{
				// Reply with RTOS free heap space
				// replies in Human Readable form
				case freeHeapEvent :
			
					sendFreeHeapSpace(xReceivedEvent.pvData);
    5fe2:	8a 81       	ldd	r24, Y+2	; 0x02
    5fe4:	9b 81       	ldd	r25, Y+3	; 0x03
    5fe6:	f4 dd       	rcall	.-1048   	; 0x5bd0 <sendFreeHeapSpace>
			
				break;
    5fe8:	df cf       	rjmp	.-66     	; 0x5fa8 <mainTask+0x1a>
			
				// Echo back the whole packet
				// incoming port => outcoming
				case echoBackEvent :
			
					echoBack(xReceivedEvent.pvData);
    5fea:	8a 81       	ldd	r24, Y+2	; 0x02
    5fec:	9b 81       	ldd	r25, Y+3	; 0x03
    5fee:	93 df       	rcall	.-218    	; 0x5f16 <echoBack>
			
				break;
    5ff0:	db cf       	rjmp	.-74     	; 0x5fa8 <mainTask+0x1a>
			
				// sends the info about the system
				case housKeepingEvent :
			
					houseKeeping(xReceivedEvent.pvData);
    5ff2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ff4:	9b 81       	ldd	r25, Y+3	; 0x03
    5ff6:	8c de       	rcall	.-744    	; 0x5d10 <houseKeeping>
			
				break;
    5ff8:	d7 cf       	rjmp	.-82     	; 0x5fa8 <mainTask+0x1a>
				
				// excite beam, measure his signal by piezo, compute FFT and attenuation
				case processAllEvent:
					processAll(xReceivedEvent.pvData);
    5ffa:	8a 81       	ldd	r24, Y+2	; 0x02
    5ffc:	9b 81       	ldd	r25, Y+3	; 0x03
    5ffe:	1b db       	rcall	.-2506   	; 0x5636 <processAll>
				break;
    6000:	d3 cf       	rjmp	.-90     	; 0x5fa8 <mainTask+0x1a>
				
				// send measured signal
				case sendSignalEvent:
					sendSignal(xReceivedEvent.pvData);
    6002:	8a 81       	ldd	r24, Y+2	; 0x02
    6004:	9b 81       	ldd	r25, Y+3	; 0x03
    6006:	9c db       	rcall	.-2248   	; 0x5740 <sendSignal>
				break;
    6008:	cf cf       	rjmp	.-98     	; 0x5fa8 <mainTask+0x1a>
				
				// send computed FFT
				case sendFFTEvent:
					sendFFT(xReceivedEvent.pvData);
    600a:	8a 81       	ldd	r24, Y+2	; 0x02
    600c:	9b 81       	ldd	r25, Y+3	; 0x03
    600e:	94 dc       	rcall	.-1752   	; 0x5938 <sendFFT>
				break;
    6010:	cb cf       	rjmp	.-106    	; 0x5fa8 <mainTask+0x1a>

00006012 <ADT_init>:

TWI_Master_t twi_adt_master;		/*!< TWI slave module. */
char adt_write_buffer[8];
	
void ADT_init(void)
{
    6012:	0f 93       	push	r16
	// Initialize TWI master for CSP
	TWI_MasterInit(&twi_adt_master, &ADT_I2C_INTERFACE, TWI_MASTER_INTLVL_LO_gc, ADT_I2C_BAUDSETTING);
    6014:	2d e4       	ldi	r18, 0x4D	; 77
    6016:	40 e4       	ldi	r20, 0x40	; 64
    6018:	60 e8       	ldi	r22, 0x80	; 128
    601a:	74 e0       	ldi	r23, 0x04	; 4
    601c:	8b e8       	ldi	r24, 0x8B	; 139
    601e:	9c e3       	ldi	r25, 0x3C	; 60
    6020:	b4 d0       	rcall	.+360    	; 0x618a <TWI_MasterInit>
	adt_write_buffer[0] = ADT_REG_CONFIGURATION;
    6022:	83 e0       	ldi	r24, 0x03	; 3
    6024:	80 93 a8 3d 	sts	0x3DA8, r24
	adt_write_buffer[1] = 0xC0;						// 16 bit, one shot (240ms), ...
    6028:	80 ec       	ldi	r24, 0xC0	; 192
    602a:	80 93 a9 3d 	sts	0x3DA9, r24
	TWI_MasterWriteRead(&twi_adt_master,ADT_I2C_ADDRESS,&adt_write_buffer,2,0);
    602e:	00 e0       	ldi	r16, 0x00	; 0
    6030:	22 e0       	ldi	r18, 0x02	; 2
    6032:	48 ea       	ldi	r20, 0xA8	; 168
    6034:	5d e3       	ldi	r21, 0x3D	; 61
    6036:	68 e4       	ldi	r22, 0x48	; 72
    6038:	8b e8       	ldi	r24, 0x8B	; 139
    603a:	9c e3       	ldi	r25, 0x3C	; 60
    603c:	b7 d0       	rcall	.+366    	; 0x61ac <TWI_MasterWriteRead>
}
    603e:	0f 91       	pop	r16
    6040:	08 95       	ret

00006042 <ADT_get_temperature>:

int ADT_get_temperature(void)
{
    6042:	0f 93       	push	r16
	int temp;
	//while(!TWI_MasterReady(&ADT_I2C_INTERFACE));
	adt_write_buffer[0] = ADT_REG_TEMPERATURE;
    6044:	10 92 a8 3d 	sts	0x3DA8, r1
	TWI_MasterWriteRead(&twi_adt_master,ADT_I2C_ADDRESS,&adt_write_buffer,1,2);		// 240 ms needed to convert temperature
    6048:	02 e0       	ldi	r16, 0x02	; 2
    604a:	21 e0       	ldi	r18, 0x01	; 1
    604c:	48 ea       	ldi	r20, 0xA8	; 168
    604e:	5d e3       	ldi	r21, 0x3D	; 61
    6050:	68 e4       	ldi	r22, 0x48	; 72
    6052:	8b e8       	ldi	r24, 0x8B	; 139
    6054:	9c e3       	ldi	r25, 0x3C	; 60
    6056:	aa d0       	rcall	.+340    	; 0x61ac <TWI_MasterWriteRead>
    6058:	2b ec       	ldi	r18, 0xCB	; 203
    605a:	80 e9       	ldi	r24, 0x90	; 144
    605c:	9c e0       	ldi	r25, 0x0C	; 12
    605e:	21 50       	subi	r18, 0x01	; 1
    6060:	80 40       	sbci	r24, 0x00	; 0
    6062:	90 40       	sbci	r25, 0x00	; 0
    6064:	e1 f7       	brne	.-8      	; 0x605e <ADT_get_temperature+0x1c>
    6066:	00 c0       	rjmp	.+0      	; 0x6068 <ADT_get_temperature+0x26>
    6068:	00 00       	nop
	
	_delay_ms(250);
	
	//while(!TWI_MasterReady(&ADT_I2C_INTERFACE));

	return (twi_adt_master.readData[0]<<8) | (twi_adt_master.readData[1]);
    606a:	20 91 8d 3d 	lds	r18, 0x3D8D
    606e:	80 91 8e 3d 	lds	r24, 0x3D8E
    6072:	90 e0       	ldi	r25, 0x00	; 0
}
    6074:	92 2b       	or	r25, r18
    6076:	0f 91       	pop	r16
    6078:	08 95       	ret

0000607a <__vector_13>:


/*!  Master Interrupt vector for ADT7420. */
ISR(ADT_I2C_TWIM)
{
    607a:	1f 92       	push	r1
    607c:	0f 92       	push	r0
    607e:	0f b6       	in	r0, 0x3f	; 63
    6080:	0f 92       	push	r0
    6082:	11 24       	eor	r1, r1
    6084:	08 b6       	in	r0, 0x38	; 56
    6086:	0f 92       	push	r0
    6088:	18 be       	out	0x38, r1	; 56
    608a:	09 b6       	in	r0, 0x39	; 57
    608c:	0f 92       	push	r0
    608e:	19 be       	out	0x39, r1	; 57
    6090:	0b b6       	in	r0, 0x3b	; 59
    6092:	0f 92       	push	r0
    6094:	1b be       	out	0x3b, r1	; 59
    6096:	2f 93       	push	r18
    6098:	3f 93       	push	r19
    609a:	4f 93       	push	r20
    609c:	5f 93       	push	r21
    609e:	6f 93       	push	r22
    60a0:	7f 93       	push	r23
    60a2:	8f 93       	push	r24
    60a4:	9f 93       	push	r25
    60a6:	af 93       	push	r26
    60a8:	bf 93       	push	r27
    60aa:	ef 93       	push	r30
    60ac:	ff 93       	push	r31
	TWI_MasterInterruptHandler(&twi_adt_master);
    60ae:	8b e8       	ldi	r24, 0x8B	; 139
    60b0:	9c e3       	ldi	r25, 0x3C	; 60
    60b2:	73 d1       	rcall	.+742    	; 0x639a <TWI_MasterInterruptHandler>
}
    60b4:	ff 91       	pop	r31
    60b6:	ef 91       	pop	r30
    60b8:	bf 91       	pop	r27
    60ba:	af 91       	pop	r26
    60bc:	9f 91       	pop	r25
    60be:	8f 91       	pop	r24
    60c0:	7f 91       	pop	r23
    60c2:	6f 91       	pop	r22
    60c4:	5f 91       	pop	r21
    60c6:	4f 91       	pop	r20
    60c8:	3f 91       	pop	r19
    60ca:	2f 91       	pop	r18
    60cc:	0f 90       	pop	r0
    60ce:	0b be       	out	0x3b, r0	; 59
    60d0:	0f 90       	pop	r0
    60d2:	09 be       	out	0x39, r0	; 57
    60d4:	0f 90       	pop	r0
    60d6:	08 be       	out	0x38, r0	; 56
    60d8:	0f 90       	pop	r0
    60da:	0f be       	out	0x3f, r0	; 63
    60dc:	0f 90       	pop	r0
    60de:	1f 90       	pop	r1
    60e0:	18 95       	reti

000060e2 <CCPWrite>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
        unsigned char PSconfig = (unsigned char) PSAfactor | PSBCfactor;
        CCPWrite( &CLK.PSCTRL, PSconfig );
    60e2:	0f 93       	push	r16
    60e4:	cf 93       	push	r28
    60e6:	df 93       	push	r29
    60e8:	1f 92       	push	r1
    60ea:	cd b7       	in	r28, 0x3d	; 61
    60ec:	de b7       	in	r29, 0x3e	; 62
    60ee:	2f b7       	in	r18, 0x3f	; 63
    60f0:	29 83       	std	Y+1, r18	; 0x01
    60f2:	f8 94       	cli
    60f4:	1b be       	out	0x3b, r1	; 59
    60f6:	fc 01       	movw	r30, r24
    60f8:	08 ed       	ldi	r16, 0xD8	; 216
    60fa:	04 bf       	out	0x34, r16	; 52
    60fc:	60 83       	st	Z, r22
    60fe:	89 81       	ldd	r24, Y+1	; 0x01
    6100:	8f bf       	out	0x3f, r24	; 63
    6102:	0f 90       	pop	r0
    6104:	df 91       	pop	r29
    6106:	cf 91       	pop	r28
    6108:	0f 91       	pop	r16
    610a:	08 95       	ret

0000610c <CLKSYS_XOSC_Config>:
    610c:	66 23       	and	r22, r22
    610e:	11 f0       	breq	.+4      	; 0x6114 <CLKSYS_XOSC_Config+0x8>
    6110:	90 e2       	ldi	r25, 0x20	; 32
    6112:	01 c0       	rjmp	.+2      	; 0x6116 <CLKSYS_XOSC_Config+0xa>
    6114:	90 e0       	ldi	r25, 0x00	; 0
    6116:	84 2b       	or	r24, r20
    6118:	89 2b       	or	r24, r25
    611a:	e0 e5       	ldi	r30, 0x50	; 80
    611c:	f0 e0       	ldi	r31, 0x00	; 0
    611e:	82 83       	std	Z+2, r24	; 0x02
    6120:	08 95       	ret

00006122 <CLKSYS_Disable>:
    6122:	e0 e5       	ldi	r30, 0x50	; 80
    6124:	f0 e0       	ldi	r31, 0x00	; 0
    6126:	90 81       	ld	r25, Z
    6128:	28 2f       	mov	r18, r24
    612a:	20 95       	com	r18
    612c:	92 23       	and	r25, r18
    612e:	90 83       	st	Z, r25
    6130:	90 81       	ld	r25, Z
    6132:	89 23       	and	r24, r25
    6134:	08 95       	ret

00006136 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
unsigned char CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    6136:	1f 93       	push	r17
    6138:	cf 93       	push	r28
    613a:	df 93       	push	r29
    613c:	18 2f       	mov	r17, r24
        unsigned char clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    613e:	c0 e4       	ldi	r28, 0x40	; 64
    6140:	d0 e0       	ldi	r29, 0x00	; 0
    6142:	68 81       	ld	r22, Y
    6144:	68 7f       	andi	r22, 0xF8	; 248
    6146:	68 2b       	or	r22, r24
        CCPWrite( &CLK.CTRL, clkCtrl );
    6148:	80 e4       	ldi	r24, 0x40	; 64
    614a:	90 e0       	ldi	r25, 0x00	; 0
    614c:	ca df       	rcall	.-108    	; 0x60e2 <CCPWrite>
        clkCtrl = ( CLK.CTRL & clockSource );
    614e:	88 81       	ld	r24, Y
        return clkCtrl;
}
    6150:	81 23       	and	r24, r17
    6152:	df 91       	pop	r29
    6154:	cf 91       	pop	r28
    6156:	1f 91       	pop	r17
    6158:	08 95       	ret

0000615a <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
    615a:	fc 01       	movw	r30, r24
    615c:	20 81       	ld	r18, Z
    615e:	20 7f       	andi	r18, 0xF0	; 240
    6160:	62 2b       	or	r22, r18
    6162:	60 83       	st	Z, r22
    6164:	08 95       	ret

00006166 <TC1_ConfigClockSource>:
    6166:	fc 01       	movw	r30, r24
    6168:	20 81       	ld	r18, Z
    616a:	20 7f       	andi	r18, 0xF0	; 240
    616c:	62 2b       	or	r22, r18
    616e:	60 83       	st	Z, r22
    6170:	08 95       	ret

00006172 <TC0_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    6172:	fc 01       	movw	r30, r24
    6174:	26 81       	ldd	r18, Z+6	; 0x06
    6176:	2c 7f       	andi	r18, 0xFC	; 252
    6178:	62 2b       	or	r22, r18
    617a:	66 83       	std	Z+6, r22	; 0x06
    617c:	08 95       	ret

0000617e <TC1_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC1_SetOverflowIntLevel( volatile TC1_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC1_OVFINTLVL_gm ) | intLevel;
    617e:	fc 01       	movw	r30, r24
    6180:	26 81       	ldd	r18, Z+6	; 0x06
    6182:	2c 7f       	andi	r18, 0xFC	; 252
    6184:	62 2b       	or	r22, r18
    6186:	66 83       	std	Z+6, r22	; 0x06
    6188:	08 95       	ret

0000618a <TWI_MasterInit>:
                    uint8_t address,
                    uint8_t bytesToRead)
{
	bool twi_status = TWI_MasterWriteRead(twi, address, 0, 0, bytesToRead);
	return twi_status;
}
    618a:	fc 01       	movw	r30, r24
    618c:	60 83       	st	Z, r22
    618e:	71 83       	std	Z+1, r23	; 0x01
    6190:	48 63       	ori	r20, 0x38	; 56
    6192:	db 01       	movw	r26, r22
    6194:	11 96       	adiw	r26, 0x01	; 1
    6196:	4c 93       	st	X, r20
    6198:	a0 81       	ld	r26, Z
    619a:	b1 81       	ldd	r27, Z+1	; 0x01
    619c:	15 96       	adiw	r26, 0x05	; 5
    619e:	2c 93       	st	X, r18
    61a0:	01 90       	ld	r0, Z+
    61a2:	f0 81       	ld	r31, Z
    61a4:	e0 2d       	mov	r30, r0
    61a6:	81 e0       	ldi	r24, 0x01	; 1
    61a8:	84 83       	std	Z+4, r24	; 0x04
    61aa:	08 95       	ret

000061ac <TWI_MasterWriteRead>:
    61ac:	0f 93       	push	r16
    61ae:	cf 93       	push	r28
    61b0:	df 93       	push	r29
    61b2:	05 31       	cpi	r16, 0x15	; 21
    61b4:	08 f0       	brcs	.+2      	; 0x61b8 <TWI_MasterWriteRead+0xc>
    61b6:	4c c0       	rjmp	.+152    	; 0x6250 <TWI_MasterWriteRead+0xa4>
    61b8:	fc 01       	movw	r30, r24
    61ba:	e6 5e       	subi	r30, 0xE6	; 230
    61bc:	fe 4f       	sbci	r31, 0xFE	; 254
    61be:	30 81       	ld	r19, Z
    61c0:	31 11       	cpse	r19, r1
    61c2:	48 c0       	rjmp	.+144    	; 0x6254 <TWI_MasterWriteRead+0xa8>
    61c4:	31 e0       	ldi	r19, 0x01	; 1
    61c6:	30 83       	st	Z, r19
    61c8:	31 96       	adiw	r30, 0x01	; 1
    61ca:	10 82       	st	Z, r1
    61cc:	66 0f       	add	r22, r22
    61ce:	dc 01       	movw	r26, r24
    61d0:	12 96       	adiw	r26, 0x02	; 2
    61d2:	6c 93       	st	X, r22
    61d4:	22 23       	and	r18, r18
    61d6:	a1 f0       	breq	.+40     	; 0x6200 <TWI_MasterWriteRead+0x54>
    61d8:	ea 01       	movw	r28, r20
    61da:	ba 01       	movw	r22, r20
    61dc:	6f 5f       	subi	r22, 0xFF	; 255
    61de:	7f 4f       	sbci	r23, 0xFF	; 255
    61e0:	3f ef       	ldi	r19, 0xFF	; 255
    61e2:	32 0f       	add	r19, r18
    61e4:	63 0f       	add	r22, r19
    61e6:	71 1d       	adc	r23, r1
    61e8:	fa 01       	movw	r30, r20
    61ea:	df 01       	movw	r26, r30
    61ec:	ac 1b       	sub	r26, r28
    61ee:	bd 0b       	sbc	r27, r29
    61f0:	31 91       	ld	r19, Z+
    61f2:	a8 0f       	add	r26, r24
    61f4:	b9 1f       	adc	r27, r25
    61f6:	13 96       	adiw	r26, 0x03	; 3
    61f8:	3c 93       	st	X, r19
    61fa:	e6 17       	cp	r30, r22
    61fc:	f7 07       	cpc	r31, r23
    61fe:	a9 f7       	brne	.-22     	; 0x61ea <TWI_MasterWriteRead+0x3e>
    6200:	fc 01       	movw	r30, r24
    6202:	ea 5e       	subi	r30, 0xEA	; 234
    6204:	fe 4f       	sbci	r31, 0xFE	; 254
    6206:	20 83       	st	Z, r18
    6208:	dc 01       	movw	r26, r24
    620a:	a9 5e       	subi	r26, 0xE9	; 233
    620c:	be 4f       	sbci	r27, 0xFE	; 254
    620e:	0c 93       	st	X, r16
    6210:	11 96       	adiw	r26, 0x01	; 1
    6212:	1c 92       	st	X, r1
    6214:	11 96       	adiw	r26, 0x01	; 1
    6216:	1c 92       	st	X, r1
    6218:	20 81       	ld	r18, Z
    621a:	22 23       	and	r18, r18
    621c:	49 f0       	breq	.+18     	; 0x6230 <TWI_MasterWriteRead+0x84>
    621e:	fc 01       	movw	r30, r24
    6220:	22 81       	ldd	r18, Z+2	; 0x02
    6222:	2e 7f       	andi	r18, 0xFE	; 254
    6224:	01 90       	ld	r0, Z+
    6226:	f0 81       	ld	r31, Z
    6228:	e0 2d       	mov	r30, r0
    622a:	26 83       	std	Z+6, r18	; 0x06
    622c:	81 e0       	ldi	r24, 0x01	; 1
    622e:	15 c0       	rjmp	.+42     	; 0x625a <TWI_MasterWriteRead+0xae>
    6230:	fc 01       	movw	r30, r24
    6232:	e9 5e       	subi	r30, 0xE9	; 233
    6234:	fe 4f       	sbci	r31, 0xFE	; 254
    6236:	20 81       	ld	r18, Z
    6238:	22 23       	and	r18, r18
    623a:	71 f0       	breq	.+28     	; 0x6258 <TWI_MasterWriteRead+0xac>
    623c:	dc 01       	movw	r26, r24
    623e:	12 96       	adiw	r26, 0x02	; 2
    6240:	2c 91       	ld	r18, X
    6242:	12 97       	sbiw	r26, 0x02	; 2
    6244:	21 60       	ori	r18, 0x01	; 1
    6246:	ed 91       	ld	r30, X+
    6248:	fc 91       	ld	r31, X
    624a:	26 83       	std	Z+6, r18	; 0x06
    624c:	81 e0       	ldi	r24, 0x01	; 1
    624e:	05 c0       	rjmp	.+10     	; 0x625a <TWI_MasterWriteRead+0xae>
    6250:	80 e0       	ldi	r24, 0x00	; 0
    6252:	03 c0       	rjmp	.+6      	; 0x625a <TWI_MasterWriteRead+0xae>
    6254:	80 e0       	ldi	r24, 0x00	; 0
    6256:	01 c0       	rjmp	.+2      	; 0x625a <TWI_MasterWriteRead+0xae>
    6258:	81 e0       	ldi	r24, 0x01	; 1
    625a:	df 91       	pop	r29
    625c:	cf 91       	pop	r28
    625e:	0f 91       	pop	r16
    6260:	08 95       	ret

00006262 <TWI_MasterWrite>:
    6262:	0f 93       	push	r16
    6264:	00 e0       	ldi	r16, 0x00	; 0
    6266:	a2 df       	rcall	.-188    	; 0x61ac <TWI_MasterWriteRead>
    6268:	0f 91       	pop	r16
    626a:	08 95       	ret

0000626c <TWI_MasterArbitrationLostBusErrorHandler>:
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterArbitrationLostBusErrorHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
    626c:	dc 01       	movw	r26, r24
    626e:	ed 91       	ld	r30, X+
    6270:	fc 91       	ld	r31, X
    6272:	11 97       	sbiw	r26, 0x01	; 1
    6274:	24 81       	ldd	r18, Z+4	; 0x04

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
    6276:	22 ff       	sbrs	r18, 2
    6278:	05 c0       	rjmp	.+10     	; 0x6284 <TWI_MasterArbitrationLostBusErrorHandler+0x18>
		twi->result = TWIM_RESULT_BUS_ERROR;
    627a:	34 e0       	ldi	r19, 0x04	; 4
    627c:	a5 5e       	subi	r26, 0xE5	; 229
    627e:	be 4f       	sbci	r27, 0xFE	; 254
    6280:	3c 93       	st	X, r19
    6282:	05 c0       	rjmp	.+10     	; 0x628e <TWI_MasterArbitrationLostBusErrorHandler+0x22>
	}
	/* If arbitration lost. */
	else {
		twi->result = TWIM_RESULT_ARBITRATION_LOST;
    6284:	33 e0       	ldi	r19, 0x03	; 3
    6286:	dc 01       	movw	r26, r24
    6288:	a5 5e       	subi	r26, 0xE5	; 229
    628a:	be 4f       	sbci	r27, 0xFE	; 254
    628c:	3c 93       	st	X, r19
	}

	/* Clear interrupt flag. */
	twi->interface->MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
    628e:	28 60       	ori	r18, 0x08	; 8
    6290:	24 83       	std	Z+4, r18	; 0x04

	twi->status = TWIM_STATUS_READY;
    6292:	fc 01       	movw	r30, r24
    6294:	e6 5e       	subi	r30, 0xE6	; 230
    6296:	fe 4f       	sbci	r31, 0xFE	; 254
    6298:	10 82       	st	Z, r1
    629a:	08 95       	ret

0000629c <TWI_MasterWriteHandler>:
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 *
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterWriteHandler(TWI_Master_t *twi)
{
    629c:	cf 93       	push	r28
    629e:	df 93       	push	r29
	/* Local variables used in if tests to avoid compiler warning. */
	uint8_t bytesToWrite  = twi->bytesToWrite;
    62a0:	fc 01       	movw	r30, r24
    62a2:	ea 5e       	subi	r30, 0xEA	; 234
    62a4:	fe 4f       	sbci	r31, 0xFE	; 254
    62a6:	30 81       	ld	r19, Z
	uint8_t bytesToRead   = twi->bytesToRead;
    62a8:	31 96       	adiw	r30, 0x01	; 1
    62aa:	40 81       	ld	r20, Z

	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (twi->interface->MASTER.STATUS & TWI_MASTER_RXACK_bm) {
    62ac:	dc 01       	movw	r26, r24
    62ae:	ed 91       	ld	r30, X+
    62b0:	fc 91       	ld	r31, X
    62b2:	24 81       	ldd	r18, Z+4	; 0x04
    62b4:	24 ff       	sbrs	r18, 4
    62b6:	0a c0       	rjmp	.+20     	; 0x62cc <TWI_MasterWriteHandler+0x30>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    62b8:	23 e0       	ldi	r18, 0x03	; 3
    62ba:	23 83       	std	Z+3, r18	; 0x03
		twi->result = TWIM_RESULT_NACK_RECEIVED;
    62bc:	fc 01       	movw	r30, r24
    62be:	e5 5e       	subi	r30, 0xE5	; 229
    62c0:	fe 4f       	sbci	r31, 0xFE	; 254
    62c2:	25 e0       	ldi	r18, 0x05	; 5
    62c4:	20 83       	st	Z, r18
		twi->status = TWIM_STATUS_READY;
    62c6:	31 97       	sbiw	r30, 0x01	; 1
    62c8:	10 82       	st	Z, r1
    62ca:	25 c0       	rjmp	.+74     	; 0x6316 <TWI_MasterWriteHandler+0x7a>
	}

	/* If more bytes to write, send data. */
	else if (twi->bytesWritten < bytesToWrite) {
    62cc:	dc 01       	movw	r26, r24
    62ce:	a8 5e       	subi	r26, 0xE8	; 232
    62d0:	be 4f       	sbci	r27, 0xFE	; 254
    62d2:	2c 91       	ld	r18, X
    62d4:	23 17       	cp	r18, r19
    62d6:	50 f4       	brcc	.+20     	; 0x62ec <TWI_MasterWriteHandler+0x50>
		uint8_t data = twi->writeData[twi->bytesWritten];
    62d8:	2c 91       	ld	r18, X
    62da:	ec 01       	movw	r28, r24
    62dc:	c2 0f       	add	r28, r18
    62de:	d1 1d       	adc	r29, r1
    62e0:	8b 81       	ldd	r24, Y+3	; 0x03
		twi->interface->MASTER.DATA = data;
    62e2:	87 83       	std	Z+7, r24	; 0x07
		++twi->bytesWritten;
    62e4:	8c 91       	ld	r24, X
    62e6:	8f 5f       	subi	r24, 0xFF	; 255
    62e8:	8c 93       	st	X, r24
    62ea:	15 c0       	rjmp	.+42     	; 0x6316 <TWI_MasterWriteHandler+0x7a>
	}

	/* If bytes to read, send repeated START condition + Address +
	 * 'R/_W = 1'
	 */
	else if (twi->bytesRead < bytesToRead) {
    62ec:	dc 01       	movw	r26, r24
    62ee:	a7 5e       	subi	r26, 0xE7	; 231
    62f0:	be 4f       	sbci	r27, 0xFE	; 254
    62f2:	2c 91       	ld	r18, X
    62f4:	24 17       	cp	r18, r20
    62f6:	30 f4       	brcc	.+12     	; 0x6304 <TWI_MasterWriteHandler+0x68>
		uint8_t readAddress = twi->address | 0x01;
    62f8:	dc 01       	movw	r26, r24
    62fa:	12 96       	adiw	r26, 0x02	; 2
    62fc:	8c 91       	ld	r24, X
    62fe:	81 60       	ori	r24, 0x01	; 1
		twi->interface->MASTER.ADDR = readAddress;
    6300:	86 83       	std	Z+6, r24	; 0x06
    6302:	09 c0       	rjmp	.+18     	; 0x6316 <TWI_MasterWriteHandler+0x7a>
	}

	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    6304:	23 e0       	ldi	r18, 0x03	; 3
    6306:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    6308:	fc 01       	movw	r30, r24
    630a:	e5 5e       	subi	r30, 0xE5	; 229
    630c:	fe 4f       	sbci	r31, 0xFE	; 254
    630e:	21 e0       	ldi	r18, 0x01	; 1
    6310:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    6312:	31 97       	sbiw	r30, 0x01	; 1
    6314:	10 82       	st	Z, r1
	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_OK);
	}
}
    6316:	df 91       	pop	r29
    6318:	cf 91       	pop	r28
    631a:	08 95       	ret

0000631c <TWI_MasterReadHandler>:
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterReadHandler(TWI_Master_t *twi)
{
	/* Fetch data if bytes to be read. */
	if (twi->bytesRead < TWIM_READ_BUFFER_SIZE) {
    631c:	fc 01       	movw	r30, r24
    631e:	e7 5e       	subi	r30, 0xE7	; 231
    6320:	fe 4f       	sbci	r31, 0xFE	; 254
    6322:	20 81       	ld	r18, Z
    6324:	24 31       	cpi	r18, 0x14	; 20
    6326:	90 f4       	brcc	.+36     	; 0x634c <TWI_MasterReadHandler+0x30>
		uint8_t data = twi->interface->MASTER.DATA;
    6328:	dc 01       	movw	r26, r24
    632a:	ed 91       	ld	r30, X+
    632c:	fc 91       	ld	r31, X
    632e:	11 97       	sbiw	r26, 0x01	; 1
    6330:	27 81       	ldd	r18, Z+7	; 0x07
		twi->readData[twi->bytesRead] = data;
    6332:	fc 01       	movw	r30, r24
    6334:	e7 5e       	subi	r30, 0xE7	; 231
    6336:	fe 4f       	sbci	r31, 0xFE	; 254
    6338:	30 81       	ld	r19, Z
    633a:	a3 0f       	add	r26, r19
    633c:	b1 1d       	adc	r27, r1
    633e:	ae 5f       	subi	r26, 0xFE	; 254
    6340:	be 4f       	sbci	r27, 0xFE	; 254
    6342:	2c 93       	st	X, r18
		twi->bytesRead++;
    6344:	20 81       	ld	r18, Z
    6346:	2f 5f       	subi	r18, 0xFF	; 255
    6348:	20 83       	st	Z, r18
    634a:	0c c0       	rjmp	.+24     	; 0x6364 <TWI_MasterReadHandler+0x48>
	}

	/* If buffer overflow, issue STOP and BUFFER_OVERFLOW condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
    634c:	dc 01       	movw	r26, r24
    634e:	ed 91       	ld	r30, X+
    6350:	fc 91       	ld	r31, X
    6352:	23 e0       	ldi	r18, 0x03	; 3
    6354:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    6356:	22 e0       	ldi	r18, 0x02	; 2
    6358:	fc 01       	movw	r30, r24
    635a:	e5 5e       	subi	r30, 0xE5	; 229
    635c:	fe 4f       	sbci	r31, 0xFE	; 254
    635e:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    6360:	31 97       	sbiw	r30, 0x01	; 1
    6362:	10 82       	st	Z, r1
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_BUFFER_OVERFLOW);
	}

	/* Local variable used in if test to avoid compiler warning. */
	uint8_t bytesToRead = twi->bytesToRead;
    6364:	fc 01       	movw	r30, r24
    6366:	e9 5e       	subi	r30, 0xE9	; 233
    6368:	fe 4f       	sbci	r31, 0xFE	; 254
    636a:	30 81       	ld	r19, Z

	/* If more bytes to read, issue ACK and start a byte read. */
	if (twi->bytesRead < bytesToRead) {
    636c:	32 96       	adiw	r30, 0x02	; 2
    636e:	20 81       	ld	r18, Z
    6370:	23 17       	cp	r18, r19
    6372:	30 f4       	brcc	.+12     	; 0x6380 <TWI_MasterReadHandler+0x64>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    6374:	dc 01       	movw	r26, r24
    6376:	ed 91       	ld	r30, X+
    6378:	fc 91       	ld	r31, X
    637a:	82 e0       	ldi	r24, 0x02	; 2
    637c:	83 83       	std	Z+3, r24	; 0x03
    637e:	08 95       	ret
	}

	/* If transaction finished, issue NACK and STOP condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm |
    6380:	dc 01       	movw	r26, r24
    6382:	ed 91       	ld	r30, X+
    6384:	fc 91       	ld	r31, X
    6386:	27 e0       	ldi	r18, 0x07	; 7
    6388:	23 83       	std	Z+3, r18	; 0x03
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    638a:	fc 01       	movw	r30, r24
    638c:	e5 5e       	subi	r30, 0xE5	; 229
    638e:	fe 4f       	sbci	r31, 0xFE	; 254
    6390:	21 e0       	ldi	r18, 0x01	; 1
    6392:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    6394:	31 97       	sbiw	r30, 0x01	; 1
    6396:	10 82       	st	Z, r1
    6398:	08 95       	ret

0000639a <TWI_MasterInterruptHandler>:
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterInterruptHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
    639a:	dc 01       	movw	r26, r24
    639c:	ed 91       	ld	r30, X+
    639e:	fc 91       	ld	r31, X
    63a0:	24 81       	ldd	r18, Z+4	; 0x04
    63a2:	32 2f       	mov	r19, r18
    63a4:	3c 70       	andi	r19, 0x0C	; 12

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
    63a6:	11 f0       	breq	.+4      	; 0x63ac <TWI_MasterInterruptHandler+0x12>
	    (currentStatus & TWI_MASTER_BUSERR_bm)) {

		TWI_MasterArbitrationLostBusErrorHandler(twi);
    63a8:	61 cf       	rjmp	.-318    	; 0x626c <TWI_MasterArbitrationLostBusErrorHandler>
    63aa:	08 95       	ret
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
    63ac:	26 ff       	sbrs	r18, 6
    63ae:	02 c0       	rjmp	.+4      	; 0x63b4 <TWI_MasterInterruptHandler+0x1a>
		TWI_MasterWriteHandler(twi);
    63b0:	75 cf       	rjmp	.-278    	; 0x629c <TWI_MasterWriteHandler>
    63b2:	08 95       	ret
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
    63b4:	22 23       	and	r18, r18
    63b6:	14 f4       	brge	.+4      	; 0x63bc <TWI_MasterInterruptHandler+0x22>
		TWI_MasterReadHandler(twi);
    63b8:	b1 cf       	rjmp	.-158    	; 0x631c <TWI_MasterReadHandler>
    63ba:	08 95       	ret
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
    63bc:	fc 01       	movw	r30, r24
    63be:	e5 5e       	subi	r30, 0xE5	; 229
    63c0:	fe 4f       	sbci	r31, 0xFE	; 254
    63c2:	26 e0       	ldi	r18, 0x06	; 6
    63c4:	20 83       	st	Z, r18
	twi->status = TWIM_STATUS_READY;
    63c6:	31 97       	sbiw	r30, 0x01	; 1
    63c8:	10 82       	st	Z, r1
    63ca:	08 95       	ret

000063cc <TWI_SlaveInitializeDriver>:
 */
void TWI_SlaveInitializeDriver(TWI_Slave_t *twi,
                               TWI_t *module,
                               void (*processDataFunction) (void))
{
	twi->interface = module;
    63cc:	fc 01       	movw	r30, r24
    63ce:	60 83       	st	Z, r22
    63d0:	71 83       	std	Z+1, r23	; 0x01
	twi->Process_Data = processDataFunction;
    63d2:	42 83       	std	Z+2, r20	; 0x02
    63d4:	53 83       	std	Z+3, r21	; 0x03
	twi->bytesReceived = 0;
    63d6:	e3 5b       	subi	r30, 0xB3	; 179
    63d8:	ff 4f       	sbci	r31, 0xFF	; 255
    63da:	10 82       	st	Z, r1
	twi->bytesSent = 0;
    63dc:	31 96       	adiw	r30, 0x01	; 1
    63de:	10 82       	st	Z, r1
	twi->status = TWIS_STATUS_READY;
    63e0:	31 96       	adiw	r30, 0x01	; 1
    63e2:	10 82       	st	Z, r1
	twi->result = TWIS_RESULT_UNKNOWN;
    63e4:	31 96       	adiw	r30, 0x01	; 1
    63e6:	10 82       	st	Z, r1
	twi->abort = false;
    63e8:	31 96       	adiw	r30, 0x01	; 1
    63ea:	10 82       	st	Z, r1
    63ec:	08 95       	ret

000063ee <TWI_SlaveInitializeModule>:
 */
void TWI_SlaveInitializeModule(TWI_Slave_t *twi,
                               uint8_t address,
                               TWI_SLAVE_INTLVL_t intLevel)
{
	twi->interface->SLAVE.CTRLA = intLevel |
    63ee:	dc 01       	movw	r26, r24
    63f0:	ed 91       	ld	r30, X+
    63f2:	fc 91       	ld	r31, X
    63f4:	11 97       	sbiw	r26, 0x01	; 1
    63f6:	48 63       	ori	r20, 0x38	; 56
    63f8:	40 87       	std	Z+8, r20	; 0x08
	                              TWI_SLAVE_DIEN_bm |
	                              TWI_SLAVE_APIEN_bm |
	                              TWI_SLAVE_ENABLE_bm;
	twi->interface->SLAVE.ADDR = (address<<1);
    63fa:	ed 91       	ld	r30, X+
    63fc:	fc 91       	ld	r31, X
    63fe:	66 0f       	add	r22, r22
    6400:	63 87       	std	Z+11, r22	; 0x0b
    6402:	08 95       	ret

00006404 <TWI_SlaveTransactionFinished>:
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
    6404:	fc 01       	movw	r30, r24
    6406:	e0 5b       	subi	r30, 0xB0	; 176
    6408:	ff 4f       	sbci	r31, 0xFF	; 255
    640a:	60 83       	st	Z, r22
	twi->status = TWIS_STATUS_READY;
    640c:	31 97       	sbiw	r30, 0x01	; 1
    640e:	10 82       	st	Z, r1
	

	/* Process data. */
	twi->Process_Data();
    6410:	dc 01       	movw	r26, r24
    6412:	12 96       	adiw	r26, 0x02	; 2
    6414:	ed 91       	ld	r30, X+
    6416:	fc 91       	ld	r31, X
    6418:	13 97       	sbiw	r26, 0x03	; 3
    641a:	19 95       	eicall
    641c:	08 95       	ret

0000641e <TWI_SlaveAddressMatchHandler>:
 *  Prepares TWI module for transaction when an address match occures.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveAddressMatchHandler(TWI_Slave_t *twi)
{
    641e:	cf 93       	push	r28
    6420:	df 93       	push	r29
    6422:	ec 01       	movw	r28, r24
	/* If application signalling need to abort (error occured). */
	if (twi->abort) {
    6424:	fc 01       	movw	r30, r24
    6426:	ef 5a       	subi	r30, 0xAF	; 175
    6428:	ff 4f       	sbci	r31, 0xFF	; 255
    642a:	80 81       	ld	r24, Z
    642c:	88 23       	and	r24, r24
    642e:	59 f0       	breq	.+22     	; 0x6446 <TWI_SlaveAddressMatchHandler+0x28>
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    6430:	e8 81       	ld	r30, Y
    6432:	f9 81       	ldd	r31, Y+1	; 0x01
    6434:	82 e0       	ldi	r24, 0x02	; 2
    6436:	81 87       	std	Z+9, r24	; 0x09
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
    6438:	66 e0       	ldi	r22, 0x06	; 6
    643a:	ce 01       	movw	r24, r28
    643c:	e3 df       	rcall	.-58     	; 0x6404 <TWI_SlaveTransactionFinished>
		twi->abort = false;
    643e:	cf 5a       	subi	r28, 0xAF	; 175
    6440:	df 4f       	sbci	r29, 0xFF	; 255
    6442:	18 82       	st	Y, r1
    6444:	16 c0       	rjmp	.+44     	; 0x6472 <TWI_SlaveAddressMatchHandler+0x54>
	} else {
		twi->status = TWIS_STATUS_BUSY;
    6446:	fe 01       	movw	r30, r28
    6448:	e1 5b       	subi	r30, 0xB1	; 177
    644a:	ff 4f       	sbci	r31, 0xFF	; 255
    644c:	81 e0       	ldi	r24, 0x01	; 1
    644e:	80 83       	st	Z, r24
		twi->result = TWIS_RESULT_UNKNOWN;
    6450:	31 96       	adiw	r30, 0x01	; 1
    6452:	10 82       	st	Z, r1

		/* Disable stop interrupt. */
		uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    6454:	e8 81       	ld	r30, Y
    6456:	f9 81       	ldd	r31, Y+1	; 0x01
    6458:	80 85       	ldd	r24, Z+8	; 0x08
		twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
    645a:	8b 7f       	andi	r24, 0xFB	; 251
    645c:	80 87       	std	Z+8, r24	; 0x08

		twi->bytesReceived = 0;
    645e:	fe 01       	movw	r30, r28
    6460:	e3 5b       	subi	r30, 0xB3	; 179
    6462:	ff 4f       	sbci	r31, 0xFF	; 255
    6464:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    6466:	31 96       	adiw	r30, 0x01	; 1
    6468:	10 82       	st	Z, r1

		/* Send ACK, wait for data interrupt. */
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    646a:	e8 81       	ld	r30, Y
    646c:	f9 81       	ldd	r31, Y+1	; 0x01
    646e:	83 e0       	ldi	r24, 0x03	; 3
    6470:	81 87       	std	Z+9, r24	; 0x09
	}
}
    6472:	df 91       	pop	r29
    6474:	cf 91       	pop	r28
    6476:	08 95       	ret

00006478 <TWI_SlaveStopHandler>:
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveStopHandler(TWI_Slave_t *twi)
{
	/* Disable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    6478:	dc 01       	movw	r26, r24
    647a:	ed 91       	ld	r30, X+
    647c:	fc 91       	ld	r31, X
    647e:	11 97       	sbiw	r26, 0x01	; 1
    6480:	20 85       	ldd	r18, Z+8	; 0x08
	twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
    6482:	2b 7f       	andi	r18, 0xFB	; 251
    6484:	20 87       	std	Z+8, r18	; 0x08
	
	/* Clear APIF, according to flowchart don't ACK or NACK */
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
    6486:	ed 91       	ld	r30, X+
    6488:	fc 91       	ld	r31, X
    648a:	22 85       	ldd	r18, Z+10	; 0x0a
	twi->interface->SLAVE.STATUS = currentStatus | TWI_SLAVE_APIF_bm;
    648c:	20 64       	ori	r18, 0x40	; 64
    648e:	22 87       	std	Z+10, r18	; 0x0a

	TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
    6490:	61 e0       	ldi	r22, 0x01	; 1
    6492:	b8 cf       	rjmp	.-144    	; 0x6404 <TWI_SlaveTransactionFinished>
    6494:	08 95       	ret

00006496 <TWI_SlaveReadHandler>:
 *  Handles TWI slave read transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveReadHandler(TWI_Slave_t *twi)
{
    6496:	cf 93       	push	r28
    6498:	df 93       	push	r29
    649a:	ec 01       	movw	r28, r24
	/* Enable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
    649c:	e8 81       	ld	r30, Y
    649e:	f9 81       	ldd	r31, Y+1	; 0x01
    64a0:	80 85       	ldd	r24, Z+8	; 0x08
	twi->interface->SLAVE.CTRLA = currentCtrlA | TWI_SLAVE_PIEN_bm;
    64a2:	84 60       	ori	r24, 0x04	; 4
    64a4:	80 87       	std	Z+8, r24	; 0x08

	/* If free space in buffer. */
	if (twi->bytesReceived < TWIS_RECEIVE_BUFFER_SIZE) {
    64a6:	fe 01       	movw	r30, r28
    64a8:	e3 5b       	subi	r30, 0xB3	; 179
    64aa:	ff 4f       	sbci	r31, 0xFF	; 255
    64ac:	80 81       	ld	r24, Z
    64ae:	88 34       	cpi	r24, 0x48	; 72
    64b0:	10 f5       	brcc	.+68     	; 0x64f6 <TWI_SlaveReadHandler+0x60>
		/* Fetch data */
		uint8_t data = twi->interface->SLAVE.DATA;
    64b2:	68 81       	ld	r22, Y
    64b4:	79 81       	ldd	r23, Y+1	; 0x01
    64b6:	db 01       	movw	r26, r22
    64b8:	1c 96       	adiw	r26, 0x0c	; 12
    64ba:	2c 91       	ld	r18, X
		twi->receivedData[twi->bytesReceived] = data;
    64bc:	80 81       	ld	r24, Z
    64be:	ae 01       	movw	r20, r28
    64c0:	48 0f       	add	r20, r24
    64c2:	51 1d       	adc	r21, r1
    64c4:	da 01       	movw	r26, r20
    64c6:	14 96       	adiw	r26, 0x04	; 4
    64c8:	2c 93       	st	X, r18

		twi->bytesReceived++;
    64ca:	80 81       	ld	r24, Z
    64cc:	8f 5f       	subi	r24, 0xFF	; 255
    64ce:	80 83       	st	Z, r24

		/* If application signalling need to abort (error occured),
		 * complete transaction and wait for next START. Otherwise
		 * send ACK and wait for data interrupt.
		 */
		if (twi->abort) {
    64d0:	34 96       	adiw	r30, 0x04	; 4
    64d2:	80 81       	ld	r24, Z
    64d4:	88 23       	and	r24, r24
    64d6:	51 f0       	breq	.+20     	; 0x64ec <TWI_SlaveReadHandler+0x56>
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    64d8:	82 e0       	ldi	r24, 0x02	; 2
    64da:	fb 01       	movw	r30, r22
    64dc:	81 87       	std	Z+9, r24	; 0x09
			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
    64de:	66 e0       	ldi	r22, 0x06	; 6
    64e0:	ce 01       	movw	r24, r28
    64e2:	90 df       	rcall	.-224    	; 0x6404 <TWI_SlaveTransactionFinished>
			twi->abort = false;
    64e4:	cf 5a       	subi	r28, 0xAF	; 175
    64e6:	df 4f       	sbci	r29, 0xFF	; 255
    64e8:	18 82       	st	Y, r1
    64ea:	0c c0       	rjmp	.+24     	; 0x6504 <TWI_SlaveReadHandler+0x6e>
		} else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    64ec:	83 e0       	ldi	r24, 0x03	; 3
    64ee:	db 01       	movw	r26, r22
    64f0:	19 96       	adiw	r26, 0x09	; 9
    64f2:	8c 93       	st	X, r24
    64f4:	07 c0       	rjmp	.+14     	; 0x6504 <TWI_SlaveReadHandler+0x6e>
	}
	/* If buffer overflow, send NACK and wait for next START. Set
	 * result buffer overflow.
	 */
	else {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
    64f6:	e8 81       	ld	r30, Y
    64f8:	f9 81       	ldd	r31, Y+1	; 0x01
    64fa:	86 e0       	ldi	r24, 0x06	; 6
    64fc:	81 87       	std	Z+9, r24	; 0x09
		                              TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
    64fe:	62 e0       	ldi	r22, 0x02	; 2
    6500:	ce 01       	movw	r24, r28
    6502:	80 df       	rcall	.-256    	; 0x6404 <TWI_SlaveTransactionFinished>
	}
}
    6504:	df 91       	pop	r29
    6506:	cf 91       	pop	r28
    6508:	08 95       	ret

0000650a <TWI_SlaveWriteHandler>:
 *  Handles TWI slave write transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveWriteHandler(TWI_Slave_t *twi)
{
    650a:	cf 93       	push	r28
    650c:	df 93       	push	r29
	/* If NACK, slave write transaction finished. */
	if ((twi->bytesSent > 0) && (twi->interface->SLAVE.STATUS &
    650e:	fc 01       	movw	r30, r24
    6510:	e2 5b       	subi	r30, 0xB2	; 178
    6512:	ff 4f       	sbci	r31, 0xFF	; 255
    6514:	20 81       	ld	r18, Z
    6516:	22 23       	and	r18, r18
    6518:	59 f0       	breq	.+22     	; 0x6530 <TWI_SlaveWriteHandler+0x26>
    651a:	dc 01       	movw	r26, r24
    651c:	ed 91       	ld	r30, X+
    651e:	fc 91       	ld	r31, X
    6520:	22 85       	ldd	r18, Z+10	; 0x0a
    6522:	24 ff       	sbrs	r18, 4
    6524:	05 c0       	rjmp	.+10     	; 0x6530 <TWI_SlaveWriteHandler+0x26>
	                             TWI_SLAVE_RXACK_bm)) {

		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    6526:	22 e0       	ldi	r18, 0x02	; 2
    6528:	21 87       	std	Z+9, r18	; 0x09
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
    652a:	61 e0       	ldi	r22, 0x01	; 1
    652c:	6b df       	rcall	.-298    	; 0x6404 <TWI_SlaveTransactionFinished>
    652e:	21 c0       	rjmp	.+66     	; 0x6572 <TWI_SlaveWriteHandler+0x68>
	}
	/* If ACK, master expects more data. */
	else {
		if (twi->bytesSent < TWIS_SEND_BUFFER_SIZE) {
    6530:	fc 01       	movw	r30, r24
    6532:	e2 5b       	subi	r30, 0xB2	; 178
    6534:	ff 4f       	sbci	r31, 0xFF	; 255
    6536:	20 81       	ld	r18, Z
    6538:	21 11       	cpse	r18, r1
    653a:	14 c0       	rjmp	.+40     	; 0x6564 <TWI_SlaveWriteHandler+0x5a>
			uint8_t data = twi->sendData[twi->bytesSent];
    653c:	20 81       	ld	r18, Z
    653e:	dc 01       	movw	r26, r24
    6540:	a2 0f       	add	r26, r18
    6542:	b1 1d       	adc	r27, r1
    6544:	a4 5b       	subi	r26, 0xB4	; 180
    6546:	bf 4f       	sbci	r27, 0xFF	; 255
    6548:	2c 91       	ld	r18, X
			twi->interface->SLAVE.DATA = data;
    654a:	ec 01       	movw	r28, r24
    654c:	a8 81       	ld	r26, Y
    654e:	b9 81       	ldd	r27, Y+1	; 0x01
    6550:	1c 96       	adiw	r26, 0x0c	; 12
    6552:	2c 93       	st	X, r18
			twi->bytesSent++;
    6554:	20 81       	ld	r18, Z
    6556:	2f 5f       	subi	r18, 0xFF	; 255
    6558:	20 83       	st	Z, r18

			/* Send data, wait for data interrupt. */
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
    655a:	e8 81       	ld	r30, Y
    655c:	f9 81       	ldd	r31, Y+1	; 0x01
    655e:	83 e0       	ldi	r24, 0x03	; 3
    6560:	81 87       	std	Z+9, r24	; 0x09
    6562:	07 c0       	rjmp	.+14     	; 0x6572 <TWI_SlaveWriteHandler+0x68>
		}
		/* If buffer overflow. */
		else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
    6564:	dc 01       	movw	r26, r24
    6566:	ed 91       	ld	r30, X+
    6568:	fc 91       	ld	r31, X
    656a:	22 e0       	ldi	r18, 0x02	; 2
    656c:	21 87       	std	Z+9, r18	; 0x09
			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
    656e:	62 e0       	ldi	r22, 0x02	; 2
    6570:	49 df       	rcall	.-366    	; 0x6404 <TWI_SlaveTransactionFinished>
		}
	}
}
    6572:	df 91       	pop	r29
    6574:	cf 91       	pop	r28
    6576:	08 95       	ret

00006578 <TWI_SlaveDataHandler>:
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveDataHandler(TWI_Slave_t *twi)
{
	if (twi->interface->SLAVE.STATUS & TWI_SLAVE_DIR_bm) {
    6578:	dc 01       	movw	r26, r24
    657a:	ed 91       	ld	r30, X+
    657c:	fc 91       	ld	r31, X
    657e:	22 85       	ldd	r18, Z+10	; 0x0a
    6580:	21 ff       	sbrs	r18, 1
    6582:	02 c0       	rjmp	.+4      	; 0x6588 <TWI_SlaveDataHandler+0x10>
		TWI_SlaveWriteHandler(twi);
    6584:	c2 cf       	rjmp	.-124    	; 0x650a <TWI_SlaveWriteHandler>
    6586:	08 95       	ret
	} else {
		TWI_SlaveReadHandler(twi);
    6588:	86 cf       	rjmp	.-244    	; 0x6496 <TWI_SlaveReadHandler>
    658a:	08 95       	ret

0000658c <TWI_SlaveInterruptHandler>:
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveInterruptHandler(TWI_Slave_t *twi)
{
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
    658c:	dc 01       	movw	r26, r24
    658e:	ed 91       	ld	r30, X+
    6590:	fc 91       	ld	r31, X
    6592:	22 85       	ldd	r18, Z+10	; 0x0a

	/* If bus error. */
	if (currentStatus & TWI_SLAVE_BUSERR_bm) {
    6594:	22 ff       	sbrs	r18, 2
    6596:	0c c0       	rjmp	.+24     	; 0x65b0 <TWI_SlaveInterruptHandler+0x24>
		twi->bytesReceived = 0;
    6598:	fc 01       	movw	r30, r24
    659a:	e3 5b       	subi	r30, 0xB3	; 179
    659c:	ff 4f       	sbci	r31, 0xFF	; 255
    659e:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    65a0:	31 96       	adiw	r30, 0x01	; 1
    65a2:	10 82       	st	Z, r1
		twi->result = TWIS_RESULT_BUS_ERROR;
    65a4:	32 96       	adiw	r30, 0x02	; 2
    65a6:	24 e0       	ldi	r18, 0x04	; 4
    65a8:	20 83       	st	Z, r18
		twi->status = TWIS_STATUS_READY;
    65aa:	31 97       	sbiw	r30, 0x01	; 1
    65ac:	10 82       	st	Z, r1
    65ae:	08 95       	ret
	}

	/* If transmit collision. */
	else if (currentStatus & TWI_SLAVE_COLL_bm) {
    65b0:	23 ff       	sbrs	r18, 3
    65b2:	0c c0       	rjmp	.+24     	; 0x65cc <TWI_SlaveInterruptHandler+0x40>
		twi->bytesReceived = 0;
    65b4:	fc 01       	movw	r30, r24
    65b6:	e3 5b       	subi	r30, 0xB3	; 179
    65b8:	ff 4f       	sbci	r31, 0xFF	; 255
    65ba:	10 82       	st	Z, r1
		twi->bytesSent = 0;
    65bc:	31 96       	adiw	r30, 0x01	; 1
    65be:	10 82       	st	Z, r1
		twi->result = TWIS_RESULT_TRANSMIT_COLLISION;
    65c0:	32 96       	adiw	r30, 0x02	; 2
    65c2:	23 e0       	ldi	r18, 0x03	; 3
    65c4:	20 83       	st	Z, r18
		twi->status = TWIS_STATUS_READY;
    65c6:	31 97       	sbiw	r30, 0x01	; 1
    65c8:	10 82       	st	Z, r1
    65ca:	08 95       	ret
	}

	/* If address match. */
	else if ((currentStatus & TWI_SLAVE_APIF_bm) &&
    65cc:	42 2f       	mov	r20, r18
    65ce:	40 74       	andi	r20, 0x40	; 64
    65d0:	32 2f       	mov	r19, r18
    65d2:	31 74       	andi	r19, 0x41	; 65
    65d4:	31 34       	cpi	r19, 0x41	; 65
    65d6:	11 f4       	brne	.+4      	; 0x65dc <TWI_SlaveInterruptHandler+0x50>
	        (currentStatus & TWI_SLAVE_AP_bm)) {

		TWI_SlaveAddressMatchHandler(twi);
    65d8:	22 cf       	rjmp	.-444    	; 0x641e <TWI_SlaveAddressMatchHandler>
    65da:	08 95       	ret
	}

	/* If stop (only enabled through slave read transaction). */
	else if (currentStatus & TWI_SLAVE_APIF_bm) {
    65dc:	44 23       	and	r20, r20
    65de:	11 f0       	breq	.+4      	; 0x65e4 <TWI_SlaveInterruptHandler+0x58>
		TWI_SlaveStopHandler(twi);
    65e0:	4b cf       	rjmp	.-362    	; 0x6478 <TWI_SlaveStopHandler>
    65e2:	08 95       	ret
	}

	/* If data interrupt. */
	else if (currentStatus & TWI_SLAVE_DIF_bm) {
    65e4:	22 23       	and	r18, r18
    65e6:	14 f4       	brge	.+4      	; 0x65ec <TWI_SlaveInterruptHandler+0x60>
		TWI_SlaveDataHandler(twi);
    65e8:	c7 cf       	rjmp	.-114    	; 0x6578 <TWI_SlaveDataHandler>
    65ea:	08 95       	ret
	}

	/* If unexpected state. */
	else {
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_FAIL);
    65ec:	65 e0       	ldi	r22, 0x05	; 5
    65ee:	0a cf       	rjmp	.-492    	; 0x6404 <TWI_SlaveTransactionFinished>
    65f0:	08 95       	ret

000065f2 <__vector_25>:
 *  as argument.
 */
ISR(USARTC0_RXC_vect){ if( USART_RXComplete(usartBufferC) ) taskYIELD(); }
ISR(USARTD0_RXC_vect){ if( USART_RXComplete(usartBufferD) ) taskYIELD(); }
ISR(USARTE0_RXC_vect){ if( USART_RXComplete(usartBufferE) ) taskYIELD(); }
ISR(USARTF0_RXC_vect){ if( USART_RXComplete(usartBufferF) ) taskYIELD(); }
    65f2:	1f 92       	push	r1
    65f4:	0f 92       	push	r0
    65f6:	0f b6       	in	r0, 0x3f	; 63
    65f8:	0f 92       	push	r0
    65fa:	11 24       	eor	r1, r1
    65fc:	08 b6       	in	r0, 0x38	; 56
    65fe:	0f 92       	push	r0
    6600:	18 be       	out	0x38, r1	; 56
    6602:	09 b6       	in	r0, 0x39	; 57
    6604:	0f 92       	push	r0
    6606:	19 be       	out	0x39, r1	; 57
    6608:	0a b6       	in	r0, 0x3a	; 58
    660a:	0f 92       	push	r0
    660c:	1a be       	out	0x3a, r1	; 58
    660e:	0b b6       	in	r0, 0x3b	; 59
    6610:	0f 92       	push	r0
    6612:	1b be       	out	0x3b, r1	; 59
    6614:	2f 93       	push	r18
    6616:	3f 93       	push	r19
    6618:	4f 93       	push	r20
    661a:	5f 93       	push	r21
    661c:	6f 93       	push	r22
    661e:	7f 93       	push	r23
    6620:	8f 93       	push	r24
    6622:	9f 93       	push	r25
    6624:	af 93       	push	r26
    6626:	bf 93       	push	r27
    6628:	ef 93       	push	r30
    662a:	ff 93       	push	r31
    662c:	cf 93       	push	r28
    662e:	df 93       	push	r29
    6630:	1f 92       	push	r1
    6632:	1f 92       	push	r1
    6634:	cd b7       	in	r28, 0x3d	; 61
    6636:	de b7       	in	r29, 0x3e	; 62
    6638:	e0 91 b6 3d 	lds	r30, 0x3DB6
    663c:	f0 91 b7 3d 	lds	r31, 0x3DB7
    6640:	1a 82       	std	Y+2, r1	; 0x02
    6642:	a0 81       	ld	r26, Z
    6644:	b1 81       	ldd	r27, Z+1	; 0x01
    6646:	8c 91       	ld	r24, X
    6648:	89 83       	std	Y+1, r24	; 0x01
    664a:	20 e0       	ldi	r18, 0x00	; 0
    664c:	ae 01       	movw	r20, r28
    664e:	4e 5f       	subi	r20, 0xFE	; 254
    6650:	5f 4f       	sbci	r21, 0xFF	; 255
    6652:	be 01       	movw	r22, r28
    6654:	6f 5f       	subi	r22, 0xFF	; 255
    6656:	7f 4f       	sbci	r23, 0xFF	; 255
    6658:	83 81       	ldd	r24, Z+3	; 0x03
    665a:	94 81       	ldd	r25, Z+4	; 0x04
    665c:	0e 94 3b 12 	call	0x2476	; 0x2476 <xQueueGenericSendFromISR>
    6660:	8a 81       	ldd	r24, Y+2	; 0x02
    6662:	81 11       	cpse	r24, r1
    6664:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vPortYield>
    6668:	0f 90       	pop	r0
    666a:	0f 90       	pop	r0
    666c:	df 91       	pop	r29
    666e:	cf 91       	pop	r28
    6670:	ff 91       	pop	r31
    6672:	ef 91       	pop	r30
    6674:	bf 91       	pop	r27
    6676:	af 91       	pop	r26
    6678:	9f 91       	pop	r25
    667a:	8f 91       	pop	r24
    667c:	7f 91       	pop	r23
    667e:	6f 91       	pop	r22
    6680:	5f 91       	pop	r21
    6682:	4f 91       	pop	r20
    6684:	3f 91       	pop	r19
    6686:	2f 91       	pop	r18
    6688:	0f 90       	pop	r0
    668a:	0b be       	out	0x3b, r0	; 59
    668c:	0f 90       	pop	r0
    668e:	0a be       	out	0x3a, r0	; 58
    6690:	0f 90       	pop	r0
    6692:	09 be       	out	0x39, r0	; 57
    6694:	0f 90       	pop	r0
    6696:	08 be       	out	0x38, r0	; 56
    6698:	0f 90       	pop	r0
    669a:	0f be       	out	0x3f, r0	; 63
    669c:	0f 90       	pop	r0
    669e:	1f 90       	pop	r1
    66a0:	18 95       	reti

000066a2 <__vector_88>:
    66a2:	1f 92       	push	r1
    66a4:	0f 92       	push	r0
    66a6:	0f b6       	in	r0, 0x3f	; 63
    66a8:	0f 92       	push	r0
    66aa:	11 24       	eor	r1, r1
    66ac:	08 b6       	in	r0, 0x38	; 56
    66ae:	0f 92       	push	r0
    66b0:	18 be       	out	0x38, r1	; 56
    66b2:	09 b6       	in	r0, 0x39	; 57
    66b4:	0f 92       	push	r0
    66b6:	19 be       	out	0x39, r1	; 57
    66b8:	0a b6       	in	r0, 0x3a	; 58
    66ba:	0f 92       	push	r0
    66bc:	1a be       	out	0x3a, r1	; 58
    66be:	0b b6       	in	r0, 0x3b	; 59
    66c0:	0f 92       	push	r0
    66c2:	1b be       	out	0x3b, r1	; 59
    66c4:	2f 93       	push	r18
    66c6:	3f 93       	push	r19
    66c8:	4f 93       	push	r20
    66ca:	5f 93       	push	r21
    66cc:	6f 93       	push	r22
    66ce:	7f 93       	push	r23
    66d0:	8f 93       	push	r24
    66d2:	9f 93       	push	r25
    66d4:	af 93       	push	r26
    66d6:	bf 93       	push	r27
    66d8:	ef 93       	push	r30
    66da:	ff 93       	push	r31
    66dc:	cf 93       	push	r28
    66de:	df 93       	push	r29
    66e0:	1f 92       	push	r1
    66e2:	1f 92       	push	r1
    66e4:	cd b7       	in	r28, 0x3d	; 61
    66e6:	de b7       	in	r29, 0x3e	; 62
    66e8:	e0 91 b4 3d 	lds	r30, 0x3DB4
    66ec:	f0 91 b5 3d 	lds	r31, 0x3DB5
    66f0:	1a 82       	std	Y+2, r1	; 0x02
    66f2:	a0 81       	ld	r26, Z
    66f4:	b1 81       	ldd	r27, Z+1	; 0x01
    66f6:	8c 91       	ld	r24, X
    66f8:	89 83       	std	Y+1, r24	; 0x01
    66fa:	20 e0       	ldi	r18, 0x00	; 0
    66fc:	ae 01       	movw	r20, r28
    66fe:	4e 5f       	subi	r20, 0xFE	; 254
    6700:	5f 4f       	sbci	r21, 0xFF	; 255
    6702:	be 01       	movw	r22, r28
    6704:	6f 5f       	subi	r22, 0xFF	; 255
    6706:	7f 4f       	sbci	r23, 0xFF	; 255
    6708:	83 81       	ldd	r24, Z+3	; 0x03
    670a:	94 81       	ldd	r25, Z+4	; 0x04
    670c:	0e 94 3b 12 	call	0x2476	; 0x2476 <xQueueGenericSendFromISR>
    6710:	8a 81       	ldd	r24, Y+2	; 0x02
    6712:	81 11       	cpse	r24, r1
    6714:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vPortYield>
    6718:	0f 90       	pop	r0
    671a:	0f 90       	pop	r0
    671c:	df 91       	pop	r29
    671e:	cf 91       	pop	r28
    6720:	ff 91       	pop	r31
    6722:	ef 91       	pop	r30
    6724:	bf 91       	pop	r27
    6726:	af 91       	pop	r26
    6728:	9f 91       	pop	r25
    672a:	8f 91       	pop	r24
    672c:	7f 91       	pop	r23
    672e:	6f 91       	pop	r22
    6730:	5f 91       	pop	r21
    6732:	4f 91       	pop	r20
    6734:	3f 91       	pop	r19
    6736:	2f 91       	pop	r18
    6738:	0f 90       	pop	r0
    673a:	0b be       	out	0x3b, r0	; 59
    673c:	0f 90       	pop	r0
    673e:	0a be       	out	0x3a, r0	; 58
    6740:	0f 90       	pop	r0
    6742:	09 be       	out	0x39, r0	; 57
    6744:	0f 90       	pop	r0
    6746:	08 be       	out	0x38, r0	; 56
    6748:	0f 90       	pop	r0
    674a:	0f be       	out	0x3f, r0	; 63
    674c:	0f 90       	pop	r0
    674e:	1f 90       	pop	r1
    6750:	18 95       	reti

00006752 <__vector_58>:
    6752:	1f 92       	push	r1
    6754:	0f 92       	push	r0
    6756:	0f b6       	in	r0, 0x3f	; 63
    6758:	0f 92       	push	r0
    675a:	11 24       	eor	r1, r1
    675c:	08 b6       	in	r0, 0x38	; 56
    675e:	0f 92       	push	r0
    6760:	18 be       	out	0x38, r1	; 56
    6762:	09 b6       	in	r0, 0x39	; 57
    6764:	0f 92       	push	r0
    6766:	19 be       	out	0x39, r1	; 57
    6768:	0a b6       	in	r0, 0x3a	; 58
    676a:	0f 92       	push	r0
    676c:	1a be       	out	0x3a, r1	; 58
    676e:	0b b6       	in	r0, 0x3b	; 59
    6770:	0f 92       	push	r0
    6772:	1b be       	out	0x3b, r1	; 59
    6774:	2f 93       	push	r18
    6776:	3f 93       	push	r19
    6778:	4f 93       	push	r20
    677a:	5f 93       	push	r21
    677c:	6f 93       	push	r22
    677e:	7f 93       	push	r23
    6780:	8f 93       	push	r24
    6782:	9f 93       	push	r25
    6784:	af 93       	push	r26
    6786:	bf 93       	push	r27
    6788:	ef 93       	push	r30
    678a:	ff 93       	push	r31
    678c:	cf 93       	push	r28
    678e:	df 93       	push	r29
    6790:	1f 92       	push	r1
    6792:	1f 92       	push	r1
    6794:	cd b7       	in	r28, 0x3d	; 61
    6796:	de b7       	in	r29, 0x3e	; 62
    6798:	e0 91 b2 3d 	lds	r30, 0x3DB2
    679c:	f0 91 b3 3d 	lds	r31, 0x3DB3
    67a0:	1a 82       	std	Y+2, r1	; 0x02
    67a2:	a0 81       	ld	r26, Z
    67a4:	b1 81       	ldd	r27, Z+1	; 0x01
    67a6:	8c 91       	ld	r24, X
    67a8:	89 83       	std	Y+1, r24	; 0x01
    67aa:	20 e0       	ldi	r18, 0x00	; 0
    67ac:	ae 01       	movw	r20, r28
    67ae:	4e 5f       	subi	r20, 0xFE	; 254
    67b0:	5f 4f       	sbci	r21, 0xFF	; 255
    67b2:	be 01       	movw	r22, r28
    67b4:	6f 5f       	subi	r22, 0xFF	; 255
    67b6:	7f 4f       	sbci	r23, 0xFF	; 255
    67b8:	83 81       	ldd	r24, Z+3	; 0x03
    67ba:	94 81       	ldd	r25, Z+4	; 0x04
    67bc:	0e 94 3b 12 	call	0x2476	; 0x2476 <xQueueGenericSendFromISR>
    67c0:	8a 81       	ldd	r24, Y+2	; 0x02
    67c2:	81 11       	cpse	r24, r1
    67c4:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <vPortYield>
    67c8:	0f 90       	pop	r0
    67ca:	0f 90       	pop	r0
    67cc:	df 91       	pop	r29
    67ce:	cf 91       	pop	r28
    67d0:	ff 91       	pop	r31
    67d2:	ef 91       	pop	r30
    67d4:	bf 91       	pop	r27
    67d6:	af 91       	pop	r26
    67d8:	9f 91       	pop	r25
    67da:	8f 91       	pop	r24
    67dc:	7f 91       	pop	r23
    67de:	6f 91       	pop	r22
    67e0:	5f 91       	pop	r21
    67e2:	4f 91       	pop	r20
    67e4:	3f 91       	pop	r19
    67e6:	2f 91       	pop	r18
    67e8:	0f 90       	pop	r0
    67ea:	0b be       	out	0x3b, r0	; 59
    67ec:	0f 90       	pop	r0
    67ee:	0a be       	out	0x3a, r0	; 58
    67f0:	0f 90       	pop	r0
    67f2:	09 be       	out	0x39, r0	; 57
    67f4:	0f 90       	pop	r0
    67f6:	08 be       	out	0x38, r0	; 56
    67f8:	0f 90       	pop	r0
    67fa:	0f be       	out	0x3f, r0	; 63
    67fc:	0f 90       	pop	r0
    67fe:	1f 90       	pop	r1
    6800:	18 95       	reti

00006802 <__vector_26>:
 *
 *  Data register empty  interrupt service routine.
 *  Calls the common data register empty complete handler with pointer to the
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
    6802:	1f 92       	push	r1
    6804:	0f 92       	push	r0
    6806:	0f b6       	in	r0, 0x3f	; 63
    6808:	0f 92       	push	r0
    680a:	11 24       	eor	r1, r1
    680c:	08 b6       	in	r0, 0x38	; 56
    680e:	0f 92       	push	r0
    6810:	18 be       	out	0x38, r1	; 56
    6812:	09 b6       	in	r0, 0x39	; 57
    6814:	0f 92       	push	r0
    6816:	19 be       	out	0x39, r1	; 57
    6818:	0a b6       	in	r0, 0x3a	; 58
    681a:	0f 92       	push	r0
    681c:	1a be       	out	0x3a, r1	; 58
    681e:	0b b6       	in	r0, 0x3b	; 59
    6820:	0f 92       	push	r0
    6822:	1b be       	out	0x3b, r1	; 59
    6824:	0f 93       	push	r16
    6826:	1f 93       	push	r17
    6828:	2f 93       	push	r18
    682a:	3f 93       	push	r19
    682c:	4f 93       	push	r20
    682e:	5f 93       	push	r21
    6830:	6f 93       	push	r22
    6832:	7f 93       	push	r23
    6834:	8f 93       	push	r24
    6836:	9f 93       	push	r25
    6838:	af 93       	push	r26
    683a:	bf 93       	push	r27
    683c:	ef 93       	push	r30
    683e:	ff 93       	push	r31
    6840:	cf 93       	push	r28
    6842:	df 93       	push	r29
    6844:	1f 92       	push	r1
    6846:	1f 92       	push	r1
    6848:	cd b7       	in	r28, 0x3d	; 61
    684a:	de b7       	in	r29, 0x3e	; 62
    684c:	00 91 b6 3d 	lds	r16, 0x3DB6
    6850:	10 91 b7 3d 	lds	r17, 0x3DB7
 *  \param usart_struct      The USART_struct_t struct instance.
 */
inline signed char USART_DataRegEmpty(UsartBuffer * usartBuffer)
{
	signed char cChar, cTaskWoken;
		if( xQueueReceiveFromISR( usartBuffer->xQueueTX, &cChar, &cTaskWoken ) == pdTRUE )
    6854:	ae 01       	movw	r20, r28
    6856:	4f 5f       	subi	r20, 0xFF	; 255
    6858:	5f 4f       	sbci	r21, 0xFF	; 255
    685a:	be 01       	movw	r22, r28
    685c:	6e 5f       	subi	r22, 0xFE	; 254
    685e:	7f 4f       	sbci	r23, 0xFF	; 255
    6860:	d8 01       	movw	r26, r16
    6862:	15 96       	adiw	r26, 0x05	; 5
    6864:	8d 91       	ld	r24, X+
    6866:	9c 91       	ld	r25, X
    6868:	16 97       	sbiw	r26, 0x06	; 6
    686a:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueReceiveFromISR>
    686e:	81 30       	cpi	r24, 0x01	; 1
    6870:	31 f4       	brne	.+12     	; 0x687e <__vector_26+0x7c>
		{
			/* Send the next character queued for Tx. */
			usartBuffer->usart->DATA = cChar;
    6872:	d8 01       	movw	r26, r16
    6874:	ed 91       	ld	r30, X+
    6876:	fc 91       	ld	r31, X
    6878:	8a 81       	ldd	r24, Y+2	; 0x02
    687a:	80 83       	st	Z, r24
    687c:	06 c0       	rjmp	.+12     	; 0x688a <__vector_26+0x88>
		}
		else
		{
			/* Queue empty, nothing to send. */
		    /* Disable DRE interrupts. */
			uint8_t tempCTRLA = usartBuffer->usart->CTRLA;
    687e:	d8 01       	movw	r26, r16
    6880:	ed 91       	ld	r30, X+
    6882:	fc 91       	ld	r31, X
    6884:	83 81       	ldd	r24, Z+3	; 0x03
			tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
    6886:	8c 7f       	andi	r24, 0xFC	; 252
			usartBuffer->usart->CTRLA = tempCTRLA;
    6888:	83 83       	std	Z+3, r24	; 0x03
 *
 *  Data register empty  interrupt service routine.
 *  Calls the common data register empty complete handler with pointer to the
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
    688a:	0f 90       	pop	r0
    688c:	0f 90       	pop	r0
    688e:	df 91       	pop	r29
    6890:	cf 91       	pop	r28
    6892:	ff 91       	pop	r31
    6894:	ef 91       	pop	r30
    6896:	bf 91       	pop	r27
    6898:	af 91       	pop	r26
    689a:	9f 91       	pop	r25
    689c:	8f 91       	pop	r24
    689e:	7f 91       	pop	r23
    68a0:	6f 91       	pop	r22
    68a2:	5f 91       	pop	r21
    68a4:	4f 91       	pop	r20
    68a6:	3f 91       	pop	r19
    68a8:	2f 91       	pop	r18
    68aa:	1f 91       	pop	r17
    68ac:	0f 91       	pop	r16
    68ae:	0f 90       	pop	r0
    68b0:	0b be       	out	0x3b, r0	; 59
    68b2:	0f 90       	pop	r0
    68b4:	0a be       	out	0x3a, r0	; 58
    68b6:	0f 90       	pop	r0
    68b8:	09 be       	out	0x39, r0	; 57
    68ba:	0f 90       	pop	r0
    68bc:	08 be       	out	0x38, r0	; 56
    68be:	0f 90       	pop	r0
    68c0:	0f be       	out	0x3f, r0	; 63
    68c2:	0f 90       	pop	r0
    68c4:	1f 90       	pop	r1
    68c6:	18 95       	reti

000068c8 <__vector_89>:
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
    68c8:	1f 92       	push	r1
    68ca:	0f 92       	push	r0
    68cc:	0f b6       	in	r0, 0x3f	; 63
    68ce:	0f 92       	push	r0
    68d0:	11 24       	eor	r1, r1
    68d2:	08 b6       	in	r0, 0x38	; 56
    68d4:	0f 92       	push	r0
    68d6:	18 be       	out	0x38, r1	; 56
    68d8:	09 b6       	in	r0, 0x39	; 57
    68da:	0f 92       	push	r0
    68dc:	19 be       	out	0x39, r1	; 57
    68de:	0a b6       	in	r0, 0x3a	; 58
    68e0:	0f 92       	push	r0
    68e2:	1a be       	out	0x3a, r1	; 58
    68e4:	0b b6       	in	r0, 0x3b	; 59
    68e6:	0f 92       	push	r0
    68e8:	1b be       	out	0x3b, r1	; 59
    68ea:	0f 93       	push	r16
    68ec:	1f 93       	push	r17
    68ee:	2f 93       	push	r18
    68f0:	3f 93       	push	r19
    68f2:	4f 93       	push	r20
    68f4:	5f 93       	push	r21
    68f6:	6f 93       	push	r22
    68f8:	7f 93       	push	r23
    68fa:	8f 93       	push	r24
    68fc:	9f 93       	push	r25
    68fe:	af 93       	push	r26
    6900:	bf 93       	push	r27
    6902:	ef 93       	push	r30
    6904:	ff 93       	push	r31
    6906:	cf 93       	push	r28
    6908:	df 93       	push	r29
    690a:	1f 92       	push	r1
    690c:	1f 92       	push	r1
    690e:	cd b7       	in	r28, 0x3d	; 61
    6910:	de b7       	in	r29, 0x3e	; 62
    6912:	00 91 b4 3d 	lds	r16, 0x3DB4
    6916:	10 91 b5 3d 	lds	r17, 0x3DB5
 *  \param usart_struct      The USART_struct_t struct instance.
 */
inline signed char USART_DataRegEmpty(UsartBuffer * usartBuffer)
{
	signed char cChar, cTaskWoken;
		if( xQueueReceiveFromISR( usartBuffer->xQueueTX, &cChar, &cTaskWoken ) == pdTRUE )
    691a:	ae 01       	movw	r20, r28
    691c:	4f 5f       	subi	r20, 0xFF	; 255
    691e:	5f 4f       	sbci	r21, 0xFF	; 255
    6920:	be 01       	movw	r22, r28
    6922:	6e 5f       	subi	r22, 0xFE	; 254
    6924:	7f 4f       	sbci	r23, 0xFF	; 255
    6926:	d8 01       	movw	r26, r16
    6928:	15 96       	adiw	r26, 0x05	; 5
    692a:	8d 91       	ld	r24, X+
    692c:	9c 91       	ld	r25, X
    692e:	16 97       	sbiw	r26, 0x06	; 6
    6930:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueReceiveFromISR>
    6934:	81 30       	cpi	r24, 0x01	; 1
    6936:	31 f4       	brne	.+12     	; 0x6944 <__vector_89+0x7c>
		{
			/* Send the next character queued for Tx. */
			usartBuffer->usart->DATA = cChar;
    6938:	d8 01       	movw	r26, r16
    693a:	ed 91       	ld	r30, X+
    693c:	fc 91       	ld	r31, X
    693e:	8a 81       	ldd	r24, Y+2	; 0x02
    6940:	80 83       	st	Z, r24
    6942:	06 c0       	rjmp	.+12     	; 0x6950 <__vector_89+0x88>
		}
		else
		{
			/* Queue empty, nothing to send. */
		    /* Disable DRE interrupts. */
			uint8_t tempCTRLA = usartBuffer->usart->CTRLA;
    6944:	d8 01       	movw	r26, r16
    6946:	ed 91       	ld	r30, X+
    6948:	fc 91       	ld	r31, X
    694a:	83 81       	ldd	r24, Z+3	; 0x03
			tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
    694c:	8c 7f       	andi	r24, 0xFC	; 252
			usartBuffer->usart->CTRLA = tempCTRLA;
    694e:	83 83       	std	Z+3, r24	; 0x03
 *  Data register empty  interrupt service routine.
 *  Calls the common data register empty complete handler with pointer to the
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
    6950:	0f 90       	pop	r0
    6952:	0f 90       	pop	r0
    6954:	df 91       	pop	r29
    6956:	cf 91       	pop	r28
    6958:	ff 91       	pop	r31
    695a:	ef 91       	pop	r30
    695c:	bf 91       	pop	r27
    695e:	af 91       	pop	r26
    6960:	9f 91       	pop	r25
    6962:	8f 91       	pop	r24
    6964:	7f 91       	pop	r23
    6966:	6f 91       	pop	r22
    6968:	5f 91       	pop	r21
    696a:	4f 91       	pop	r20
    696c:	3f 91       	pop	r19
    696e:	2f 91       	pop	r18
    6970:	1f 91       	pop	r17
    6972:	0f 91       	pop	r16
    6974:	0f 90       	pop	r0
    6976:	0b be       	out	0x3b, r0	; 59
    6978:	0f 90       	pop	r0
    697a:	0a be       	out	0x3a, r0	; 58
    697c:	0f 90       	pop	r0
    697e:	09 be       	out	0x39, r0	; 57
    6980:	0f 90       	pop	r0
    6982:	08 be       	out	0x38, r0	; 56
    6984:	0f 90       	pop	r0
    6986:	0f be       	out	0x3f, r0	; 63
    6988:	0f 90       	pop	r0
    698a:	1f 90       	pop	r1
    698c:	18 95       	reti

0000698e <__vector_59>:
ISR(USARTE0_DRE_vect){USART_DataRegEmpty(usartBufferE);}
    698e:	1f 92       	push	r1
    6990:	0f 92       	push	r0
    6992:	0f b6       	in	r0, 0x3f	; 63
    6994:	0f 92       	push	r0
    6996:	11 24       	eor	r1, r1
    6998:	08 b6       	in	r0, 0x38	; 56
    699a:	0f 92       	push	r0
    699c:	18 be       	out	0x38, r1	; 56
    699e:	09 b6       	in	r0, 0x39	; 57
    69a0:	0f 92       	push	r0
    69a2:	19 be       	out	0x39, r1	; 57
    69a4:	0a b6       	in	r0, 0x3a	; 58
    69a6:	0f 92       	push	r0
    69a8:	1a be       	out	0x3a, r1	; 58
    69aa:	0b b6       	in	r0, 0x3b	; 59
    69ac:	0f 92       	push	r0
    69ae:	1b be       	out	0x3b, r1	; 59
    69b0:	0f 93       	push	r16
    69b2:	1f 93       	push	r17
    69b4:	2f 93       	push	r18
    69b6:	3f 93       	push	r19
    69b8:	4f 93       	push	r20
    69ba:	5f 93       	push	r21
    69bc:	6f 93       	push	r22
    69be:	7f 93       	push	r23
    69c0:	8f 93       	push	r24
    69c2:	9f 93       	push	r25
    69c4:	af 93       	push	r26
    69c6:	bf 93       	push	r27
    69c8:	ef 93       	push	r30
    69ca:	ff 93       	push	r31
    69cc:	cf 93       	push	r28
    69ce:	df 93       	push	r29
    69d0:	1f 92       	push	r1
    69d2:	1f 92       	push	r1
    69d4:	cd b7       	in	r28, 0x3d	; 61
    69d6:	de b7       	in	r29, 0x3e	; 62
    69d8:	00 91 b2 3d 	lds	r16, 0x3DB2
    69dc:	10 91 b3 3d 	lds	r17, 0x3DB3
 *  \param usart_struct      The USART_struct_t struct instance.
 */
inline signed char USART_DataRegEmpty(UsartBuffer * usartBuffer)
{
	signed char cChar, cTaskWoken;
		if( xQueueReceiveFromISR( usartBuffer->xQueueTX, &cChar, &cTaskWoken ) == pdTRUE )
    69e0:	ae 01       	movw	r20, r28
    69e2:	4f 5f       	subi	r20, 0xFF	; 255
    69e4:	5f 4f       	sbci	r21, 0xFF	; 255
    69e6:	be 01       	movw	r22, r28
    69e8:	6e 5f       	subi	r22, 0xFE	; 254
    69ea:	7f 4f       	sbci	r23, 0xFF	; 255
    69ec:	d8 01       	movw	r26, r16
    69ee:	15 96       	adiw	r26, 0x05	; 5
    69f0:	8d 91       	ld	r24, X+
    69f2:	9c 91       	ld	r25, X
    69f4:	16 97       	sbiw	r26, 0x06	; 6
    69f6:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueReceiveFromISR>
    69fa:	81 30       	cpi	r24, 0x01	; 1
    69fc:	31 f4       	brne	.+12     	; 0x6a0a <__vector_59+0x7c>
		{
			/* Send the next character queued for Tx. */
			usartBuffer->usart->DATA = cChar;
    69fe:	d8 01       	movw	r26, r16
    6a00:	ed 91       	ld	r30, X+
    6a02:	fc 91       	ld	r31, X
    6a04:	8a 81       	ldd	r24, Y+2	; 0x02
    6a06:	80 83       	st	Z, r24
    6a08:	06 c0       	rjmp	.+12     	; 0x6a16 <__vector_59+0x88>
		}
		else
		{
			/* Queue empty, nothing to send. */
		    /* Disable DRE interrupts. */
			uint8_t tempCTRLA = usartBuffer->usart->CTRLA;
    6a0a:	d8 01       	movw	r26, r16
    6a0c:	ed 91       	ld	r30, X+
    6a0e:	fc 91       	ld	r31, X
    6a10:	83 81       	ldd	r24, Z+3	; 0x03
			tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
    6a12:	8c 7f       	andi	r24, 0xFC	; 252
			usartBuffer->usart->CTRLA = tempCTRLA;
    6a14:	83 83       	std	Z+3, r24	; 0x03
 *  Calls the common data register empty complete handler with pointer to the
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
ISR(USARTE0_DRE_vect){USART_DataRegEmpty(usartBufferE);}
    6a16:	0f 90       	pop	r0
    6a18:	0f 90       	pop	r0
    6a1a:	df 91       	pop	r29
    6a1c:	cf 91       	pop	r28
    6a1e:	ff 91       	pop	r31
    6a20:	ef 91       	pop	r30
    6a22:	bf 91       	pop	r27
    6a24:	af 91       	pop	r26
    6a26:	9f 91       	pop	r25
    6a28:	8f 91       	pop	r24
    6a2a:	7f 91       	pop	r23
    6a2c:	6f 91       	pop	r22
    6a2e:	5f 91       	pop	r21
    6a30:	4f 91       	pop	r20
    6a32:	3f 91       	pop	r19
    6a34:	2f 91       	pop	r18
    6a36:	1f 91       	pop	r17
    6a38:	0f 91       	pop	r16
    6a3a:	0f 90       	pop	r0
    6a3c:	0b be       	out	0x3b, r0	; 59
    6a3e:	0f 90       	pop	r0
    6a40:	0a be       	out	0x3a, r0	; 58
    6a42:	0f 90       	pop	r0
    6a44:	09 be       	out	0x39, r0	; 57
    6a46:	0f 90       	pop	r0
    6a48:	08 be       	out	0x38, r0	; 56
    6a4a:	0f 90       	pop	r0
    6a4c:	0f be       	out	0x3f, r0	; 63
    6a4e:	0f 90       	pop	r0
    6a50:	1f 90       	pop	r1
    6a52:	18 95       	reti

00006a54 <spi_mem_init>:
	spi_deselect_device(&SPI_MEM_INTERFACE, &spi_device_conf);
	
	//memcpy(&data,buffer_memory,1);
	
	return buffer_memory[0];
}
    6a54:	cf 92       	push	r12
    6a56:	df 92       	push	r13
    6a58:	ef 92       	push	r14
    6a5a:	ff 92       	push	r15
    6a5c:	0f 93       	push	r16
    6a5e:	1f 93       	push	r17
    6a60:	43 e0       	ldi	r20, 0x03	; 3
    6a62:	50 e0       	ldi	r21, 0x00	; 0
    6a64:	60 e1       	ldi	r22, 0x10	; 16
    6a66:	80 e4       	ldi	r24, 0x40	; 64
    6a68:	96 e0       	ldi	r25, 0x06	; 6
    6a6a:	c7 d4       	rcall	.+2446   	; 0x73fa <ioport_configure_port_pin>
    6a6c:	43 e0       	ldi	r20, 0x03	; 3
    6a6e:	50 e0       	ldi	r21, 0x00	; 0
    6a70:	60 e2       	ldi	r22, 0x20	; 32
    6a72:	80 e4       	ldi	r24, 0x40	; 64
    6a74:	96 e0       	ldi	r25, 0x06	; 6
    6a76:	c1 d4       	rcall	.+2434   	; 0x73fa <ioport_configure_port_pin>
    6a78:	40 e0       	ldi	r20, 0x00	; 0
    6a7a:	50 e0       	ldi	r21, 0x00	; 0
    6a7c:	60 e4       	ldi	r22, 0x40	; 64
    6a7e:	80 e4       	ldi	r24, 0x40	; 64
    6a80:	96 e0       	ldi	r25, 0x06	; 6
    6a82:	bb d4       	rcall	.+2422   	; 0x73fa <ioport_configure_port_pin>
    6a84:	43 e0       	ldi	r20, 0x03	; 3
    6a86:	50 e0       	ldi	r21, 0x00	; 0
    6a88:	60 e8       	ldi	r22, 0x80	; 128
    6a8a:	80 e4       	ldi	r24, 0x40	; 64
    6a8c:	96 e0       	ldi	r25, 0x06	; 6
    6a8e:	b5 d4       	rcall	.+2410   	; 0x73fa <ioport_configure_port_pin>
    6a90:	80 ec       	ldi	r24, 0xC0	; 192
    6a92:	98 e0       	ldi	r25, 0x08	; 8
    6a94:	f9 d0       	rcall	.+498    	; 0x6c88 <spi_master_init>
    6a96:	c1 2c       	mov	r12, r1
    6a98:	d1 2c       	mov	r13, r1
    6a9a:	76 01       	movw	r14, r12
    6a9c:	00 e8       	ldi	r16, 0x80	; 128
    6a9e:	14 e8       	ldi	r17, 0x84	; 132
    6aa0:	2e e1       	ldi	r18, 0x1E	; 30
    6aa2:	30 e0       	ldi	r19, 0x00	; 0
    6aa4:	40 e0       	ldi	r20, 0x00	; 0
    6aa6:	6e e6       	ldi	r22, 0x6E	; 110
    6aa8:	70 e2       	ldi	r23, 0x20	; 32
    6aaa:	80 ec       	ldi	r24, 0xC0	; 192
    6aac:	98 e0       	ldi	r25, 0x08	; 8
    6aae:	03 d1       	rcall	.+518    	; 0x6cb6 <spi_master_setup_device>
    6ab0:	e0 ec       	ldi	r30, 0xC0	; 192
    6ab2:	f8 e0       	ldi	r31, 0x08	; 8
    6ab4:	80 81       	ld	r24, Z
    6ab6:	80 64       	ori	r24, 0x40	; 64
    6ab8:	80 83       	st	Z, r24
    6aba:	1f 91       	pop	r17
    6abc:	0f 91       	pop	r16
    6abe:	ff 90       	pop	r15
    6ac0:	ef 90       	pop	r14
    6ac2:	df 90       	pop	r13
    6ac4:	cf 90       	pop	r12
    6ac6:	08 95       	ret

00006ac8 <spi_mem_write_word>:
    6ac8:	92 e0       	ldi	r25, 0x02	; 2
    6aca:	90 93 b8 3d 	sts	0x3DB8, r25
    6ace:	80 93 b9 3d 	sts	0x3DB9, r24
    6ad2:	70 93 ba 3d 	sts	0x3DBA, r23
    6ad6:	60 93 bb 3d 	sts	0x3DBB, r22
    6ada:	50 93 bc 3d 	sts	0x3DBC, r21
    6ade:	40 93 bd 3d 	sts	0x3DBD, r20
    6ae2:	6e e6       	ldi	r22, 0x6E	; 110
    6ae4:	70 e2       	ldi	r23, 0x20	; 32
    6ae6:	80 ec       	ldi	r24, 0xC0	; 192
    6ae8:	98 e0       	ldi	r25, 0x08	; 8
    6aea:	26 d1       	rcall	.+588    	; 0x6d38 <spi_select_device>
    6aec:	46 e0       	ldi	r20, 0x06	; 6
    6aee:	50 e0       	ldi	r21, 0x00	; 0
    6af0:	68 eb       	ldi	r22, 0xB8	; 184
    6af2:	7d e3       	ldi	r23, 0x3D	; 61
    6af4:	80 ec       	ldi	r24, 0xC0	; 192
    6af6:	98 e0       	ldi	r25, 0x08	; 8
    6af8:	fd d0       	rcall	.+506    	; 0x6cf4 <spi_write_packet>
    6afa:	6e e6       	ldi	r22, 0x6E	; 110
    6afc:	70 e2       	ldi	r23, 0x20	; 32
    6afe:	80 ec       	ldi	r24, 0xC0	; 192
    6b00:	98 e0       	ldi	r25, 0x08	; 8
    6b02:	30 c1       	rjmp	.+608    	; 0x6d64 <spi_deselect_device>
    6b04:	08 95       	ret

00006b06 <spi_mem_write_complex>:
    6b06:	ef 92       	push	r14
    6b08:	ff 92       	push	r15
    6b0a:	0f 93       	push	r16
    6b0c:	1f 93       	push	r17
    6b0e:	cf 93       	push	r28
    6b10:	df 93       	push	r29
    6b12:	cd b7       	in	r28, 0x3d	; 61
    6b14:	de b7       	in	r29, 0x3e	; 62
    6b16:	28 97       	sbiw	r28, 0x08	; 8
    6b18:	cd bf       	out	0x3d, r28	; 61
    6b1a:	de bf       	out	0x3e, r29	; 62
    6b1c:	e9 82       	std	Y+1, r14	; 0x01
    6b1e:	fa 82       	std	Y+2, r15	; 0x02
    6b20:	0b 83       	std	Y+3, r16	; 0x03
    6b22:	1c 83       	std	Y+4, r17	; 0x04
    6b24:	2d 83       	std	Y+5, r18	; 0x05
    6b26:	3e 83       	std	Y+6, r19	; 0x06
    6b28:	4f 83       	std	Y+7, r20	; 0x07
    6b2a:	58 87       	std	Y+8, r21	; 0x08
    6b2c:	92 e0       	ldi	r25, 0x02	; 2
    6b2e:	90 93 b8 3d 	sts	0x3DB8, r25
    6b32:	80 93 b9 3d 	sts	0x3DB9, r24
    6b36:	70 93 ba 3d 	sts	0x3DBA, r23
    6b3a:	60 93 bb 3d 	sts	0x3DBB, r22
    6b3e:	6e e6       	ldi	r22, 0x6E	; 110
    6b40:	70 e2       	ldi	r23, 0x20	; 32
    6b42:	80 ec       	ldi	r24, 0xC0	; 192
    6b44:	98 e0       	ldi	r25, 0x08	; 8
    6b46:	f8 d0       	rcall	.+496    	; 0x6d38 <spi_select_device>
    6b48:	44 e0       	ldi	r20, 0x04	; 4
    6b4a:	50 e0       	ldi	r21, 0x00	; 0
    6b4c:	68 eb       	ldi	r22, 0xB8	; 184
    6b4e:	7d e3       	ldi	r23, 0x3D	; 61
    6b50:	80 ec       	ldi	r24, 0xC0	; 192
    6b52:	98 e0       	ldi	r25, 0x08	; 8
    6b54:	cf d0       	rcall	.+414    	; 0x6cf4 <spi_write_packet>
    6b56:	88 e0       	ldi	r24, 0x08	; 8
    6b58:	fe 01       	movw	r30, r28
    6b5a:	31 96       	adiw	r30, 0x01	; 1
    6b5c:	a8 eb       	ldi	r26, 0xB8	; 184
    6b5e:	bd e3       	ldi	r27, 0x3D	; 61
    6b60:	01 90       	ld	r0, Z+
    6b62:	0d 92       	st	X+, r0
    6b64:	8a 95       	dec	r24
    6b66:	e1 f7       	brne	.-8      	; 0x6b60 <spi_mem_write_complex+0x5a>
    6b68:	48 e0       	ldi	r20, 0x08	; 8
    6b6a:	50 e0       	ldi	r21, 0x00	; 0
    6b6c:	68 eb       	ldi	r22, 0xB8	; 184
    6b6e:	7d e3       	ldi	r23, 0x3D	; 61
    6b70:	80 ec       	ldi	r24, 0xC0	; 192
    6b72:	98 e0       	ldi	r25, 0x08	; 8
    6b74:	bf d0       	rcall	.+382    	; 0x6cf4 <spi_write_packet>
    6b76:	6e e6       	ldi	r22, 0x6E	; 110
    6b78:	70 e2       	ldi	r23, 0x20	; 32
    6b7a:	80 ec       	ldi	r24, 0xC0	; 192
    6b7c:	98 e0       	ldi	r25, 0x08	; 8
    6b7e:	f2 d0       	rcall	.+484    	; 0x6d64 <spi_deselect_device>
    6b80:	28 96       	adiw	r28, 0x08	; 8
    6b82:	cd bf       	out	0x3d, r28	; 61
    6b84:	de bf       	out	0x3e, r29	; 62
    6b86:	df 91       	pop	r29
    6b88:	cf 91       	pop	r28
    6b8a:	1f 91       	pop	r17
    6b8c:	0f 91       	pop	r16
    6b8e:	ff 90       	pop	r15
    6b90:	ef 90       	pop	r14
    6b92:	08 95       	ret

00006b94 <spi_mem_read_word>:
    6b94:	0f 93       	push	r16
    6b96:	1f 93       	push	r17
    6b98:	cf 93       	push	r28
    6b9a:	df 93       	push	r29
    6b9c:	08 eb       	ldi	r16, 0xB8	; 184
    6b9e:	1d e3       	ldi	r17, 0x3D	; 61
    6ba0:	93 e0       	ldi	r25, 0x03	; 3
    6ba2:	f8 01       	movw	r30, r16
    6ba4:	90 83       	st	Z, r25
    6ba6:	c9 eb       	ldi	r28, 0xB9	; 185
    6ba8:	dd e3       	ldi	r29, 0x3D	; 61
    6baa:	88 83       	st	Y, r24
    6bac:	70 93 ba 3d 	sts	0x3DBA, r23
    6bb0:	60 93 bb 3d 	sts	0x3DBB, r22
    6bb4:	6e e6       	ldi	r22, 0x6E	; 110
    6bb6:	70 e2       	ldi	r23, 0x20	; 32
    6bb8:	80 ec       	ldi	r24, 0xC0	; 192
    6bba:	98 e0       	ldi	r25, 0x08	; 8
    6bbc:	bd d0       	rcall	.+378    	; 0x6d38 <spi_select_device>
    6bbe:	44 e0       	ldi	r20, 0x04	; 4
    6bc0:	50 e0       	ldi	r21, 0x00	; 0
    6bc2:	b8 01       	movw	r22, r16
    6bc4:	80 ec       	ldi	r24, 0xC0	; 192
    6bc6:	98 e0       	ldi	r25, 0x08	; 8
    6bc8:	95 d0       	rcall	.+298    	; 0x6cf4 <spi_write_packet>
    6bca:	42 e0       	ldi	r20, 0x02	; 2
    6bcc:	50 e0       	ldi	r21, 0x00	; 0
    6bce:	b8 01       	movw	r22, r16
    6bd0:	80 ec       	ldi	r24, 0xC0	; 192
    6bd2:	98 e0       	ldi	r25, 0x08	; 8
    6bd4:	9e d0       	rcall	.+316    	; 0x6d12 <spi_read_packet>
    6bd6:	6e e6       	ldi	r22, 0x6E	; 110
    6bd8:	70 e2       	ldi	r23, 0x20	; 32
    6bda:	80 ec       	ldi	r24, 0xC0	; 192
    6bdc:	98 e0       	ldi	r25, 0x08	; 8
    6bde:	c2 d0       	rcall	.+388    	; 0x6d64 <spi_deselect_device>
    6be0:	f8 01       	movw	r30, r16
    6be2:	80 81       	ld	r24, Z
    6be4:	90 e0       	ldi	r25, 0x00	; 0
    6be6:	98 2f       	mov	r25, r24
    6be8:	88 27       	eor	r24, r24
    6bea:	28 81       	ld	r18, Y
    6bec:	82 2b       	or	r24, r18
    6bee:	df 91       	pop	r29
    6bf0:	cf 91       	pop	r28
    6bf2:	1f 91       	pop	r17
    6bf4:	0f 91       	pop	r16
    6bf6:	08 95       	ret

00006bf8 <spi_mem_read_complex>:

complex spi_mem_read_complex(unsigned long address)
{
    6bf8:	cf 93       	push	r28
    6bfa:	df 93       	push	r29
    6bfc:	cd b7       	in	r28, 0x3d	; 61
    6bfe:	de b7       	in	r29, 0x3e	; 62
    6c00:	60 97       	sbiw	r28, 0x10	; 16
    6c02:	cd bf       	out	0x3d, r28	; 61
    6c04:	de bf       	out	0x3e, r29	; 62
	complex data;
	//memcpy(buffer_memory,&address,4);
	buffer_memory[0] = SPI_READ;
    6c06:	93 e0       	ldi	r25, 0x03	; 3
    6c08:	90 93 b8 3d 	sts	0x3DB8, r25
 	buffer_memory[1] = ((address & 0xFF0000) >> 16);
    6c0c:	80 93 b9 3d 	sts	0x3DB9, r24
 	buffer_memory[2] = ((address & 0x00FF00) >> 8);
    6c10:	70 93 ba 3d 	sts	0x3DBA, r23
 	buffer_memory[3] = ((address & 0x0000FF));
    6c14:	60 93 bb 3d 	sts	0x3DBB, r22
	
	spi_select_device(&SPI_MEM_INTERFACE, &spi_device_conf);
    6c18:	6e e6       	ldi	r22, 0x6E	; 110
    6c1a:	70 e2       	ldi	r23, 0x20	; 32
    6c1c:	80 ec       	ldi	r24, 0xC0	; 192
    6c1e:	98 e0       	ldi	r25, 0x08	; 8
    6c20:	8b d0       	rcall	.+278    	; 0x6d38 <spi_select_device>
	spi_write_packet(&SPI_MEM_INTERFACE, buffer_memory, 4);
    6c22:	44 e0       	ldi	r20, 0x04	; 4
    6c24:	50 e0       	ldi	r21, 0x00	; 0
    6c26:	68 eb       	ldi	r22, 0xB8	; 184
    6c28:	7d e3       	ldi	r23, 0x3D	; 61
    6c2a:	80 ec       	ldi	r24, 0xC0	; 192
    6c2c:	98 e0       	ldi	r25, 0x08	; 8
    6c2e:	62 d0       	rcall	.+196    	; 0x6cf4 <spi_write_packet>
	spi_read_packet(&SPI_MEM_INTERFACE, buffer_memory, 8);
    6c30:	48 e0       	ldi	r20, 0x08	; 8
    6c32:	50 e0       	ldi	r21, 0x00	; 0
    6c34:	68 eb       	ldi	r22, 0xB8	; 184
    6c36:	7d e3       	ldi	r23, 0x3D	; 61
    6c38:	80 ec       	ldi	r24, 0xC0	; 192
    6c3a:	98 e0       	ldi	r25, 0x08	; 8
    6c3c:	6a d0       	rcall	.+212    	; 0x6d12 <spi_read_packet>
	spi_deselect_device(&SPI_MEM_INTERFACE, &spi_device_conf);
    6c3e:	6e e6       	ldi	r22, 0x6E	; 110
    6c40:	70 e2       	ldi	r23, 0x20	; 32
    6c42:	80 ec       	ldi	r24, 0xC0	; 192
    6c44:	98 e0       	ldi	r25, 0x08	; 8
    6c46:	8e d0       	rcall	.+284    	; 0x6d64 <spi_deselect_device>
	
	memcpy(&data,buffer_memory,8);
    6c48:	88 e0       	ldi	r24, 0x08	; 8
    6c4a:	e8 eb       	ldi	r30, 0xB8	; 184
    6c4c:	fd e3       	ldi	r31, 0x3D	; 61
    6c4e:	de 01       	movw	r26, r28
    6c50:	19 96       	adiw	r26, 0x09	; 9
    6c52:	01 90       	ld	r0, Z+
    6c54:	0d 92       	st	X+, r0
    6c56:	8a 95       	dec	r24
    6c58:	e1 f7       	brne	.-8      	; 0x6c52 <spi_mem_read_complex+0x5a>
			
	return data;
    6c5a:	88 e0       	ldi	r24, 0x08	; 8
    6c5c:	fe 01       	movw	r30, r28
    6c5e:	39 96       	adiw	r30, 0x09	; 9
    6c60:	de 01       	movw	r26, r28
    6c62:	11 96       	adiw	r26, 0x01	; 1
    6c64:	01 90       	ld	r0, Z+
    6c66:	0d 92       	st	X+, r0
    6c68:	8a 95       	dec	r24
    6c6a:	e1 f7       	brne	.-8      	; 0x6c64 <spi_mem_read_complex+0x6c>
    6c6c:	29 81       	ldd	r18, Y+1	; 0x01
    6c6e:	3a 81       	ldd	r19, Y+2	; 0x02
    6c70:	4b 81       	ldd	r20, Y+3	; 0x03
    6c72:	5c 81       	ldd	r21, Y+4	; 0x04
    6c74:	6d 81       	ldd	r22, Y+5	; 0x05
    6c76:	7e 81       	ldd	r23, Y+6	; 0x06
}
    6c78:	8f 81       	ldd	r24, Y+7	; 0x07
    6c7a:	98 85       	ldd	r25, Y+8	; 0x08
    6c7c:	60 96       	adiw	r28, 0x10	; 16
    6c7e:	cd bf       	out	0x3d, r28	; 61
    6c80:	de bf       	out	0x3e, r29	; 62
    6c82:	df 91       	pop	r29
    6c84:	cf 91       	pop	r28
    6c86:	08 95       	ret

00006c88 <spi_master_init>:
 *
 * \param spi       Base address of the SPI instance.
 *
 */
void spi_master_init(SPI_t *spi)
{
    6c88:	cf 93       	push	r28
    6c8a:	df 93       	push	r29
    6c8c:	ec 01       	movw	r28, r24
	if ((uint16_t)spi == (uint16_t)&SPIB) {
		sysclk_enable_module(SYSCLK_PORT_B, PR_SPI_bm);
	}
#endif
#ifdef SPIC
	if ((uint16_t)spi == (uint16_t)&SPIC) {
    6c8e:	c0 3c       	cpi	r28, 0xC0	; 192
    6c90:	28 e0       	ldi	r18, 0x08	; 8
    6c92:	d2 07       	cpc	r29, r18
    6c94:	21 f4       	brne	.+8      	; 0x6c9e <spi_master_init+0x16>
		sysclk_enable_module(SYSCLK_PORT_C, PR_SPI_bm);
    6c96:	68 e0       	ldi	r22, 0x08	; 8
    6c98:	83 e0       	ldi	r24, 0x03	; 3
    6c9a:	a3 d3       	rcall	.+1862   	; 0x73e2 <sysclk_enable_module>
    6c9c:	06 c0       	rjmp	.+12     	; 0x6caa <spi_master_init+0x22>
	}
#endif
#ifdef SPID
	if ((uint16_t)spi == (uint16_t)&SPID) {
    6c9e:	80 3c       	cpi	r24, 0xC0	; 192
    6ca0:	99 40       	sbci	r25, 0x09	; 9
    6ca2:	19 f4       	brne	.+6      	; 0x6caa <spi_master_init+0x22>
		sysclk_enable_module(SYSCLK_PORT_D, PR_SPI_bm);
    6ca4:	68 e0       	ldi	r22, 0x08	; 8
    6ca6:	84 e0       	ldi	r24, 0x04	; 4
    6ca8:	9c d3       	rcall	.+1848   	; 0x73e2 <sysclk_enable_module>
 *
 * \warning This may cause data loss if used on a slave SPI.
 */
static inline void spi_enable_master_mode(SPI_t *spi)
{
	spi->CTRL |= SPI_MASTER_bm;
    6caa:	88 81       	ld	r24, Y
    6cac:	80 61       	ori	r24, 0x10	; 16
    6cae:	88 83       	st	Y, r24
	if ((uint16_t)spi == (uint16_t)&SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, PR_SPI_bm);
	}
#endif
	spi_enable_master_mode(spi);
}
    6cb0:	df 91       	pop	r29
    6cb2:	cf 91       	pop	r28
    6cb4:	08 95       	ret

00006cb6 <spi_master_setup_device>:
 * \param sel_id    Board specific select id
 */
void spi_master_setup_device(SPI_t *spi, struct spi_device *device,
		spi_flags_t flags, uint32_t baud_rate,
		board_spi_select_id_t sel_id)
{
    6cb6:	ff 92       	push	r15
    6cb8:	0f 93       	push	r16
    6cba:	1f 93       	push	r17
    6cbc:	cf 93       	push	r28
    6cbe:	df 93       	push	r29
    6cc0:	ec 01       	movw	r28, r24
    6cc2:	f4 2e       	mov	r15, r20
    6cc4:	b9 01       	movw	r22, r18
    6cc6:	a8 01       	movw	r20, r16
	if (spi_xmega_set_baud_div(spi, baud_rate, sysclk_get_cpu_hz()) < 0) {
    6cc8:	00 e0       	ldi	r16, 0x00	; 0
    6cca:	18 e4       	ldi	r17, 0x48	; 72
    6ccc:	28 ee       	ldi	r18, 0xE8	; 232
    6cce:	31 e0       	ldi	r19, 0x01	; 1
    6cd0:	53 d1       	rcall	.+678    	; 0x6f78 <spi_xmega_set_baud_div>
    6cd2:	88 23       	and	r24, r24
    6cd4:	4c f0       	brlt	.+18     	; 0x6ce8 <spi_master_setup_device+0x32>
		Assert(false);
		return;
	}

	/* Clear any set SPI mode flags and set them to the user-specified mode */
	spi->CTRL = (spi->CTRL & ~SPI_MODE_gm) |
    6cd6:	88 81       	ld	r24, Y
			((flags << SPI_MODE_gp) & SPI_MODE_gm);
    6cd8:	9f 2d       	mov	r25, r15
    6cda:	99 0f       	add	r25, r25
    6cdc:	99 0f       	add	r25, r25
		Assert(false);
		return;
	}

	/* Clear any set SPI mode flags and set them to the user-specified mode */
	spi->CTRL = (spi->CTRL & ~SPI_MODE_gm) |
    6cde:	9c 70       	andi	r25, 0x0C	; 12
    6ce0:	83 7f       	andi	r24, 0xF3	; 243
    6ce2:	f9 2e       	mov	r15, r25
    6ce4:	f8 2a       	or	r15, r24
    6ce6:	f8 82       	st	Y, r15
			((flags << SPI_MODE_gp) & SPI_MODE_gm);
}
    6ce8:	df 91       	pop	r29
    6cea:	cf 91       	pop	r28
    6cec:	1f 91       	pop	r17
    6cee:	0f 91       	pop	r16
    6cf0:	ff 90       	pop	r15
    6cf2:	08 95       	ret

00006cf4 <spi_write_packet>:
 * \param len    Length of data
 *
 * \pre SPI device must be selected with spi_select_device() first
 */
status_code_t spi_write_packet(SPI_t *spi, const uint8_t *data, size_t len)
{
    6cf4:	fc 01       	movw	r30, r24
    6cf6:	db 01       	movw	r26, r22
    6cf8:	46 0f       	add	r20, r22
    6cfa:	57 1f       	adc	r21, r23
	while (len--) {
    6cfc:	05 c0       	rjmp	.+10     	; 0x6d08 <spi_write_packet+0x14>
		spi_write_single(spi, *data++);
    6cfe:	8d 91       	ld	r24, X+
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(SPI_t *spi, uint8_t data)
{
	spi->DATA = data;
    6d00:	83 83       	std	Z+3, r24	; 0x03
 *
 * \return \c 1 if the SPI Receive Holding Register is full, otherwise \c 0.
 */
static inline bool spi_is_tx_ok(SPI_t *spi)
{
	return spi->STATUS & SPI_IF_bm ? true : false;
    6d02:	82 81       	ldd	r24, Z+2	; 0x02
		
		while (!spi_is_rx_full(spi)) {
    6d04:	88 23       	and	r24, r24
    6d06:	ec f7       	brge	.-6      	; 0x6d02 <spi_write_packet+0xe>
 *
 * \pre SPI device must be selected with spi_select_device() first
 */
status_code_t spi_write_packet(SPI_t *spi, const uint8_t *data, size_t len)
{
	while (len--) {
    6d08:	a4 17       	cp	r26, r20
    6d0a:	b5 07       	cpc	r27, r21
    6d0c:	c1 f7       	brne	.-16     	; 0x6cfe <spi_write_packet+0xa>
		while (!spi_is_rx_full(spi)) {
		}
	}
	
	return STATUS_OK;
}
    6d0e:	80 e0       	ldi	r24, 0x00	; 0
    6d10:	08 95       	ret

00006d12 <spi_read_packet>:
 * \param len    Length of data
 *
 * \pre SPI device must be selected with spi_select_device() first
 */
status_code_t spi_read_packet(SPI_t *spi, uint8_t *data, size_t len)
{
    6d12:	fc 01       	movw	r30, r24
    6d14:	db 01       	movw	r26, r22
	while (len--) {
    6d16:	41 15       	cp	r20, r1
    6d18:	51 05       	cpc	r21, r1
    6d1a:	61 f0       	breq	.+24     	; 0x6d34 <spi_read_packet+0x22>
    6d1c:	46 0f       	add	r20, r22
    6d1e:	57 1f       	adc	r21, r23
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(SPI_t *spi, uint8_t data)
{
	spi->DATA = data;
    6d20:	9f ef       	ldi	r25, 0xFF	; 255
    6d22:	93 83       	std	Z+3, r25	; 0x03
 *
 * \return \c 1 if the SPI Receive Holding Register is full, otherwise \c 0.
 */
static inline bool spi_is_tx_ok(SPI_t *spi)
{
	return spi->STATUS & SPI_IF_bm ? true : false;
    6d24:	82 81       	ldd	r24, Z+2	; 0x02
		spi_write_single(spi,CONFIG_SPI_MASTER_DUMMY); //Dummy write

		while (!spi_is_rx_full(spi)) {
    6d26:	88 23       	and	r24, r24
    6d28:	ec f7       	brge	.-6      	; 0x6d24 <spi_read_packet+0x12>
 * \return The data byte
 *
 */
static inline uint8_t spi_get(SPI_t *spi)
{
	return spi->DATA;
    6d2a:	83 81       	ldd	r24, Z+3	; 0x03
 * \param data Pointer to the data byte where to store the received data.
 *
 */
inline static void spi_read_single(SPI_t *spi, uint8_t *data)
{
	*data=spi_get(spi);
    6d2c:	8d 93       	st	X+, r24
 *
 * \pre SPI device must be selected with spi_select_device() first
 */
status_code_t spi_read_packet(SPI_t *spi, uint8_t *data, size_t len)
{
	while (len--) {
    6d2e:	a4 17       	cp	r26, r20
    6d30:	b5 07       	cpc	r27, r21
    6d32:	b9 f7       	brne	.-18     	; 0x6d22 <spi_read_packet+0x10>
		spi_read_single(spi, data);
		data++;
	}
	
	return STATUS_OK;
}
    6d34:	80 e0       	ldi	r24, 0x00	; 0
    6d36:	08 95       	ret

00006d38 <spi_select_device>:
 * \param device SPI device
 *
 */
void spi_select_device(SPI_t *spi, struct spi_device *device)
{
	ioport_set_pin_low(device->id);
    6d38:	fb 01       	movw	r30, r22
    6d3a:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    6d3c:	e8 2f       	mov	r30, r24
    6d3e:	e6 95       	lsr	r30
    6d40:	e6 95       	lsr	r30
    6d42:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    6d44:	40 e2       	ldi	r20, 0x20	; 32
    6d46:	e4 9f       	mul	r30, r20
    6d48:	f0 01       	movw	r30, r0
    6d4a:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    6d4c:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    6d4e:	87 70       	andi	r24, 0x07	; 7
    6d50:	21 e0       	ldi	r18, 0x01	; 1
    6d52:	30 e0       	ldi	r19, 0x00	; 0
    6d54:	a9 01       	movw	r20, r18
    6d56:	02 c0       	rjmp	.+4      	; 0x6d5c <spi_select_device+0x24>
    6d58:	44 0f       	add	r20, r20
    6d5a:	55 1f       	adc	r21, r21
    6d5c:	8a 95       	dec	r24
    6d5e:	e2 f7       	brpl	.-8      	; 0x6d58 <spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    6d60:	46 83       	std	Z+6, r20	; 0x06
    6d62:	08 95       	ret

00006d64 <spi_deselect_device>:
 *
 * \pre SPI device must be selected with spi_select_device() first
 */
void spi_deselect_device(SPI_t *spi, struct spi_device *device)
{
	ioport_set_pin_high(device->id);
    6d64:	fb 01       	movw	r30, r22
    6d66:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    6d68:	e8 2f       	mov	r30, r24
    6d6a:	e6 95       	lsr	r30
    6d6c:	e6 95       	lsr	r30
    6d6e:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    6d70:	40 e2       	ldi	r20, 0x20	; 32
    6d72:	e4 9f       	mul	r30, r20
    6d74:	f0 01       	movw	r30, r0
    6d76:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    6d78:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    6d7a:	87 70       	andi	r24, 0x07	; 7
    6d7c:	21 e0       	ldi	r18, 0x01	; 1
    6d7e:	30 e0       	ldi	r19, 0x00	; 0
    6d80:	a9 01       	movw	r20, r18
    6d82:	02 c0       	rjmp	.+4      	; 0x6d88 <spi_deselect_device+0x24>
    6d84:	44 0f       	add	r20, r20
    6d86:	55 1f       	adc	r21, r21
    6d88:	8a 95       	dec	r24
    6d8a:	e2 f7       	brpl	.-8      	; 0x6d84 <spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    6d8c:	45 83       	std	Z+5, r20	; 0x05
    6d8e:	08 95       	ret

00006d90 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    6d90:	1f 92       	push	r1
    6d92:	0f 92       	push	r0
    6d94:	0f b6       	in	r0, 0x3f	; 63
    6d96:	0f 92       	push	r0
    6d98:	11 24       	eor	r1, r1
    6d9a:	08 b6       	in	r0, 0x38	; 56
    6d9c:	0f 92       	push	r0
    6d9e:	18 be       	out	0x38, r1	; 56
    6da0:	09 b6       	in	r0, 0x39	; 57
    6da2:	0f 92       	push	r0
    6da4:	19 be       	out	0x39, r1	; 57
    6da6:	0b b6       	in	r0, 0x3b	; 59
    6da8:	0f 92       	push	r0
    6daa:	1b be       	out	0x3b, r1	; 59
    6dac:	2f 93       	push	r18
    6dae:	3f 93       	push	r19
    6db0:	4f 93       	push	r20
    6db2:	5f 93       	push	r21
    6db4:	6f 93       	push	r22
    6db6:	7f 93       	push	r23
    6db8:	8f 93       	push	r24
    6dba:	9f 93       	push	r25
    6dbc:	af 93       	push	r26
    6dbe:	bf 93       	push	r27
    6dc0:	ef 93       	push	r30
    6dc2:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    6dc4:	e0 e0       	ldi	r30, 0x00	; 0
    6dc6:	f2 e0       	ldi	r31, 0x02	; 2
    6dc8:	44 a1       	ldd	r20, Z+36	; 0x24
    6dca:	55 a1       	ldd	r21, Z+37	; 0x25
    6dcc:	e0 91 d8 3d 	lds	r30, 0x3DD8
    6dd0:	f0 91 d9 3d 	lds	r31, 0x3DD9
    6dd4:	61 e0       	ldi	r22, 0x01	; 1
    6dd6:	80 e0       	ldi	r24, 0x00	; 0
    6dd8:	92 e0       	ldi	r25, 0x02	; 2
    6dda:	19 95       	eicall
}
    6ddc:	ff 91       	pop	r31
    6dde:	ef 91       	pop	r30
    6de0:	bf 91       	pop	r27
    6de2:	af 91       	pop	r26
    6de4:	9f 91       	pop	r25
    6de6:	8f 91       	pop	r24
    6de8:	7f 91       	pop	r23
    6dea:	6f 91       	pop	r22
    6dec:	5f 91       	pop	r21
    6dee:	4f 91       	pop	r20
    6df0:	3f 91       	pop	r19
    6df2:	2f 91       	pop	r18
    6df4:	0f 90       	pop	r0
    6df6:	0b be       	out	0x3b, r0	; 59
    6df8:	0f 90       	pop	r0
    6dfa:	09 be       	out	0x39, r0	; 57
    6dfc:	0f 90       	pop	r0
    6dfe:	08 be       	out	0x38, r0	; 56
    6e00:	0f 90       	pop	r0
    6e02:	0f be       	out	0x3f, r0	; 63
    6e04:	0f 90       	pop	r0
    6e06:	1f 90       	pop	r1
    6e08:	18 95       	reti

00006e0a <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    6e0a:	1f 92       	push	r1
    6e0c:	0f 92       	push	r0
    6e0e:	0f b6       	in	r0, 0x3f	; 63
    6e10:	0f 92       	push	r0
    6e12:	11 24       	eor	r1, r1
    6e14:	08 b6       	in	r0, 0x38	; 56
    6e16:	0f 92       	push	r0
    6e18:	18 be       	out	0x38, r1	; 56
    6e1a:	09 b6       	in	r0, 0x39	; 57
    6e1c:	0f 92       	push	r0
    6e1e:	19 be       	out	0x39, r1	; 57
    6e20:	0b b6       	in	r0, 0x3b	; 59
    6e22:	0f 92       	push	r0
    6e24:	1b be       	out	0x3b, r1	; 59
    6e26:	2f 93       	push	r18
    6e28:	3f 93       	push	r19
    6e2a:	4f 93       	push	r20
    6e2c:	5f 93       	push	r21
    6e2e:	6f 93       	push	r22
    6e30:	7f 93       	push	r23
    6e32:	8f 93       	push	r24
    6e34:	9f 93       	push	r25
    6e36:	af 93       	push	r26
    6e38:	bf 93       	push	r27
    6e3a:	ef 93       	push	r30
    6e3c:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    6e3e:	e8 e2       	ldi	r30, 0x28	; 40
    6e40:	f2 e0       	ldi	r31, 0x02	; 2
    6e42:	44 81       	ldd	r20, Z+4	; 0x04
    6e44:	55 81       	ldd	r21, Z+5	; 0x05
    6e46:	e0 91 d8 3d 	lds	r30, 0x3DD8
    6e4a:	f0 91 d9 3d 	lds	r31, 0x3DD9
    6e4e:	62 e0       	ldi	r22, 0x02	; 2
    6e50:	80 e0       	ldi	r24, 0x00	; 0
    6e52:	92 e0       	ldi	r25, 0x02	; 2
    6e54:	19 95       	eicall
}
    6e56:	ff 91       	pop	r31
    6e58:	ef 91       	pop	r30
    6e5a:	bf 91       	pop	r27
    6e5c:	af 91       	pop	r26
    6e5e:	9f 91       	pop	r25
    6e60:	8f 91       	pop	r24
    6e62:	7f 91       	pop	r23
    6e64:	6f 91       	pop	r22
    6e66:	5f 91       	pop	r21
    6e68:	4f 91       	pop	r20
    6e6a:	3f 91       	pop	r19
    6e6c:	2f 91       	pop	r18
    6e6e:	0f 90       	pop	r0
    6e70:	0b be       	out	0x3b, r0	; 59
    6e72:	0f 90       	pop	r0
    6e74:	09 be       	out	0x39, r0	; 57
    6e76:	0f 90       	pop	r0
    6e78:	08 be       	out	0x38, r0	; 56
    6e7a:	0f 90       	pop	r0
    6e7c:	0f be       	out	0x3f, r0	; 63
    6e7e:	0f 90       	pop	r0
    6e80:	1f 90       	pop	r1
    6e82:	18 95       	reti

00006e84 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    6e84:	1f 92       	push	r1
    6e86:	0f 92       	push	r0
    6e88:	0f b6       	in	r0, 0x3f	; 63
    6e8a:	0f 92       	push	r0
    6e8c:	11 24       	eor	r1, r1
    6e8e:	08 b6       	in	r0, 0x38	; 56
    6e90:	0f 92       	push	r0
    6e92:	18 be       	out	0x38, r1	; 56
    6e94:	09 b6       	in	r0, 0x39	; 57
    6e96:	0f 92       	push	r0
    6e98:	19 be       	out	0x39, r1	; 57
    6e9a:	0b b6       	in	r0, 0x3b	; 59
    6e9c:	0f 92       	push	r0
    6e9e:	1b be       	out	0x3b, r1	; 59
    6ea0:	2f 93       	push	r18
    6ea2:	3f 93       	push	r19
    6ea4:	4f 93       	push	r20
    6ea6:	5f 93       	push	r21
    6ea8:	6f 93       	push	r22
    6eaa:	7f 93       	push	r23
    6eac:	8f 93       	push	r24
    6eae:	9f 93       	push	r25
    6eb0:	af 93       	push	r26
    6eb2:	bf 93       	push	r27
    6eb4:	ef 93       	push	r30
    6eb6:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    6eb8:	e0 e3       	ldi	r30, 0x30	; 48
    6eba:	f2 e0       	ldi	r31, 0x02	; 2
    6ebc:	44 81       	ldd	r20, Z+4	; 0x04
    6ebe:	55 81       	ldd	r21, Z+5	; 0x05
    6ec0:	e0 91 d8 3d 	lds	r30, 0x3DD8
    6ec4:	f0 91 d9 3d 	lds	r31, 0x3DD9
    6ec8:	64 e0       	ldi	r22, 0x04	; 4
    6eca:	80 e0       	ldi	r24, 0x00	; 0
    6ecc:	92 e0       	ldi	r25, 0x02	; 2
    6ece:	19 95       	eicall
}
    6ed0:	ff 91       	pop	r31
    6ed2:	ef 91       	pop	r30
    6ed4:	bf 91       	pop	r27
    6ed6:	af 91       	pop	r26
    6ed8:	9f 91       	pop	r25
    6eda:	8f 91       	pop	r24
    6edc:	7f 91       	pop	r23
    6ede:	6f 91       	pop	r22
    6ee0:	5f 91       	pop	r21
    6ee2:	4f 91       	pop	r20
    6ee4:	3f 91       	pop	r19
    6ee6:	2f 91       	pop	r18
    6ee8:	0f 90       	pop	r0
    6eea:	0b be       	out	0x3b, r0	; 59
    6eec:	0f 90       	pop	r0
    6eee:	09 be       	out	0x39, r0	; 57
    6ef0:	0f 90       	pop	r0
    6ef2:	08 be       	out	0x38, r0	; 56
    6ef4:	0f 90       	pop	r0
    6ef6:	0f be       	out	0x3f, r0	; 63
    6ef8:	0f 90       	pop	r0
    6efa:	1f 90       	pop	r1
    6efc:	18 95       	reti

00006efe <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    6efe:	1f 92       	push	r1
    6f00:	0f 92       	push	r0
    6f02:	0f b6       	in	r0, 0x3f	; 63
    6f04:	0f 92       	push	r0
    6f06:	11 24       	eor	r1, r1
    6f08:	08 b6       	in	r0, 0x38	; 56
    6f0a:	0f 92       	push	r0
    6f0c:	18 be       	out	0x38, r1	; 56
    6f0e:	09 b6       	in	r0, 0x39	; 57
    6f10:	0f 92       	push	r0
    6f12:	19 be       	out	0x39, r1	; 57
    6f14:	0b b6       	in	r0, 0x3b	; 59
    6f16:	0f 92       	push	r0
    6f18:	1b be       	out	0x3b, r1	; 59
    6f1a:	2f 93       	push	r18
    6f1c:	3f 93       	push	r19
    6f1e:	4f 93       	push	r20
    6f20:	5f 93       	push	r21
    6f22:	6f 93       	push	r22
    6f24:	7f 93       	push	r23
    6f26:	8f 93       	push	r24
    6f28:	9f 93       	push	r25
    6f2a:	af 93       	push	r26
    6f2c:	bf 93       	push	r27
    6f2e:	ef 93       	push	r30
    6f30:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    6f32:	e8 e3       	ldi	r30, 0x38	; 56
    6f34:	f2 e0       	ldi	r31, 0x02	; 2
    6f36:	44 81       	ldd	r20, Z+4	; 0x04
    6f38:	55 81       	ldd	r21, Z+5	; 0x05
    6f3a:	e0 91 d8 3d 	lds	r30, 0x3DD8
    6f3e:	f0 91 d9 3d 	lds	r31, 0x3DD9
    6f42:	68 e0       	ldi	r22, 0x08	; 8
    6f44:	80 e0       	ldi	r24, 0x00	; 0
    6f46:	92 e0       	ldi	r25, 0x02	; 2
    6f48:	19 95       	eicall
}
    6f4a:	ff 91       	pop	r31
    6f4c:	ef 91       	pop	r30
    6f4e:	bf 91       	pop	r27
    6f50:	af 91       	pop	r26
    6f52:	9f 91       	pop	r25
    6f54:	8f 91       	pop	r24
    6f56:	7f 91       	pop	r23
    6f58:	6f 91       	pop	r22
    6f5a:	5f 91       	pop	r21
    6f5c:	4f 91       	pop	r20
    6f5e:	3f 91       	pop	r19
    6f60:	2f 91       	pop	r18
    6f62:	0f 90       	pop	r0
    6f64:	0b be       	out	0x3b, r0	; 59
    6f66:	0f 90       	pop	r0
    6f68:	09 be       	out	0x39, r0	; 57
    6f6a:	0f 90       	pop	r0
    6f6c:	08 be       	out	0x38, r0	; 56
    6f6e:	0f 90       	pop	r0
    6f70:	0f be       	out	0x3f, r0	; 63
    6f72:	0f 90       	pop	r0
    6f74:	1f 90       	pop	r1
    6f76:	18 95       	reti

00006f78 <spi_xmega_set_baud_div>:
 * \return Status of operation.
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
int8_t spi_xmega_set_baud_div(SPI_t *spi, uint32_t baudrate, uint32_t clkper_hz)
{
    6f78:	cf 92       	push	r12
    6f7a:	df 92       	push	r13
    6f7c:	ef 92       	push	r14
    6f7e:	ff 92       	push	r15
    6f80:	0f 93       	push	r16
    6f82:	1f 93       	push	r17
    6f84:	cf 93       	push	r28
    6f86:	df 93       	push	r29
    6f88:	ec 01       	movw	r28, r24
    6f8a:	6a 01       	movw	r12, r20
    6f8c:	7b 01       	movw	r14, r22

	/*
	 * Get wanted divisor rounded up so we don't get speed higher than
	 * requested baudrate.
	 */
	divisor = (clkper_hz + baudrate - 1) / baudrate;
    6f8e:	db 01       	movw	r26, r22
    6f90:	ca 01       	movw	r24, r20
    6f92:	01 97       	sbiw	r24, 0x01	; 1
    6f94:	a1 09       	sbc	r26, r1
    6f96:	b1 09       	sbc	r27, r1
    6f98:	bc 01       	movw	r22, r24
    6f9a:	cd 01       	movw	r24, r26
    6f9c:	60 0f       	add	r22, r16
    6f9e:	71 1f       	adc	r23, r17
    6fa0:	82 1f       	adc	r24, r18
    6fa2:	93 1f       	adc	r25, r19
    6fa4:	a7 01       	movw	r20, r14
    6fa6:	96 01       	movw	r18, r12
    6fa8:	e9 d7       	rcall	.+4050   	; 0x7f7c <__udivmodsi4>

	if (divisor > 128) {
    6faa:	21 38       	cpi	r18, 0x81	; 129
    6fac:	31 05       	cpc	r19, r1
    6fae:	41 05       	cpc	r20, r1
    6fb0:	51 05       	cpc	r21, r1
    6fb2:	f8 f4       	brcc	.+62     	; 0x6ff2 <spi_xmega_set_baud_div+0x7a>

	/*
	 * For divisor values between the possible ones round up to the closest
	 * higher one to avoid higher baudrate than requested.
	 */
	if (divisor_8bit > 64) {
    6fb4:	21 34       	cpi	r18, 0x41	; 65
    6fb6:	60 f4       	brcc	.+24     	; 0x6fd0 <spi_xmega_set_baud_div+0x58>
		ctrl = SPI_PRESCALER_DIV128_gc;
	}
	else if (divisor_8bit > 32) {
    6fb8:	21 32       	cpi	r18, 0x21	; 33
    6fba:	60 f4       	brcc	.+24     	; 0x6fd4 <spi_xmega_set_baud_div+0x5c>
		ctrl = SPI_PRESCALER_DIV64_gc;
	}
	else if (divisor_8bit > 16) {
    6fbc:	21 31       	cpi	r18, 0x11	; 17
    6fbe:	60 f4       	brcc	.+24     	; 0x6fd8 <spi_xmega_set_baud_div+0x60>
		ctrl = SPI_CLK2X_bm | SPI_PRESCALER_DIV64_gc;
	}
	else if (divisor_8bit > 8) {
    6fc0:	29 30       	cpi	r18, 0x09	; 9
    6fc2:	60 f4       	brcc	.+24     	; 0x6fdc <spi_xmega_set_baud_div+0x64>
		ctrl = SPI_PRESCALER_DIV16_gc;
	}
	else if (divisor_8bit > 4) {
    6fc4:	25 30       	cpi	r18, 0x05	; 5
    6fc6:	60 f4       	brcc	.+24     	; 0x6fe0 <spi_xmega_set_baud_div+0x68>
		ctrl = SPI_CLK2X_bm | SPI_PRESCALER_DIV16_gc;
	}
	else if (divisor_8bit > 2) {
    6fc8:	23 30       	cpi	r18, 0x03	; 3
    6fca:	60 f0       	brcs	.+24     	; 0x6fe4 <spi_xmega_set_baud_div+0x6c>
		ctrl = SPI_PRESCALER_DIV4_gc;
    6fcc:	90 e0       	ldi	r25, 0x00	; 0
    6fce:	0b c0       	rjmp	.+22     	; 0x6fe6 <spi_xmega_set_baud_div+0x6e>
	/*
	 * For divisor values between the possible ones round up to the closest
	 * higher one to avoid higher baudrate than requested.
	 */
	if (divisor_8bit > 64) {
		ctrl = SPI_PRESCALER_DIV128_gc;
    6fd0:	93 e0       	ldi	r25, 0x03	; 3
    6fd2:	09 c0       	rjmp	.+18     	; 0x6fe6 <spi_xmega_set_baud_div+0x6e>
	}
	else if (divisor_8bit > 32) {
		ctrl = SPI_PRESCALER_DIV64_gc;
    6fd4:	92 e0       	ldi	r25, 0x02	; 2
    6fd6:	07 c0       	rjmp	.+14     	; 0x6fe6 <spi_xmega_set_baud_div+0x6e>
	}
	else if (divisor_8bit > 16) {
		ctrl = SPI_CLK2X_bm | SPI_PRESCALER_DIV64_gc;
    6fd8:	92 e8       	ldi	r25, 0x82	; 130
    6fda:	05 c0       	rjmp	.+10     	; 0x6fe6 <spi_xmega_set_baud_div+0x6e>
	}
	else if (divisor_8bit > 8) {
		ctrl = SPI_PRESCALER_DIV16_gc;
    6fdc:	91 e0       	ldi	r25, 0x01	; 1
    6fde:	03 c0       	rjmp	.+6      	; 0x6fe6 <spi_xmega_set_baud_div+0x6e>
	}
	else if (divisor_8bit > 4) {
		ctrl = SPI_CLK2X_bm | SPI_PRESCALER_DIV16_gc;
    6fe0:	91 e8       	ldi	r25, 0x81	; 129
    6fe2:	01 c0       	rjmp	.+2      	; 0x6fe6 <spi_xmega_set_baud_div+0x6e>
	}
	else if (divisor_8bit > 2) {
		ctrl = SPI_PRESCALER_DIV4_gc;
	}
	else {
		ctrl = SPI_CLK2X_bm | SPI_PRESCALER_DIV4_gc;
    6fe4:	90 e8       	ldi	r25, 0x80	; 128
	}

	// Update register and make sure to clear out any leftover bits
	spi->CTRL = (spi->CTRL & ~(SPI_CLK2X_bm | SPI_PRESCALER_gm)) | ctrl;
    6fe6:	88 81       	ld	r24, Y
    6fe8:	8c 77       	andi	r24, 0x7C	; 124
    6fea:	89 2b       	or	r24, r25
    6fec:	88 83       	st	Y, r24

	return 1;
    6fee:	81 e0       	ldi	r24, 0x01	; 1
    6ff0:	01 c0       	rjmp	.+2      	; 0x6ff4 <spi_xmega_set_baud_div+0x7c>
	if (divisor > 128) {
		/*
		 * Highest possible divisor is 128 so fail since we can't get
		 * low enough baudrate.
		 */
		return -1;
    6ff2:	8f ef       	ldi	r24, 0xFF	; 255

	// Update register and make sure to clear out any leftover bits
	spi->CTRL = (spi->CTRL & ~(SPI_CLK2X_bm | SPI_PRESCALER_gm)) | ctrl;

	return 1;
}
    6ff4:	df 91       	pop	r29
    6ff6:	cf 91       	pop	r28
    6ff8:	1f 91       	pop	r17
    6ffa:	0f 91       	pop	r16
    6ffc:	ff 90       	pop	r15
    6ffe:	ef 90       	pop	r14
    7000:	df 90       	pop	r13
    7002:	cf 90       	pop	r12
    7004:	08 95       	ret

00007006 <__vector_20>:

/* -------------------------------------------------------------------- */
/*	Interrupt for timing the RTC										*/
/* -------------------------------------------------------------------- */
ISR(TCC1_OVF_vect) 
{
    7006:	1f 92       	push	r1
    7008:	0f 92       	push	r0
    700a:	0f b6       	in	r0, 0x3f	; 63
    700c:	0f 92       	push	r0
    700e:	11 24       	eor	r1, r1
    7010:	08 b6       	in	r0, 0x38	; 56
    7012:	0f 92       	push	r0
    7014:	18 be       	out	0x38, r1	; 56
    7016:	09 b6       	in	r0, 0x39	; 57
    7018:	0f 92       	push	r0
    701a:	19 be       	out	0x39, r1	; 57
    701c:	2f 93       	push	r18
    701e:	4f 93       	push	r20
    7020:	5f 93       	push	r21
    7022:	6f 93       	push	r22
    7024:	7f 93       	push	r23
    7026:	8f 93       	push	r24
    7028:	9f 93       	push	r25
    702a:	af 93       	push	r26
    702c:	bf 93       	push	r27

	
	// shut down the output PPM pulse

	if (milisecondsTimer++ == 1000) {
    702e:	80 91 e0 3d 	lds	r24, 0x3DE0
    7032:	90 91 e1 3d 	lds	r25, 0x3DE1
    7036:	a0 91 e2 3d 	lds	r26, 0x3DE2
    703a:	b0 91 e3 3d 	lds	r27, 0x3DE3
    703e:	ac 01       	movw	r20, r24
    7040:	bd 01       	movw	r22, r26
    7042:	4f 5f       	subi	r20, 0xFF	; 255
    7044:	5f 4f       	sbci	r21, 0xFF	; 255
    7046:	6f 4f       	sbci	r22, 0xFF	; 255
    7048:	7f 4f       	sbci	r23, 0xFF	; 255
    704a:	40 93 e0 3d 	sts	0x3DE0, r20
    704e:	50 93 e1 3d 	sts	0x3DE1, r21
    7052:	60 93 e2 3d 	sts	0x3DE2, r22
    7056:	70 93 e3 3d 	sts	0x3DE3, r23
    705a:	88 3e       	cpi	r24, 0xE8	; 232
    705c:	93 40       	sbci	r25, 0x03	; 3
    705e:	a1 05       	cpc	r26, r1
    7060:	b1 05       	cpc	r27, r1
    7062:	f1 f5       	brne	.+124    	; 0x70e0 <__vector_20+0xda>
		
		milisecondsTimer = 0;
    7064:	10 92 e0 3d 	sts	0x3DE0, r1
    7068:	10 92 e1 3d 	sts	0x3DE1, r1
    706c:	10 92 e2 3d 	sts	0x3DE2, r1
    7070:	10 92 e3 3d 	sts	0x3DE3, r1
		
		if (secondsTimer++ == 3600) {
    7074:	80 91 ea 3d 	lds	r24, 0x3DEA
    7078:	90 91 eb 3d 	lds	r25, 0x3DEB
    707c:	a0 91 ec 3d 	lds	r26, 0x3DEC
    7080:	b0 91 ed 3d 	lds	r27, 0x3DED
    7084:	ac 01       	movw	r20, r24
    7086:	bd 01       	movw	r22, r26
    7088:	4f 5f       	subi	r20, 0xFF	; 255
    708a:	5f 4f       	sbci	r21, 0xFF	; 255
    708c:	6f 4f       	sbci	r22, 0xFF	; 255
    708e:	7f 4f       	sbci	r23, 0xFF	; 255
    7090:	40 93 ea 3d 	sts	0x3DEA, r20
    7094:	50 93 eb 3d 	sts	0x3DEB, r21
    7098:	60 93 ec 3d 	sts	0x3DEC, r22
    709c:	70 93 ed 3d 	sts	0x3DED, r23
    70a0:	80 31       	cpi	r24, 0x10	; 16
    70a2:	9e 40       	sbci	r25, 0x0E	; 14
    70a4:	a1 05       	cpc	r26, r1
    70a6:	b1 05       	cpc	r27, r1
    70a8:	d9 f4       	brne	.+54     	; 0x70e0 <__vector_20+0xda>
			
			secondsTimer = 0;
    70aa:	10 92 ea 3d 	sts	0x3DEA, r1
    70ae:	10 92 eb 3d 	sts	0x3DEB, r1
    70b2:	10 92 ec 3d 	sts	0x3DEC, r1
    70b6:	10 92 ed 3d 	sts	0x3DED, r1
			hoursTimer++;
    70ba:	80 91 dc 3d 	lds	r24, 0x3DDC
    70be:	90 91 dd 3d 	lds	r25, 0x3DDD
    70c2:	a0 91 de 3d 	lds	r26, 0x3DDE
    70c6:	b0 91 df 3d 	lds	r27, 0x3DDF
    70ca:	01 96       	adiw	r24, 0x01	; 1
    70cc:	a1 1d       	adc	r26, r1
    70ce:	b1 1d       	adc	r27, r1
    70d0:	80 93 dc 3d 	sts	0x3DDC, r24
    70d4:	90 93 dd 3d 	sts	0x3DDD, r25
    70d8:	a0 93 de 3d 	sts	0x3DDE, r26
    70dc:	b0 93 df 3d 	sts	0x3DDF, r27
		}
	}
	

}
    70e0:	bf 91       	pop	r27
    70e2:	af 91       	pop	r26
    70e4:	9f 91       	pop	r25
    70e6:	8f 91       	pop	r24
    70e8:	7f 91       	pop	r23
    70ea:	6f 91       	pop	r22
    70ec:	5f 91       	pop	r21
    70ee:	4f 91       	pop	r20
    70f0:	2f 91       	pop	r18
    70f2:	0f 90       	pop	r0
    70f4:	09 be       	out	0x39, r0	; 57
    70f6:	0f 90       	pop	r0
    70f8:	08 be       	out	0x38, r0	; 56
    70fa:	0f 90       	pop	r0
    70fc:	0f be       	out	0x3f, r0	; 63
    70fe:	0f 90       	pop	r0
    7100:	1f 90       	pop	r1
    7102:	18 95       	reti

00007104 <enable_xtal>:
/* -------------------------------------------------------------------- */
/*	Enable external timing												*/
/* -------------------------------------------------------------------- */
void enable_xtal(void)
{
	PMIC.CTRL = PMIC.CTRL |	PMIC_MEDLVLEN_bm;
    7104:	e0 ea       	ldi	r30, 0xA0	; 160
    7106:	f0 e0       	ldi	r31, 0x00	; 0
    7108:	82 81       	ldd	r24, Z+2	; 0x02
    710a:	82 60       	ori	r24, 0x02	; 2
    710c:	82 83       	std	Z+2, r24	; 0x02
	// Enable external oscillator 16,470 MHz
	CLKSYS_XOSC_Config(OSC_FRQRANGE_12TO16_gc, 0, OSC_XOSCSEL_XTAL_1KCLK_gc);
    710e:	47 e0       	ldi	r20, 0x07	; 7
    7110:	60 e0       	ldi	r22, 0x00	; 0
    7112:	80 ec       	ldi	r24, 0xC0	; 192
    7114:	0e 94 86 30 	call	0x610c	; 0x610c <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    7118:	e0 e5       	ldi	r30, 0x50	; 80
    711a:	f0 e0       	ldi	r31, 0x00	; 0
    711c:	80 81       	ld	r24, Z
    711e:	88 60       	ori	r24, 0x08	; 8
    7120:	80 83       	st	Z, r24
	while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 ){}
    7122:	81 81       	ldd	r24, Z+1	; 0x01
    7124:	83 ff       	sbrs	r24, 3
    7126:	fd cf       	rjmp	.-6      	; 0x7122 <enable_xtal+0x1e>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_XOSC_gc );
    7128:	83 e0       	ldi	r24, 0x03	; 3
    712a:	05 d8       	rcall	.-4086   	; 0x6136 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    712c:	81 e0       	ldi	r24, 0x01	; 1
    712e:	0c 94 91 30 	jmp	0x6122	; 0x6122 <CLKSYS_Disable>
    7132:	08 95       	ret

00007134 <adc_init>:
	

	// differential mode
	// negative input is PORTA.0 connected to GND
	
	PORTA.DIR = 0;	 // configure PORTA as input
    7134:	10 92 00 06 	sts	0x0600, r1
	ADCA.CTRLA |= 0x1;	 // enable adc
    7138:	e0 e0       	ldi	r30, 0x00	; 0
    713a:	f2 e0       	ldi	r31, 0x02	; 2
    713c:	80 81       	ld	r24, Z
    713e:	81 60       	ori	r24, 0x01	; 1
    7140:	80 83       	st	Z, r24
	ADCA.CTRLB = ADC_CONMODE_bm | ADC_RESOLUTION_12BIT_gc;	 // 12 bit conversion, conversion mode - signed - diff
    7142:	80 e1       	ldi	r24, 0x10	; 16
    7144:	81 83       	std	Z+1, r24	; 0x01
	
	ADCA.REFCTRL = 0x12;	 // internal Vcc/1.6 (3,3/1,6=2,0625V)
    7146:	82 e1       	ldi	r24, 0x12	; 18
    7148:	82 83       	std	Z+2, r24	; 0x02
	ADCA.PRESCALER = ADC_PRESCALER_DIV128_gc;	 // peripheral clk/128 (16,47MHz ... 128kHz)
    714a:	85 e0       	ldi	r24, 0x05	; 5
    714c:	84 83       	std	Z+4, r24	; 0x04
	ADCA.CH0.CTRL = ADC_CH_INPUTMODE_DIFF_gc;				  // differential mode, without gain, NEG input PORTA.0!
    714e:	82 e0       	ldi	r24, 0x02	; 2
    7150:	80 a3       	std	Z+32, r24	; 0x20
	ADCA.EVCTRL = 0x1A;
    7152:	8a e1       	ldi	r24, 0x1A	; 26
    7154:	83 83       	std	Z+3, r24	; 0x03
	//ADCA.EVCTRL = 0x01;
	
	
	// in differential mode ****************************
	ADCA.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc | ADC_CH_MUXNEG_PIN0_gc;	// without gain	PIN 1
    7156:	88 e0       	ldi	r24, 0x08	; 8
    7158:	81 a3       	std	Z+33, r24	; 0x21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    715a:	87 e3       	ldi	r24, 0x37	; 55
    715c:	8a 95       	dec	r24
    715e:	f1 f7       	brne	.-4      	; 0x715c <adc_init+0x28>

	_delay_us(10);
	//ADCA.CTRLA |= 0x4;
	// wait for result
	ADCA.CH0.CTRL |= ADC_CH_START_bm;
    7160:	80 a1       	ldd	r24, Z+32	; 0x20
    7162:	80 68       	ori	r24, 0x80	; 128
    7164:	80 a3       	std	Z+32, r24	; 0x20
	while(!ADCA.CH0.INTFLAGS);                           // wait for conversion complete flag
    7166:	83 a1       	ldd	r24, Z+35	; 0x23
    7168:	88 23       	and	r24, r24
    716a:	e9 f3       	breq	.-6      	; 0x7166 <adc_init+0x32>
	ADCA.CH0.INTFLAGS=ADC_CH_CHIF_bm;                    // clear int flags (cleared by writing 1)
    716c:	81 e0       	ldi	r24, 0x01	; 1
    716e:	e0 e0       	ldi	r30, 0x00	; 0
    7170:	f2 e0       	ldi	r31, 0x02	; 2
    7172:	83 a3       	std	Z+35, r24	; 0x23
    7174:	08 95       	ret

00007176 <boardInit>:
	
	// prepare i/o
	ioport_init();
	
	// clock init & enable system clock to all peripheral modules
	sysclk_init();
    7176:	0e d1       	rcall	.+540    	; 0x7394 <sysclk_init>
	
	// enable external oscillator
	enable_xtal();
    7178:	c5 df       	rcall	.-118    	; 0x7104 <enable_xtal>
	
	// enable SPI communication on port C for SPI memory
	spi_mem_init();
    717a:	6c dc       	rcall	.-1832   	; 0x6a54 <spi_mem_init>
	
	sysclk_enable_module(SYSCLK_PORT_GEN, 0xff);
    717c:	6f ef       	ldi	r22, 0xFF	; 255
    717e:	80 e0       	ldi	r24, 0x00	; 0
    7180:	30 d1       	rcall	.+608    	; 0x73e2 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_A, 0xff);
    7182:	6f ef       	ldi	r22, 0xFF	; 255
    7184:	81 e0       	ldi	r24, 0x01	; 1
    7186:	2d d1       	rcall	.+602    	; 0x73e2 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_B, 0xff);
    7188:	6f ef       	ldi	r22, 0xFF	; 255
    718a:	82 e0       	ldi	r24, 0x02	; 2
    718c:	2a d1       	rcall	.+596    	; 0x73e2 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_C, 0xff);
    718e:	6f ef       	ldi	r22, 0xFF	; 255
    7190:	83 e0       	ldi	r24, 0x03	; 3
    7192:	27 d1       	rcall	.+590    	; 0x73e2 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_D, 0xff);
    7194:	6f ef       	ldi	r22, 0xFF	; 255
    7196:	84 e0       	ldi	r24, 0x04	; 4
    7198:	24 d1       	rcall	.+584    	; 0x73e2 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_E, 0xff);
    719a:	6f ef       	ldi	r22, 0xFF	; 255
    719c:	85 e0       	ldi	r24, 0x05	; 5
    719e:	21 d1       	rcall	.+578    	; 0x73e2 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_F, 0xff);
    71a0:	6f ef       	ldi	r22, 0xFF	; 255
    71a2:	86 e0       	ldi	r24, 0x06	; 6
    71a4:	1e d1       	rcall	.+572    	; 0x73e2 <sysclk_enable_module>
	
	// enable ADC converter
	adc_init();
    71a6:	c6 df       	rcall	.-116    	; 0x7134 <adc_init>
	
	// init another TWI/I2C interface for ADT (TWIC)
	ADT_init();
    71a8:	0e 94 09 30 	call	0x6012	; 0x6012 <ADT_init>
	/* -------------------------------------------------------------------- */
	/*	Timer for RTC - 1ms													*/
	/* -------------------------------------------------------------------- */
	
	// select the clock source and pre-scaler by 1
	TC1_ConfigClockSource(&TCC1, TC_CLKSEL_DIV1_gc);
    71ac:	61 e0       	ldi	r22, 0x01	; 1
    71ae:	80 e4       	ldi	r24, 0x40	; 64
    71b0:	98 e0       	ldi	r25, 0x08	; 8
    71b2:	0e 94 b3 30 	call	0x6166	; 0x6166 <TC1_ConfigClockSource>
	
	TC1_SetOverflowIntLevel(&TCC1, TC_OVFINTLVL_LO_gc);
    71b6:	61 e0       	ldi	r22, 0x01	; 1
    71b8:	80 e4       	ldi	r24, 0x40	; 64
    71ba:	98 e0       	ldi	r25, 0x08	; 8
    71bc:	0e 94 bf 30 	call	0x617e	; 0x617e <TC1_SetOverflowIntLevel>
	
	TC_SetPeriod(&TCC1, 16469);
    71c0:	85 e5       	ldi	r24, 0x55	; 85
    71c2:	90 e4       	ldi	r25, 0x40	; 64
    71c4:	e0 e4       	ldi	r30, 0x40	; 64
    71c6:	f8 e0       	ldi	r31, 0x08	; 8
    71c8:	86 a3       	std	Z+38, r24	; 0x26
    71ca:	97 a3       	std	Z+39, r25	; 0x27
	
	milisecondsTimer = 0;
    71cc:	10 92 e0 3d 	sts	0x3DE0, r1
    71d0:	10 92 e1 3d 	sts	0x3DE1, r1
    71d4:	10 92 e2 3d 	sts	0x3DE2, r1
    71d8:	10 92 e3 3d 	sts	0x3DE3, r1
	secondsTimer = 0;
    71dc:	10 92 ea 3d 	sts	0x3DEA, r1
    71e0:	10 92 eb 3d 	sts	0x3DEB, r1
    71e4:	10 92 ec 3d 	sts	0x3DEC, r1
    71e8:	10 92 ed 3d 	sts	0x3DED, r1
	hoursTimer = 0;
    71ec:	10 92 dc 3d 	sts	0x3DDC, r1
    71f0:	10 92 dd 3d 	sts	0x3DDD, r1
    71f4:	10 92 de 3d 	sts	0x3DDE, r1
    71f8:	10 92 df 3d 	sts	0x3DDF, r1
	/* -------------------------------------------------------------------- */
	/*	Timer for sampling 2kHz												*/
	/* -------------------------------------------------------------------- */
		
	// select the clock source and pre-scaler by 1
	TC0_ConfigClockSource(&TCD0, TC_CLKSEL_DIV1_gc);
    71fc:	61 e0       	ldi	r22, 0x01	; 1
    71fe:	80 e0       	ldi	r24, 0x00	; 0
    7200:	99 e0       	ldi	r25, 0x09	; 9
    7202:	0e 94 ad 30 	call	0x615a	; 0x615a <TC0_ConfigClockSource>
		
	TC0_SetOverflowIntLevel(&TCD0, TC_OVFINTLVL_MED_gc);
    7206:	62 e0       	ldi	r22, 0x02	; 2
    7208:	80 e0       	ldi	r24, 0x00	; 0
    720a:	99 e0       	ldi	r25, 0x09	; 9
    720c:	0e 94 b9 30 	call	0x6172	; 0x6172 <TC0_SetOverflowIntLevel>
		
	TC_SetPeriod(&TCD0, 8234);
    7210:	8a e2       	ldi	r24, 0x2A	; 42
    7212:	90 e2       	ldi	r25, 0x20	; 32
    7214:	e0 e0       	ldi	r30, 0x00	; 0
    7216:	f9 e0       	ldi	r31, 0x09	; 9
    7218:	86 a3       	std	Z+38, r24	; 0x26
    721a:	97 a3       	std	Z+39, r25	; 0x27
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    721c:	e0 e8       	ldi	r30, 0x80	; 128
    721e:	f6 e0       	ldi	r31, 0x06	; 6
    7220:	88 e0       	ldi	r24, 0x08	; 8
    7222:	81 83       	std	Z+1, r24	; 0x01
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    7224:	85 83       	std	Z+5, r24	; 0x05
    7226:	08 95       	ret

00007228 <adca_read_ch0>:
	ADCA.CH0.INTFLAGS=ADC_CH_CHIF_bm;                    // clear int flags (cleared by writing 1)
	
}

unsigned int adca_read_ch0(void)
{
    7228:	44 e0       	ldi	r20, 0x04	; 4
int adc_sum;
unsigned char i;

	adc_sum=0;
    722a:	80 e0       	ldi	r24, 0x00	; 0
    722c:	90 e0       	ldi	r25, 0x00	; 0
	for(i=0;i<4;++i)
	{
		ADCA.CH0.CTRL |= ADC_CH_START_bm; // start conversion on channel 0
    722e:	e0 e0       	ldi	r30, 0x00	; 0
    7230:	f2 e0       	ldi	r31, 0x02	; 2
    7232:	20 a1       	ldd	r18, Z+32	; 0x20
    7234:	20 68       	ori	r18, 0x80	; 128
    7236:	20 a3       	std	Z+32, r18	; 0x20
		while(!ADCA.CH0.INTFLAGS);
    7238:	23 a1       	ldd	r18, Z+35	; 0x23
    723a:	22 23       	and	r18, r18
    723c:	e9 f3       	breq	.-6      	; 0x7238 <adca_read_ch0+0x10>
		adc_sum += ADCA.CH0RES;
    723e:	20 89       	ldd	r18, Z+16	; 0x10
    7240:	31 89       	ldd	r19, Z+17	; 0x11
    7242:	82 0f       	add	r24, r18
    7244:	93 1f       	adc	r25, r19
    7246:	41 50       	subi	r20, 0x01	; 1
{
int adc_sum;
unsigned char i;

	adc_sum=0;
	for(i=0;i<4;++i)
    7248:	a1 f7       	brne	.-24     	; 0x7232 <adca_read_ch0+0xa>
		//ADCA.CH0.INTFLAGS=ADC_CH_CHIF_bm;                    // clear int flags (cleared by writing 1)
	}
	adc_sum = adc_sum >> 2;
	return adc_sum;
	
    724a:	95 95       	asr	r25
    724c:	87 95       	ror	r24
    724e:	95 95       	asr	r25
    7250:	87 95       	ror	r24
    7252:	08 95       	ret

00007254 <__vector_77>:

/* -------------------------------------------------------------------- */
/*	Interrupt for sampling input signal	2kHz							*/
/* -------------------------------------------------------------------- */
ISR(TCD0_OVF_vect) 
{
    7254:	1f 92       	push	r1
    7256:	0f 92       	push	r0
    7258:	0f b6       	in	r0, 0x3f	; 63
    725a:	0f 92       	push	r0
    725c:	11 24       	eor	r1, r1
    725e:	08 b6       	in	r0, 0x38	; 56
    7260:	0f 92       	push	r0
    7262:	18 be       	out	0x38, r1	; 56
    7264:	09 b6       	in	r0, 0x39	; 57
    7266:	0f 92       	push	r0
    7268:	19 be       	out	0x39, r1	; 57
    726a:	0b b6       	in	r0, 0x3b	; 59
    726c:	0f 92       	push	r0
    726e:	1b be       	out	0x3b, r1	; 59
    7270:	cf 92       	push	r12
    7272:	df 92       	push	r13
    7274:	ef 92       	push	r14
    7276:	ff 92       	push	r15
    7278:	0f 93       	push	r16
    727a:	1f 93       	push	r17
    727c:	2f 93       	push	r18
    727e:	3f 93       	push	r19
    7280:	4f 93       	push	r20
    7282:	5f 93       	push	r21
    7284:	6f 93       	push	r22
    7286:	7f 93       	push	r23
    7288:	8f 93       	push	r24
    728a:	9f 93       	push	r25
    728c:	af 93       	push	r26
    728e:	bf 93       	push	r27
    7290:	ef 93       	push	r30
    7292:	ff 93       	push	r31

	unsigned long address;
	int adc_value;

	if (sampling == true)
    7294:	80 91 03 3b 	lds	r24, 0x3B03
    7298:	88 23       	and	r24, r24
    729a:	09 f4       	brne	.+2      	; 0x729e <__vector_77+0x4a>
    729c:	5e c0       	rjmp	.+188    	; 0x735a <__vector_77+0x106>
	{

		adc_value =  adca_read_ch0();
    729e:	c4 df       	rcall	.-120    	; 0x7228 <adca_read_ch0>
    72a0:	ac 01       	movw	r20, r24
		signal_offset += adc_value;
    72a2:	8c 01       	movw	r16, r24
    72a4:	22 27       	eor	r18, r18
    72a6:	17 fd       	sbrc	r17, 7
    72a8:	20 95       	com	r18
    72aa:	32 2f       	mov	r19, r18
    72ac:	c0 90 e6 3d 	lds	r12, 0x3DE6
    72b0:	d0 90 e7 3d 	lds	r13, 0x3DE7
    72b4:	e0 90 e8 3d 	lds	r14, 0x3DE8
    72b8:	f0 90 e9 3d 	lds	r15, 0x3DE9
    72bc:	0c 0d       	add	r16, r12
    72be:	1d 1d       	adc	r17, r13
    72c0:	2e 1d       	adc	r18, r14
    72c2:	3f 1d       	adc	r19, r15
    72c4:	00 93 e6 3d 	sts	0x3DE6, r16
    72c8:	10 93 e7 3d 	sts	0x3DE7, r17
    72cc:	20 93 e8 3d 	sts	0x3DE8, r18
    72d0:	30 93 e9 3d 	sts	0x3DE9, r19
		
		spi_mem_write_word(count_TCD0*2 + MEM_SIGNAL_BEGIN, adc_value);
    72d4:	60 91 da 3d 	lds	r22, 0x3DDA
    72d8:	70 91 db 3d 	lds	r23, 0x3DDB
    72dc:	66 0f       	add	r22, r22
    72de:	77 1f       	adc	r23, r23
    72e0:	80 e0       	ldi	r24, 0x00	; 0
    72e2:	90 e0       	ldi	r25, 0x00	; 0
    72e4:	f1 db       	rcall	.-2078   	; 0x6ac8 <spi_mem_write_word>
		
		++count_TCD0;
    72e6:	80 91 da 3d 	lds	r24, 0x3DDA
    72ea:	90 91 db 3d 	lds	r25, 0x3DDB
    72ee:	01 96       	adiw	r24, 0x01	; 1
    72f0:	80 93 da 3d 	sts	0x3DDA, r24
    72f4:	90 93 db 3d 	sts	0x3DDB, r25
		if (count_TCD0 == MEM_SIGNAL_LENGTH)
    72f8:	81 15       	cp	r24, r1
    72fa:	98 40       	sbci	r25, 0x08	; 8
    72fc:	71 f5       	brne	.+92     	; 0x735a <__vector_77+0x106>
		{
			spi_mem_write_word(MEM_SIGNAL_OFFSET, signal_offset/MEM_SIGNAL_LENGTH);
    72fe:	40 91 e6 3d 	lds	r20, 0x3DE6
    7302:	50 91 e7 3d 	lds	r21, 0x3DE7
    7306:	60 91 e8 3d 	lds	r22, 0x3DE8
    730a:	70 91 e9 3d 	lds	r23, 0x3DE9
    730e:	77 23       	and	r23, r23
    7310:	24 f4       	brge	.+8      	; 0x731a <__vector_77+0xc6>
    7312:	41 50       	subi	r20, 0x01	; 1
    7314:	58 4f       	sbci	r21, 0xF8	; 248
    7316:	6f 4f       	sbci	r22, 0xFF	; 255
    7318:	7f 4f       	sbci	r23, 0xFF	; 255
    731a:	03 2e       	mov	r0, r19
    731c:	3b e0       	ldi	r19, 0x0B	; 11
    731e:	75 95       	asr	r23
    7320:	67 95       	ror	r22
    7322:	57 95       	ror	r21
    7324:	47 95       	ror	r20
    7326:	3a 95       	dec	r19
    7328:	d1 f7       	brne	.-12     	; 0x731e <__vector_77+0xca>
    732a:	30 2d       	mov	r19, r0
    732c:	60 e0       	ldi	r22, 0x00	; 0
    732e:	78 e1       	ldi	r23, 0x18	; 24
    7330:	81 e0       	ldi	r24, 0x01	; 1
    7332:	90 e0       	ldi	r25, 0x00	; 0
    7334:	c9 db       	rcall	.-2158   	; 0x6ac8 <spi_mem_write_word>

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->OUTTGL = arch_ioport_pin_to_mask(pin);
    7336:	88 e0       	ldi	r24, 0x08	; 8
    7338:	e0 e8       	ldi	r30, 0x80	; 128
    733a:	f6 e0       	ldi	r31, 0x06	; 6
    733c:	87 83       	std	Z+7, r24	; 0x07
			power_switch_toggle();
			count_TCD0 = 0;
    733e:	10 92 da 3d 	sts	0x3DDA, r1
    7342:	10 92 db 3d 	sts	0x3DDB, r1
			sampling = false;
    7346:	10 92 03 3b 	sts	0x3B03, r1
			signal_offset = 0;
    734a:	10 92 e6 3d 	sts	0x3DE6, r1
    734e:	10 92 e7 3d 	sts	0x3DE7, r1
    7352:	10 92 e8 3d 	sts	0x3DE8, r1
    7356:	10 92 e9 3d 	sts	0x3DE9, r1
		}
		
	}
		
}
    735a:	ff 91       	pop	r31
    735c:	ef 91       	pop	r30
    735e:	bf 91       	pop	r27
    7360:	af 91       	pop	r26
    7362:	9f 91       	pop	r25
    7364:	8f 91       	pop	r24
    7366:	7f 91       	pop	r23
    7368:	6f 91       	pop	r22
    736a:	5f 91       	pop	r21
    736c:	4f 91       	pop	r20
    736e:	3f 91       	pop	r19
    7370:	2f 91       	pop	r18
    7372:	1f 91       	pop	r17
    7374:	0f 91       	pop	r16
    7376:	ff 90       	pop	r15
    7378:	ef 90       	pop	r14
    737a:	df 90       	pop	r13
    737c:	cf 90       	pop	r12
    737e:	0f 90       	pop	r0
    7380:	0b be       	out	0x3b, r0	; 59
    7382:	0f 90       	pop	r0
    7384:	09 be       	out	0x39, r0	; 57
    7386:	0f 90       	pop	r0
    7388:	08 be       	out	0x38, r0	; 56
    738a:	0f 90       	pop	r0
    738c:	0f be       	out	0x3f, r0	; 63
    738e:	0f 90       	pop	r0
    7390:	1f 90       	pop	r1
    7392:	18 95       	reti

00007394 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    7394:	8f ef       	ldi	r24, 0xFF	; 255
    7396:	80 93 70 00 	sts	0x0070, r24
    739a:	80 93 71 00 	sts	0x0071, r24
    739e:	80 93 72 00 	sts	0x0072, r24
    73a2:	80 93 73 00 	sts	0x0073, r24
    73a6:	80 93 74 00 	sts	0x0074, r24
    73aa:	80 93 75 00 	sts	0x0075, r24
    73ae:	80 93 76 00 	sts	0x0076, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    73b2:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    73b4:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL |= id;
    73b6:	e0 e5       	ldi	r30, 0x50	; 80
    73b8:	f0 e0       	ldi	r31, 0x00	; 0
    73ba:	90 81       	ld	r25, Z
    73bc:	92 60       	ori	r25, 0x02	; 2
    73be:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    73c0:	8f bf       	out	0x3f, r24	; 63

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
    73c2:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
    73c4:	81 ff       	sbrs	r24, 1
    73c6:	fd cf       	rjmp	.-6      	; 0x73c2 <sysclk_init+0x2e>
		default:
			//unhandled_case(CONFIG_SYSCLK_SOURCE);
			return;
		}

		ccp_write_io((uint8_t *)&CLK.CTRL, CONFIG_SYSCLK_SOURCE);
    73c8:	61 e0       	ldi	r22, 0x01	; 1
    73ca:	80 e4       	ldi	r24, 0x40	; 64
    73cc:	90 e0       	ldi	r25, 0x00	; 0
    73ce:	3d d0       	rcall	.+122    	; 0x744a <ccp_write_io>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    73d0:	8f b7       	in	r24, 0x3f	; 63
	cpu_irq_disable();
    73d2:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL &= ~id;
    73d4:	e0 e5       	ldi	r30, 0x50	; 80
    73d6:	f0 e0       	ldi	r31, 0x00	; 0
    73d8:	90 81       	ld	r25, Z
    73da:	9e 7f       	andi	r25, 0xFE	; 254
    73dc:	90 83       	st	Z, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    73de:	8f bf       	out	0x3f, r24	; 63
    73e0:	08 95       	ret

000073e2 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    73e2:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    73e4:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    73e6:	e8 2f       	mov	r30, r24
    73e8:	f0 e0       	ldi	r31, 0x00	; 0
    73ea:	e0 59       	subi	r30, 0x90	; 144
    73ec:	ff 4f       	sbci	r31, 0xFF	; 255
    73ee:	60 95       	com	r22
    73f0:	80 81       	ld	r24, Z
    73f2:	68 23       	and	r22, r24
    73f4:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    73f6:	9f bf       	out	0x3f, r25	; 63
    73f8:	08 95       	ret

000073fa <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    73fa:	cf 93       	push	r28
    73fc:	df 93       	push	r29
    73fe:	fc 01       	movw	r30, r24
    7400:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    7402:	20 e0       	ldi	r18, 0x00	; 0
    7404:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    7406:	c6 2f       	mov	r28, r22
    7408:	d0 e0       	ldi	r29, 0x00	; 0
    740a:	de 01       	movw	r26, r28
    740c:	02 2e       	mov	r0, r18
    740e:	02 c0       	rjmp	.+4      	; 0x7414 <ioport_configure_port_pin+0x1a>
    7410:	b5 95       	asr	r27
    7412:	a7 95       	ror	r26
    7414:	0a 94       	dec	r0
    7416:	e2 f7       	brpl	.-8      	; 0x7410 <ioport_configure_port_pin+0x16>
    7418:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    741a:	50 83       	st	Z, r21
    741c:	2f 5f       	subi	r18, 0xFF	; 255
    741e:	3f 4f       	sbci	r19, 0xFF	; 255
    7420:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    7422:	28 30       	cpi	r18, 0x08	; 8
    7424:	31 05       	cpc	r19, r1
    7426:	89 f7       	brne	.-30     	; 0x740a <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    7428:	40 ff       	sbrs	r20, 0
    742a:	0a c0       	rjmp	.+20     	; 0x7440 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    742c:	41 ff       	sbrs	r20, 1
    742e:	03 c0       	rjmp	.+6      	; 0x7436 <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    7430:	fc 01       	movw	r30, r24
    7432:	65 83       	std	Z+5, r22	; 0x05
    7434:	02 c0       	rjmp	.+4      	; 0x743a <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    7436:	fc 01       	movw	r30, r24
    7438:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    743a:	fc 01       	movw	r30, r24
    743c:	61 83       	std	Z+1, r22	; 0x01
    743e:	02 c0       	rjmp	.+4      	; 0x7444 <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    7440:	fc 01       	movw	r30, r24
    7442:	62 83       	std	Z+2, r22	; 0x02
	}
}
    7444:	df 91       	pop	r29
    7446:	cf 91       	pop	r28
    7448:	08 95       	ret

0000744a <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
    744a:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
    744c:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
    744e:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
    7450:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
    7452:	60 83       	st	Z, r22
	ret                             // Return to caller
    7454:	08 95       	ret

00007456 <__subsf3>:
    7456:	50 58       	subi	r21, 0x80	; 128

00007458 <__addsf3>:
    7458:	bb 27       	eor	r27, r27
    745a:	aa 27       	eor	r26, r26
    745c:	0e d0       	rcall	.+28     	; 0x747a <__addsf3x>
    745e:	e5 c0       	rjmp	.+458    	; 0x762a <__fp_round>
    7460:	d6 d0       	rcall	.+428    	; 0x760e <__fp_pscA>
    7462:	30 f0       	brcs	.+12     	; 0x7470 <__addsf3+0x18>
    7464:	db d0       	rcall	.+438    	; 0x761c <__fp_pscB>
    7466:	20 f0       	brcs	.+8      	; 0x7470 <__addsf3+0x18>
    7468:	31 f4       	brne	.+12     	; 0x7476 <__addsf3+0x1e>
    746a:	9f 3f       	cpi	r25, 0xFF	; 255
    746c:	11 f4       	brne	.+4      	; 0x7472 <__addsf3+0x1a>
    746e:	1e f4       	brtc	.+6      	; 0x7476 <__addsf3+0x1e>
    7470:	cb c0       	rjmp	.+406    	; 0x7608 <__fp_nan>
    7472:	0e f4       	brtc	.+2      	; 0x7476 <__addsf3+0x1e>
    7474:	e0 95       	com	r30
    7476:	e7 fb       	bst	r30, 7
    7478:	c1 c0       	rjmp	.+386    	; 0x75fc <__fp_inf>

0000747a <__addsf3x>:
    747a:	e9 2f       	mov	r30, r25
    747c:	e7 d0       	rcall	.+462    	; 0x764c <__fp_split3>
    747e:	80 f3       	brcs	.-32     	; 0x7460 <__addsf3+0x8>
    7480:	ba 17       	cp	r27, r26
    7482:	62 07       	cpc	r22, r18
    7484:	73 07       	cpc	r23, r19
    7486:	84 07       	cpc	r24, r20
    7488:	95 07       	cpc	r25, r21
    748a:	18 f0       	brcs	.+6      	; 0x7492 <__addsf3x+0x18>
    748c:	71 f4       	brne	.+28     	; 0x74aa <__addsf3x+0x30>
    748e:	9e f5       	brtc	.+102    	; 0x74f6 <__addsf3x+0x7c>
    7490:	ff c0       	rjmp	.+510    	; 0x7690 <__fp_zero>
    7492:	0e f4       	brtc	.+2      	; 0x7496 <__addsf3x+0x1c>
    7494:	e0 95       	com	r30
    7496:	0b 2e       	mov	r0, r27
    7498:	ba 2f       	mov	r27, r26
    749a:	a0 2d       	mov	r26, r0
    749c:	0b 01       	movw	r0, r22
    749e:	b9 01       	movw	r22, r18
    74a0:	90 01       	movw	r18, r0
    74a2:	0c 01       	movw	r0, r24
    74a4:	ca 01       	movw	r24, r20
    74a6:	a0 01       	movw	r20, r0
    74a8:	11 24       	eor	r1, r1
    74aa:	ff 27       	eor	r31, r31
    74ac:	59 1b       	sub	r21, r25
    74ae:	99 f0       	breq	.+38     	; 0x74d6 <__addsf3x+0x5c>
    74b0:	59 3f       	cpi	r21, 0xF9	; 249
    74b2:	50 f4       	brcc	.+20     	; 0x74c8 <__addsf3x+0x4e>
    74b4:	50 3e       	cpi	r21, 0xE0	; 224
    74b6:	68 f1       	brcs	.+90     	; 0x7512 <__addsf3x+0x98>
    74b8:	1a 16       	cp	r1, r26
    74ba:	f0 40       	sbci	r31, 0x00	; 0
    74bc:	a2 2f       	mov	r26, r18
    74be:	23 2f       	mov	r18, r19
    74c0:	34 2f       	mov	r19, r20
    74c2:	44 27       	eor	r20, r20
    74c4:	58 5f       	subi	r21, 0xF8	; 248
    74c6:	f3 cf       	rjmp	.-26     	; 0x74ae <__addsf3x+0x34>
    74c8:	46 95       	lsr	r20
    74ca:	37 95       	ror	r19
    74cc:	27 95       	ror	r18
    74ce:	a7 95       	ror	r26
    74d0:	f0 40       	sbci	r31, 0x00	; 0
    74d2:	53 95       	inc	r21
    74d4:	c9 f7       	brne	.-14     	; 0x74c8 <__addsf3x+0x4e>
    74d6:	7e f4       	brtc	.+30     	; 0x74f6 <__addsf3x+0x7c>
    74d8:	1f 16       	cp	r1, r31
    74da:	ba 0b       	sbc	r27, r26
    74dc:	62 0b       	sbc	r22, r18
    74de:	73 0b       	sbc	r23, r19
    74e0:	84 0b       	sbc	r24, r20
    74e2:	ba f0       	brmi	.+46     	; 0x7512 <__addsf3x+0x98>
    74e4:	91 50       	subi	r25, 0x01	; 1
    74e6:	a1 f0       	breq	.+40     	; 0x7510 <__addsf3x+0x96>
    74e8:	ff 0f       	add	r31, r31
    74ea:	bb 1f       	adc	r27, r27
    74ec:	66 1f       	adc	r22, r22
    74ee:	77 1f       	adc	r23, r23
    74f0:	88 1f       	adc	r24, r24
    74f2:	c2 f7       	brpl	.-16     	; 0x74e4 <__addsf3x+0x6a>
    74f4:	0e c0       	rjmp	.+28     	; 0x7512 <__addsf3x+0x98>
    74f6:	ba 0f       	add	r27, r26
    74f8:	62 1f       	adc	r22, r18
    74fa:	73 1f       	adc	r23, r19
    74fc:	84 1f       	adc	r24, r20
    74fe:	48 f4       	brcc	.+18     	; 0x7512 <__addsf3x+0x98>
    7500:	87 95       	ror	r24
    7502:	77 95       	ror	r23
    7504:	67 95       	ror	r22
    7506:	b7 95       	ror	r27
    7508:	f7 95       	ror	r31
    750a:	9e 3f       	cpi	r25, 0xFE	; 254
    750c:	08 f0       	brcs	.+2      	; 0x7510 <__addsf3x+0x96>
    750e:	b3 cf       	rjmp	.-154    	; 0x7476 <__addsf3+0x1e>
    7510:	93 95       	inc	r25
    7512:	88 0f       	add	r24, r24
    7514:	08 f0       	brcs	.+2      	; 0x7518 <__addsf3x+0x9e>
    7516:	99 27       	eor	r25, r25
    7518:	ee 0f       	add	r30, r30
    751a:	97 95       	ror	r25
    751c:	87 95       	ror	r24
    751e:	08 95       	ret

00007520 <__fixsfsi>:
    7520:	04 d0       	rcall	.+8      	; 0x752a <__fixunssfsi>
    7522:	68 94       	set
    7524:	b1 11       	cpse	r27, r1
    7526:	b5 c0       	rjmp	.+362    	; 0x7692 <__fp_szero>
    7528:	08 95       	ret

0000752a <__fixunssfsi>:
    752a:	98 d0       	rcall	.+304    	; 0x765c <__fp_splitA>
    752c:	88 f0       	brcs	.+34     	; 0x7550 <__fixunssfsi+0x26>
    752e:	9f 57       	subi	r25, 0x7F	; 127
    7530:	90 f0       	brcs	.+36     	; 0x7556 <__fixunssfsi+0x2c>
    7532:	b9 2f       	mov	r27, r25
    7534:	99 27       	eor	r25, r25
    7536:	b7 51       	subi	r27, 0x17	; 23
    7538:	a0 f0       	brcs	.+40     	; 0x7562 <__fixunssfsi+0x38>
    753a:	d1 f0       	breq	.+52     	; 0x7570 <__fixunssfsi+0x46>
    753c:	66 0f       	add	r22, r22
    753e:	77 1f       	adc	r23, r23
    7540:	88 1f       	adc	r24, r24
    7542:	99 1f       	adc	r25, r25
    7544:	1a f0       	brmi	.+6      	; 0x754c <__fixunssfsi+0x22>
    7546:	ba 95       	dec	r27
    7548:	c9 f7       	brne	.-14     	; 0x753c <__fixunssfsi+0x12>
    754a:	12 c0       	rjmp	.+36     	; 0x7570 <__fixunssfsi+0x46>
    754c:	b1 30       	cpi	r27, 0x01	; 1
    754e:	81 f0       	breq	.+32     	; 0x7570 <__fixunssfsi+0x46>
    7550:	9f d0       	rcall	.+318    	; 0x7690 <__fp_zero>
    7552:	b1 e0       	ldi	r27, 0x01	; 1
    7554:	08 95       	ret
    7556:	9c c0       	rjmp	.+312    	; 0x7690 <__fp_zero>
    7558:	67 2f       	mov	r22, r23
    755a:	78 2f       	mov	r23, r24
    755c:	88 27       	eor	r24, r24
    755e:	b8 5f       	subi	r27, 0xF8	; 248
    7560:	39 f0       	breq	.+14     	; 0x7570 <__fixunssfsi+0x46>
    7562:	b9 3f       	cpi	r27, 0xF9	; 249
    7564:	cc f3       	brlt	.-14     	; 0x7558 <__fixunssfsi+0x2e>
    7566:	86 95       	lsr	r24
    7568:	77 95       	ror	r23
    756a:	67 95       	ror	r22
    756c:	b3 95       	inc	r27
    756e:	d9 f7       	brne	.-10     	; 0x7566 <__fixunssfsi+0x3c>
    7570:	3e f4       	brtc	.+14     	; 0x7580 <__fixunssfsi+0x56>
    7572:	90 95       	com	r25
    7574:	80 95       	com	r24
    7576:	70 95       	com	r23
    7578:	61 95       	neg	r22
    757a:	7f 4f       	sbci	r23, 0xFF	; 255
    757c:	8f 4f       	sbci	r24, 0xFF	; 255
    757e:	9f 4f       	sbci	r25, 0xFF	; 255
    7580:	08 95       	ret

00007582 <__floatunsisf>:
    7582:	e8 94       	clt
    7584:	09 c0       	rjmp	.+18     	; 0x7598 <__floatsisf+0x12>

00007586 <__floatsisf>:
    7586:	97 fb       	bst	r25, 7
    7588:	3e f4       	brtc	.+14     	; 0x7598 <__floatsisf+0x12>
    758a:	90 95       	com	r25
    758c:	80 95       	com	r24
    758e:	70 95       	com	r23
    7590:	61 95       	neg	r22
    7592:	7f 4f       	sbci	r23, 0xFF	; 255
    7594:	8f 4f       	sbci	r24, 0xFF	; 255
    7596:	9f 4f       	sbci	r25, 0xFF	; 255
    7598:	99 23       	and	r25, r25
    759a:	a9 f0       	breq	.+42     	; 0x75c6 <__floatsisf+0x40>
    759c:	f9 2f       	mov	r31, r25
    759e:	96 e9       	ldi	r25, 0x96	; 150
    75a0:	bb 27       	eor	r27, r27
    75a2:	93 95       	inc	r25
    75a4:	f6 95       	lsr	r31
    75a6:	87 95       	ror	r24
    75a8:	77 95       	ror	r23
    75aa:	67 95       	ror	r22
    75ac:	b7 95       	ror	r27
    75ae:	f1 11       	cpse	r31, r1
    75b0:	f8 cf       	rjmp	.-16     	; 0x75a2 <__floatsisf+0x1c>
    75b2:	fa f4       	brpl	.+62     	; 0x75f2 <__floatsisf+0x6c>
    75b4:	bb 0f       	add	r27, r27
    75b6:	11 f4       	brne	.+4      	; 0x75bc <__floatsisf+0x36>
    75b8:	60 ff       	sbrs	r22, 0
    75ba:	1b c0       	rjmp	.+54     	; 0x75f2 <__floatsisf+0x6c>
    75bc:	6f 5f       	subi	r22, 0xFF	; 255
    75be:	7f 4f       	sbci	r23, 0xFF	; 255
    75c0:	8f 4f       	sbci	r24, 0xFF	; 255
    75c2:	9f 4f       	sbci	r25, 0xFF	; 255
    75c4:	16 c0       	rjmp	.+44     	; 0x75f2 <__floatsisf+0x6c>
    75c6:	88 23       	and	r24, r24
    75c8:	11 f0       	breq	.+4      	; 0x75ce <__floatsisf+0x48>
    75ca:	96 e9       	ldi	r25, 0x96	; 150
    75cc:	11 c0       	rjmp	.+34     	; 0x75f0 <__floatsisf+0x6a>
    75ce:	77 23       	and	r23, r23
    75d0:	21 f0       	breq	.+8      	; 0x75da <__floatsisf+0x54>
    75d2:	9e e8       	ldi	r25, 0x8E	; 142
    75d4:	87 2f       	mov	r24, r23
    75d6:	76 2f       	mov	r23, r22
    75d8:	05 c0       	rjmp	.+10     	; 0x75e4 <__floatsisf+0x5e>
    75da:	66 23       	and	r22, r22
    75dc:	71 f0       	breq	.+28     	; 0x75fa <__floatsisf+0x74>
    75de:	96 e8       	ldi	r25, 0x86	; 134
    75e0:	86 2f       	mov	r24, r22
    75e2:	70 e0       	ldi	r23, 0x00	; 0
    75e4:	60 e0       	ldi	r22, 0x00	; 0
    75e6:	2a f0       	brmi	.+10     	; 0x75f2 <__floatsisf+0x6c>
    75e8:	9a 95       	dec	r25
    75ea:	66 0f       	add	r22, r22
    75ec:	77 1f       	adc	r23, r23
    75ee:	88 1f       	adc	r24, r24
    75f0:	da f7       	brpl	.-10     	; 0x75e8 <__floatsisf+0x62>
    75f2:	88 0f       	add	r24, r24
    75f4:	96 95       	lsr	r25
    75f6:	87 95       	ror	r24
    75f8:	97 f9       	bld	r25, 7
    75fa:	08 95       	ret

000075fc <__fp_inf>:
    75fc:	97 f9       	bld	r25, 7
    75fe:	9f 67       	ori	r25, 0x7F	; 127
    7600:	80 e8       	ldi	r24, 0x80	; 128
    7602:	70 e0       	ldi	r23, 0x00	; 0
    7604:	60 e0       	ldi	r22, 0x00	; 0
    7606:	08 95       	ret

00007608 <__fp_nan>:
    7608:	9f ef       	ldi	r25, 0xFF	; 255
    760a:	80 ec       	ldi	r24, 0xC0	; 192
    760c:	08 95       	ret

0000760e <__fp_pscA>:
    760e:	00 24       	eor	r0, r0
    7610:	0a 94       	dec	r0
    7612:	16 16       	cp	r1, r22
    7614:	17 06       	cpc	r1, r23
    7616:	18 06       	cpc	r1, r24
    7618:	09 06       	cpc	r0, r25
    761a:	08 95       	ret

0000761c <__fp_pscB>:
    761c:	00 24       	eor	r0, r0
    761e:	0a 94       	dec	r0
    7620:	12 16       	cp	r1, r18
    7622:	13 06       	cpc	r1, r19
    7624:	14 06       	cpc	r1, r20
    7626:	05 06       	cpc	r0, r21
    7628:	08 95       	ret

0000762a <__fp_round>:
    762a:	09 2e       	mov	r0, r25
    762c:	03 94       	inc	r0
    762e:	00 0c       	add	r0, r0
    7630:	11 f4       	brne	.+4      	; 0x7636 <__fp_round+0xc>
    7632:	88 23       	and	r24, r24
    7634:	52 f0       	brmi	.+20     	; 0x764a <__fp_round+0x20>
    7636:	bb 0f       	add	r27, r27
    7638:	40 f4       	brcc	.+16     	; 0x764a <__fp_round+0x20>
    763a:	bf 2b       	or	r27, r31
    763c:	11 f4       	brne	.+4      	; 0x7642 <__fp_round+0x18>
    763e:	60 ff       	sbrs	r22, 0
    7640:	04 c0       	rjmp	.+8      	; 0x764a <__fp_round+0x20>
    7642:	6f 5f       	subi	r22, 0xFF	; 255
    7644:	7f 4f       	sbci	r23, 0xFF	; 255
    7646:	8f 4f       	sbci	r24, 0xFF	; 255
    7648:	9f 4f       	sbci	r25, 0xFF	; 255
    764a:	08 95       	ret

0000764c <__fp_split3>:
    764c:	57 fd       	sbrc	r21, 7
    764e:	90 58       	subi	r25, 0x80	; 128
    7650:	44 0f       	add	r20, r20
    7652:	55 1f       	adc	r21, r21
    7654:	59 f0       	breq	.+22     	; 0x766c <__fp_splitA+0x10>
    7656:	5f 3f       	cpi	r21, 0xFF	; 255
    7658:	71 f0       	breq	.+28     	; 0x7676 <__fp_splitA+0x1a>
    765a:	47 95       	ror	r20

0000765c <__fp_splitA>:
    765c:	88 0f       	add	r24, r24
    765e:	97 fb       	bst	r25, 7
    7660:	99 1f       	adc	r25, r25
    7662:	61 f0       	breq	.+24     	; 0x767c <__fp_splitA+0x20>
    7664:	9f 3f       	cpi	r25, 0xFF	; 255
    7666:	79 f0       	breq	.+30     	; 0x7686 <__fp_splitA+0x2a>
    7668:	87 95       	ror	r24
    766a:	08 95       	ret
    766c:	12 16       	cp	r1, r18
    766e:	13 06       	cpc	r1, r19
    7670:	14 06       	cpc	r1, r20
    7672:	55 1f       	adc	r21, r21
    7674:	f2 cf       	rjmp	.-28     	; 0x765a <__fp_split3+0xe>
    7676:	46 95       	lsr	r20
    7678:	f1 df       	rcall	.-30     	; 0x765c <__fp_splitA>
    767a:	08 c0       	rjmp	.+16     	; 0x768c <__fp_splitA+0x30>
    767c:	16 16       	cp	r1, r22
    767e:	17 06       	cpc	r1, r23
    7680:	18 06       	cpc	r1, r24
    7682:	99 1f       	adc	r25, r25
    7684:	f1 cf       	rjmp	.-30     	; 0x7668 <__fp_splitA+0xc>
    7686:	86 95       	lsr	r24
    7688:	71 05       	cpc	r23, r1
    768a:	61 05       	cpc	r22, r1
    768c:	08 94       	sec
    768e:	08 95       	ret

00007690 <__fp_zero>:
    7690:	e8 94       	clt

00007692 <__fp_szero>:
    7692:	bb 27       	eor	r27, r27
    7694:	66 27       	eor	r22, r22
    7696:	77 27       	eor	r23, r23
    7698:	cb 01       	movw	r24, r22
    769a:	97 f9       	bld	r25, 7
    769c:	08 95       	ret
    769e:	0e f0       	brts	.+2      	; 0x76a2 <__fp_szero+0x10>
    76a0:	a6 c0       	rjmp	.+332    	; 0x77ee <__fp_mpack>
    76a2:	b2 cf       	rjmp	.-156    	; 0x7608 <__fp_nan>
    76a4:	68 94       	set
    76a6:	aa cf       	rjmp	.-172    	; 0x75fc <__fp_inf>

000076a8 <log>:
    76a8:	d9 df       	rcall	.-78     	; 0x765c <__fp_splitA>
    76aa:	c8 f3       	brcs	.-14     	; 0x769e <__fp_szero+0xc>
    76ac:	99 23       	and	r25, r25
    76ae:	d1 f3       	breq	.-12     	; 0x76a4 <__fp_szero+0x12>
    76b0:	c6 f3       	brts	.-16     	; 0x76a2 <__fp_szero+0x10>
    76b2:	df 93       	push	r29
    76b4:	cf 93       	push	r28
    76b6:	1f 93       	push	r17
    76b8:	0f 93       	push	r16
    76ba:	ff 92       	push	r15
    76bc:	c9 2f       	mov	r28, r25
    76be:	dd 27       	eor	r29, r29
    76c0:	88 23       	and	r24, r24
    76c2:	2a f0       	brmi	.+10     	; 0x76ce <log+0x26>
    76c4:	21 97       	sbiw	r28, 0x01	; 1
    76c6:	66 0f       	add	r22, r22
    76c8:	77 1f       	adc	r23, r23
    76ca:	88 1f       	adc	r24, r24
    76cc:	da f7       	brpl	.-10     	; 0x76c4 <log+0x1c>
    76ce:	20 e0       	ldi	r18, 0x00	; 0
    76d0:	30 e0       	ldi	r19, 0x00	; 0
    76d2:	40 e8       	ldi	r20, 0x80	; 128
    76d4:	5f eb       	ldi	r21, 0xBF	; 191
    76d6:	9f e3       	ldi	r25, 0x3F	; 63
    76d8:	88 39       	cpi	r24, 0x98	; 152
    76da:	20 f0       	brcs	.+8      	; 0x76e4 <log+0x3c>
    76dc:	80 3e       	cpi	r24, 0xE0	; 224
    76de:	30 f0       	brcs	.+12     	; 0x76ec <log+0x44>
    76e0:	21 96       	adiw	r28, 0x01	; 1
    76e2:	8f 77       	andi	r24, 0x7F	; 127
    76e4:	b9 de       	rcall	.-654    	; 0x7458 <__addsf3>
    76e6:	ee e2       	ldi	r30, 0x2E	; 46
    76e8:	f2 e0       	ldi	r31, 0x02	; 2
    76ea:	03 c0       	rjmp	.+6      	; 0x76f2 <log+0x4a>
    76ec:	b5 de       	rcall	.-662    	; 0x7458 <__addsf3>
    76ee:	eb e5       	ldi	r30, 0x5B	; 91
    76f0:	f2 e0       	ldi	r31, 0x02	; 2
    76f2:	8b d0       	rcall	.+278    	; 0x780a <__fp_powser>
    76f4:	8b 01       	movw	r16, r22
    76f6:	be 01       	movw	r22, r28
    76f8:	ec 01       	movw	r28, r24
    76fa:	fb 2e       	mov	r15, r27
    76fc:	6f 57       	subi	r22, 0x7F	; 127
    76fe:	71 09       	sbc	r23, r1
    7700:	75 95       	asr	r23
    7702:	77 1f       	adc	r23, r23
    7704:	88 0b       	sbc	r24, r24
    7706:	99 0b       	sbc	r25, r25
    7708:	3e df       	rcall	.-388    	; 0x7586 <__floatsisf>
    770a:	28 e1       	ldi	r18, 0x18	; 24
    770c:	32 e7       	ldi	r19, 0x72	; 114
    770e:	41 e3       	ldi	r20, 0x31	; 49
    7710:	5f e3       	ldi	r21, 0x3F	; 63
    7712:	16 d0       	rcall	.+44     	; 0x7740 <__mulsf3x>
    7714:	af 2d       	mov	r26, r15
    7716:	98 01       	movw	r18, r16
    7718:	ae 01       	movw	r20, r28
    771a:	ff 90       	pop	r15
    771c:	0f 91       	pop	r16
    771e:	1f 91       	pop	r17
    7720:	cf 91       	pop	r28
    7722:	df 91       	pop	r29
    7724:	aa de       	rcall	.-684    	; 0x747a <__addsf3x>
    7726:	81 cf       	rjmp	.-254    	; 0x762a <__fp_round>

00007728 <__mulsf3>:
    7728:	0b d0       	rcall	.+22     	; 0x7740 <__mulsf3x>
    772a:	7f cf       	rjmp	.-258    	; 0x762a <__fp_round>
    772c:	70 df       	rcall	.-288    	; 0x760e <__fp_pscA>
    772e:	28 f0       	brcs	.+10     	; 0x773a <__mulsf3+0x12>
    7730:	75 df       	rcall	.-278    	; 0x761c <__fp_pscB>
    7732:	18 f0       	brcs	.+6      	; 0x773a <__mulsf3+0x12>
    7734:	95 23       	and	r25, r21
    7736:	09 f0       	breq	.+2      	; 0x773a <__mulsf3+0x12>
    7738:	61 cf       	rjmp	.-318    	; 0x75fc <__fp_inf>
    773a:	66 cf       	rjmp	.-308    	; 0x7608 <__fp_nan>
    773c:	11 24       	eor	r1, r1
    773e:	a9 cf       	rjmp	.-174    	; 0x7692 <__fp_szero>

00007740 <__mulsf3x>:
    7740:	85 df       	rcall	.-246    	; 0x764c <__fp_split3>
    7742:	a0 f3       	brcs	.-24     	; 0x772c <__mulsf3+0x4>

00007744 <__mulsf3_pse>:
    7744:	95 9f       	mul	r25, r21
    7746:	d1 f3       	breq	.-12     	; 0x773c <__mulsf3+0x14>
    7748:	95 0f       	add	r25, r21
    774a:	50 e0       	ldi	r21, 0x00	; 0
    774c:	55 1f       	adc	r21, r21
    774e:	62 9f       	mul	r22, r18
    7750:	f0 01       	movw	r30, r0
    7752:	72 9f       	mul	r23, r18
    7754:	bb 27       	eor	r27, r27
    7756:	f0 0d       	add	r31, r0
    7758:	b1 1d       	adc	r27, r1
    775a:	63 9f       	mul	r22, r19
    775c:	aa 27       	eor	r26, r26
    775e:	f0 0d       	add	r31, r0
    7760:	b1 1d       	adc	r27, r1
    7762:	aa 1f       	adc	r26, r26
    7764:	64 9f       	mul	r22, r20
    7766:	66 27       	eor	r22, r22
    7768:	b0 0d       	add	r27, r0
    776a:	a1 1d       	adc	r26, r1
    776c:	66 1f       	adc	r22, r22
    776e:	82 9f       	mul	r24, r18
    7770:	22 27       	eor	r18, r18
    7772:	b0 0d       	add	r27, r0
    7774:	a1 1d       	adc	r26, r1
    7776:	62 1f       	adc	r22, r18
    7778:	73 9f       	mul	r23, r19
    777a:	b0 0d       	add	r27, r0
    777c:	a1 1d       	adc	r26, r1
    777e:	62 1f       	adc	r22, r18
    7780:	83 9f       	mul	r24, r19
    7782:	a0 0d       	add	r26, r0
    7784:	61 1d       	adc	r22, r1
    7786:	22 1f       	adc	r18, r18
    7788:	74 9f       	mul	r23, r20
    778a:	33 27       	eor	r19, r19
    778c:	a0 0d       	add	r26, r0
    778e:	61 1d       	adc	r22, r1
    7790:	23 1f       	adc	r18, r19
    7792:	84 9f       	mul	r24, r20
    7794:	60 0d       	add	r22, r0
    7796:	21 1d       	adc	r18, r1
    7798:	82 2f       	mov	r24, r18
    779a:	76 2f       	mov	r23, r22
    779c:	6a 2f       	mov	r22, r26
    779e:	11 24       	eor	r1, r1
    77a0:	9f 57       	subi	r25, 0x7F	; 127
    77a2:	50 40       	sbci	r21, 0x00	; 0
    77a4:	8a f0       	brmi	.+34     	; 0x77c8 <__mulsf3_pse+0x84>
    77a6:	e1 f0       	breq	.+56     	; 0x77e0 <__mulsf3_pse+0x9c>
    77a8:	88 23       	and	r24, r24
    77aa:	4a f0       	brmi	.+18     	; 0x77be <__mulsf3_pse+0x7a>
    77ac:	ee 0f       	add	r30, r30
    77ae:	ff 1f       	adc	r31, r31
    77b0:	bb 1f       	adc	r27, r27
    77b2:	66 1f       	adc	r22, r22
    77b4:	77 1f       	adc	r23, r23
    77b6:	88 1f       	adc	r24, r24
    77b8:	91 50       	subi	r25, 0x01	; 1
    77ba:	50 40       	sbci	r21, 0x00	; 0
    77bc:	a9 f7       	brne	.-22     	; 0x77a8 <__mulsf3_pse+0x64>
    77be:	9e 3f       	cpi	r25, 0xFE	; 254
    77c0:	51 05       	cpc	r21, r1
    77c2:	70 f0       	brcs	.+28     	; 0x77e0 <__mulsf3_pse+0x9c>
    77c4:	1b cf       	rjmp	.-458    	; 0x75fc <__fp_inf>
    77c6:	65 cf       	rjmp	.-310    	; 0x7692 <__fp_szero>
    77c8:	5f 3f       	cpi	r21, 0xFF	; 255
    77ca:	ec f3       	brlt	.-6      	; 0x77c6 <__mulsf3_pse+0x82>
    77cc:	98 3e       	cpi	r25, 0xE8	; 232
    77ce:	dc f3       	brlt	.-10     	; 0x77c6 <__mulsf3_pse+0x82>
    77d0:	86 95       	lsr	r24
    77d2:	77 95       	ror	r23
    77d4:	67 95       	ror	r22
    77d6:	b7 95       	ror	r27
    77d8:	f7 95       	ror	r31
    77da:	e7 95       	ror	r30
    77dc:	9f 5f       	subi	r25, 0xFF	; 255
    77de:	c1 f7       	brne	.-16     	; 0x77d0 <__mulsf3_pse+0x8c>
    77e0:	fe 2b       	or	r31, r30
    77e2:	88 0f       	add	r24, r24
    77e4:	91 1d       	adc	r25, r1
    77e6:	96 95       	lsr	r25
    77e8:	87 95       	ror	r24
    77ea:	97 f9       	bld	r25, 7
    77ec:	08 95       	ret

000077ee <__fp_mpack>:
    77ee:	9f 3f       	cpi	r25, 0xFF	; 255
    77f0:	31 f0       	breq	.+12     	; 0x77fe <__fp_mpack_finite+0xc>

000077f2 <__fp_mpack_finite>:
    77f2:	91 50       	subi	r25, 0x01	; 1
    77f4:	20 f4       	brcc	.+8      	; 0x77fe <__fp_mpack_finite+0xc>
    77f6:	87 95       	ror	r24
    77f8:	77 95       	ror	r23
    77fa:	67 95       	ror	r22
    77fc:	b7 95       	ror	r27
    77fe:	88 0f       	add	r24, r24
    7800:	91 1d       	adc	r25, r1
    7802:	96 95       	lsr	r25
    7804:	87 95       	ror	r24
    7806:	97 f9       	bld	r25, 7
    7808:	08 95       	ret

0000780a <__fp_powser>:
    780a:	df 93       	push	r29
    780c:	cf 93       	push	r28
    780e:	1f 93       	push	r17
    7810:	0f 93       	push	r16
    7812:	ff 92       	push	r15
    7814:	ef 92       	push	r14
    7816:	df 92       	push	r13
    7818:	7b 01       	movw	r14, r22
    781a:	8c 01       	movw	r16, r24
    781c:	68 94       	set
    781e:	05 c0       	rjmp	.+10     	; 0x782a <__fp_powser+0x20>
    7820:	da 2e       	mov	r13, r26
    7822:	ef 01       	movw	r28, r30
    7824:	8d df       	rcall	.-230    	; 0x7740 <__mulsf3x>
    7826:	fe 01       	movw	r30, r28
    7828:	e8 94       	clt
    782a:	a5 91       	lpm	r26, Z+
    782c:	25 91       	lpm	r18, Z+
    782e:	35 91       	lpm	r19, Z+
    7830:	45 91       	lpm	r20, Z+
    7832:	55 91       	lpm	r21, Z+
    7834:	ae f3       	brts	.-22     	; 0x7820 <__fp_powser+0x16>
    7836:	ef 01       	movw	r28, r30
    7838:	20 de       	rcall	.-960    	; 0x747a <__addsf3x>
    783a:	fe 01       	movw	r30, r28
    783c:	97 01       	movw	r18, r14
    783e:	a8 01       	movw	r20, r16
    7840:	da 94       	dec	r13
    7842:	79 f7       	brne	.-34     	; 0x7822 <__fp_powser+0x18>
    7844:	df 90       	pop	r13
    7846:	ef 90       	pop	r14
    7848:	ff 90       	pop	r15
    784a:	0f 91       	pop	r16
    784c:	1f 91       	pop	r17
    784e:	cf 91       	pop	r28
    7850:	df 91       	pop	r29
    7852:	08 95       	ret

00007854 <vfprintf>:
    7854:	2f 92       	push	r2
    7856:	3f 92       	push	r3
    7858:	4f 92       	push	r4
    785a:	5f 92       	push	r5
    785c:	6f 92       	push	r6
    785e:	7f 92       	push	r7
    7860:	8f 92       	push	r8
    7862:	9f 92       	push	r9
    7864:	af 92       	push	r10
    7866:	bf 92       	push	r11
    7868:	cf 92       	push	r12
    786a:	df 92       	push	r13
    786c:	ef 92       	push	r14
    786e:	ff 92       	push	r15
    7870:	0f 93       	push	r16
    7872:	1f 93       	push	r17
    7874:	cf 93       	push	r28
    7876:	df 93       	push	r29
    7878:	cd b7       	in	r28, 0x3d	; 61
    787a:	de b7       	in	r29, 0x3e	; 62
    787c:	63 97       	sbiw	r28, 0x13	; 19
    787e:	cd bf       	out	0x3d, r28	; 61
    7880:	de bf       	out	0x3e, r29	; 62
    7882:	7c 01       	movw	r14, r24
    7884:	1b 01       	movw	r2, r22
    7886:	6a 01       	movw	r12, r20
    7888:	fc 01       	movw	r30, r24
    788a:	16 82       	std	Z+6, r1	; 0x06
    788c:	17 82       	std	Z+7, r1	; 0x07
    788e:	83 81       	ldd	r24, Z+3	; 0x03
    7890:	81 ff       	sbrs	r24, 1
    7892:	49 c3       	rjmp	.+1682   	; 0x7f26 <vfprintf+0x6d2>
    7894:	be 01       	movw	r22, r28
    7896:	6f 5f       	subi	r22, 0xFF	; 255
    7898:	7f 4f       	sbci	r23, 0xFF	; 255
    789a:	4b 01       	movw	r8, r22
    789c:	f7 01       	movw	r30, r14
    789e:	93 81       	ldd	r25, Z+3	; 0x03
    78a0:	f1 01       	movw	r30, r2
    78a2:	93 fd       	sbrc	r25, 3
    78a4:	85 91       	lpm	r24, Z+
    78a6:	93 ff       	sbrs	r25, 3
    78a8:	81 91       	ld	r24, Z+
    78aa:	1f 01       	movw	r2, r30
    78ac:	88 23       	and	r24, r24
    78ae:	09 f4       	brne	.+2      	; 0x78b2 <vfprintf+0x5e>
    78b0:	36 c3       	rjmp	.+1644   	; 0x7f1e <vfprintf+0x6ca>
    78b2:	85 32       	cpi	r24, 0x25	; 37
    78b4:	39 f4       	brne	.+14     	; 0x78c4 <vfprintf+0x70>
    78b6:	93 fd       	sbrc	r25, 3
    78b8:	85 91       	lpm	r24, Z+
    78ba:	93 ff       	sbrs	r25, 3
    78bc:	81 91       	ld	r24, Z+
    78be:	1f 01       	movw	r2, r30
    78c0:	85 32       	cpi	r24, 0x25	; 37
    78c2:	31 f4       	brne	.+12     	; 0x78d0 <vfprintf+0x7c>
    78c4:	b7 01       	movw	r22, r14
    78c6:	90 e0       	ldi	r25, 0x00	; 0
    78c8:	3a d5       	rcall	.+2676   	; 0x833e <fputc>
    78ca:	56 01       	movw	r10, r12
    78cc:	65 01       	movw	r12, r10
    78ce:	e6 cf       	rjmp	.-52     	; 0x789c <vfprintf+0x48>
    78d0:	10 e0       	ldi	r17, 0x00	; 0
    78d2:	51 2c       	mov	r5, r1
    78d4:	20 e0       	ldi	r18, 0x00	; 0
    78d6:	20 32       	cpi	r18, 0x20	; 32
    78d8:	a0 f4       	brcc	.+40     	; 0x7902 <vfprintf+0xae>
    78da:	8b 32       	cpi	r24, 0x2B	; 43
    78dc:	69 f0       	breq	.+26     	; 0x78f8 <vfprintf+0xa4>
    78de:	30 f4       	brcc	.+12     	; 0x78ec <vfprintf+0x98>
    78e0:	80 32       	cpi	r24, 0x20	; 32
    78e2:	59 f0       	breq	.+22     	; 0x78fa <vfprintf+0xa6>
    78e4:	83 32       	cpi	r24, 0x23	; 35
    78e6:	69 f4       	brne	.+26     	; 0x7902 <vfprintf+0xae>
    78e8:	20 61       	ori	r18, 0x10	; 16
    78ea:	2c c0       	rjmp	.+88     	; 0x7944 <vfprintf+0xf0>
    78ec:	8d 32       	cpi	r24, 0x2D	; 45
    78ee:	39 f0       	breq	.+14     	; 0x78fe <vfprintf+0xaa>
    78f0:	80 33       	cpi	r24, 0x30	; 48
    78f2:	39 f4       	brne	.+14     	; 0x7902 <vfprintf+0xae>
    78f4:	21 60       	ori	r18, 0x01	; 1
    78f6:	26 c0       	rjmp	.+76     	; 0x7944 <vfprintf+0xf0>
    78f8:	22 60       	ori	r18, 0x02	; 2
    78fa:	24 60       	ori	r18, 0x04	; 4
    78fc:	23 c0       	rjmp	.+70     	; 0x7944 <vfprintf+0xf0>
    78fe:	28 60       	ori	r18, 0x08	; 8
    7900:	21 c0       	rjmp	.+66     	; 0x7944 <vfprintf+0xf0>
    7902:	27 fd       	sbrc	r18, 7
    7904:	27 c0       	rjmp	.+78     	; 0x7954 <vfprintf+0x100>
    7906:	30 ed       	ldi	r19, 0xD0	; 208
    7908:	38 0f       	add	r19, r24
    790a:	3a 30       	cpi	r19, 0x0A	; 10
    790c:	78 f4       	brcc	.+30     	; 0x792c <vfprintf+0xd8>
    790e:	26 ff       	sbrs	r18, 6
    7910:	06 c0       	rjmp	.+12     	; 0x791e <vfprintf+0xca>
    7912:	fa e0       	ldi	r31, 0x0A	; 10
    7914:	1f 9f       	mul	r17, r31
    7916:	30 0d       	add	r19, r0
    7918:	11 24       	eor	r1, r1
    791a:	13 2f       	mov	r17, r19
    791c:	13 c0       	rjmp	.+38     	; 0x7944 <vfprintf+0xf0>
    791e:	6a e0       	ldi	r22, 0x0A	; 10
    7920:	56 9e       	mul	r5, r22
    7922:	30 0d       	add	r19, r0
    7924:	11 24       	eor	r1, r1
    7926:	53 2e       	mov	r5, r19
    7928:	20 62       	ori	r18, 0x20	; 32
    792a:	0c c0       	rjmp	.+24     	; 0x7944 <vfprintf+0xf0>
    792c:	8e 32       	cpi	r24, 0x2E	; 46
    792e:	21 f4       	brne	.+8      	; 0x7938 <vfprintf+0xe4>
    7930:	26 fd       	sbrc	r18, 6
    7932:	f5 c2       	rjmp	.+1514   	; 0x7f1e <vfprintf+0x6ca>
    7934:	20 64       	ori	r18, 0x40	; 64
    7936:	06 c0       	rjmp	.+12     	; 0x7944 <vfprintf+0xf0>
    7938:	8c 36       	cpi	r24, 0x6C	; 108
    793a:	11 f4       	brne	.+4      	; 0x7940 <vfprintf+0xec>
    793c:	20 68       	ori	r18, 0x80	; 128
    793e:	02 c0       	rjmp	.+4      	; 0x7944 <vfprintf+0xf0>
    7940:	88 36       	cpi	r24, 0x68	; 104
    7942:	41 f4       	brne	.+16     	; 0x7954 <vfprintf+0x100>
    7944:	f1 01       	movw	r30, r2
    7946:	93 fd       	sbrc	r25, 3
    7948:	85 91       	lpm	r24, Z+
    794a:	93 ff       	sbrs	r25, 3
    794c:	81 91       	ld	r24, Z+
    794e:	1f 01       	movw	r2, r30
    7950:	81 11       	cpse	r24, r1
    7952:	c1 cf       	rjmp	.-126    	; 0x78d6 <vfprintf+0x82>
    7954:	9b eb       	ldi	r25, 0xBB	; 187
    7956:	98 0f       	add	r25, r24
    7958:	93 30       	cpi	r25, 0x03	; 3
    795a:	18 f4       	brcc	.+6      	; 0x7962 <vfprintf+0x10e>
    795c:	20 61       	ori	r18, 0x10	; 16
    795e:	80 5e       	subi	r24, 0xE0	; 224
    7960:	06 c0       	rjmp	.+12     	; 0x796e <vfprintf+0x11a>
    7962:	9b e9       	ldi	r25, 0x9B	; 155
    7964:	98 0f       	add	r25, r24
    7966:	93 30       	cpi	r25, 0x03	; 3
    7968:	08 f0       	brcs	.+2      	; 0x796c <vfprintf+0x118>
    796a:	9a c1       	rjmp	.+820    	; 0x7ca0 <vfprintf+0x44c>
    796c:	2f 7e       	andi	r18, 0xEF	; 239
    796e:	26 ff       	sbrs	r18, 6
    7970:	16 e0       	ldi	r17, 0x06	; 6
    7972:	2f 73       	andi	r18, 0x3F	; 63
    7974:	72 2e       	mov	r7, r18
    7976:	85 36       	cpi	r24, 0x65	; 101
    7978:	21 f4       	brne	.+8      	; 0x7982 <vfprintf+0x12e>
    797a:	f2 2f       	mov	r31, r18
    797c:	f0 64       	ori	r31, 0x40	; 64
    797e:	7f 2e       	mov	r7, r31
    7980:	08 c0       	rjmp	.+16     	; 0x7992 <vfprintf+0x13e>
    7982:	86 36       	cpi	r24, 0x66	; 102
    7984:	21 f4       	brne	.+8      	; 0x798e <vfprintf+0x13a>
    7986:	62 2f       	mov	r22, r18
    7988:	60 68       	ori	r22, 0x80	; 128
    798a:	76 2e       	mov	r7, r22
    798c:	02 c0       	rjmp	.+4      	; 0x7992 <vfprintf+0x13e>
    798e:	11 11       	cpse	r17, r1
    7990:	11 50       	subi	r17, 0x01	; 1
    7992:	77 fe       	sbrs	r7, 7
    7994:	07 c0       	rjmp	.+14     	; 0x79a4 <vfprintf+0x150>
    7996:	1c 33       	cpi	r17, 0x3C	; 60
    7998:	48 f4       	brcc	.+18     	; 0x79ac <vfprintf+0x158>
    799a:	44 24       	eor	r4, r4
    799c:	43 94       	inc	r4
    799e:	41 0e       	add	r4, r17
    79a0:	27 e0       	ldi	r18, 0x07	; 7
    79a2:	0b c0       	rjmp	.+22     	; 0x79ba <vfprintf+0x166>
    79a4:	18 30       	cpi	r17, 0x08	; 8
    79a6:	30 f4       	brcc	.+12     	; 0x79b4 <vfprintf+0x160>
    79a8:	21 2f       	mov	r18, r17
    79aa:	06 c0       	rjmp	.+12     	; 0x79b8 <vfprintf+0x164>
    79ac:	27 e0       	ldi	r18, 0x07	; 7
    79ae:	4c e3       	ldi	r20, 0x3C	; 60
    79b0:	44 2e       	mov	r4, r20
    79b2:	03 c0       	rjmp	.+6      	; 0x79ba <vfprintf+0x166>
    79b4:	27 e0       	ldi	r18, 0x07	; 7
    79b6:	17 e0       	ldi	r17, 0x07	; 7
    79b8:	41 2c       	mov	r4, r1
    79ba:	56 01       	movw	r10, r12
    79bc:	74 e0       	ldi	r23, 0x04	; 4
    79be:	a7 0e       	add	r10, r23
    79c0:	b1 1c       	adc	r11, r1
    79c2:	f6 01       	movw	r30, r12
    79c4:	60 81       	ld	r22, Z
    79c6:	71 81       	ldd	r23, Z+1	; 0x01
    79c8:	82 81       	ldd	r24, Z+2	; 0x02
    79ca:	93 81       	ldd	r25, Z+3	; 0x03
    79cc:	04 2d       	mov	r16, r4
    79ce:	a4 01       	movw	r20, r8
    79d0:	87 d3       	rcall	.+1806   	; 0x80e0 <__ftoa_engine>
    79d2:	6c 01       	movw	r12, r24
    79d4:	09 81       	ldd	r16, Y+1	; 0x01
    79d6:	00 ff       	sbrs	r16, 0
    79d8:	02 c0       	rjmp	.+4      	; 0x79de <vfprintf+0x18a>
    79da:	03 ff       	sbrs	r16, 3
    79dc:	06 c0       	rjmp	.+12     	; 0x79ea <vfprintf+0x196>
    79de:	71 fc       	sbrc	r7, 1
    79e0:	07 c0       	rjmp	.+14     	; 0x79f0 <vfprintf+0x19c>
    79e2:	72 fc       	sbrc	r7, 2
    79e4:	08 c0       	rjmp	.+16     	; 0x79f6 <vfprintf+0x1a2>
    79e6:	61 2c       	mov	r6, r1
    79e8:	08 c0       	rjmp	.+16     	; 0x79fa <vfprintf+0x1a6>
    79ea:	3d e2       	ldi	r19, 0x2D	; 45
    79ec:	63 2e       	mov	r6, r19
    79ee:	05 c0       	rjmp	.+10     	; 0x79fa <vfprintf+0x1a6>
    79f0:	2b e2       	ldi	r18, 0x2B	; 43
    79f2:	62 2e       	mov	r6, r18
    79f4:	02 c0       	rjmp	.+4      	; 0x79fa <vfprintf+0x1a6>
    79f6:	90 e2       	ldi	r25, 0x20	; 32
    79f8:	69 2e       	mov	r6, r25
    79fa:	80 2f       	mov	r24, r16
    79fc:	8c 70       	andi	r24, 0x0C	; 12
    79fe:	81 f1       	breq	.+96     	; 0x7a60 <vfprintf+0x20c>
    7a00:	66 20       	and	r6, r6
    7a02:	11 f0       	breq	.+4      	; 0x7a08 <vfprintf+0x1b4>
    7a04:	84 e0       	ldi	r24, 0x04	; 4
    7a06:	01 c0       	rjmp	.+2      	; 0x7a0a <vfprintf+0x1b6>
    7a08:	83 e0       	ldi	r24, 0x03	; 3
    7a0a:	85 15       	cp	r24, r5
    7a0c:	10 f0       	brcs	.+4      	; 0x7a12 <vfprintf+0x1be>
    7a0e:	51 2c       	mov	r5, r1
    7a10:	0a c0       	rjmp	.+20     	; 0x7a26 <vfprintf+0x1d2>
    7a12:	58 1a       	sub	r5, r24
    7a14:	73 fc       	sbrc	r7, 3
    7a16:	07 c0       	rjmp	.+14     	; 0x7a26 <vfprintf+0x1d2>
    7a18:	b7 01       	movw	r22, r14
    7a1a:	80 e2       	ldi	r24, 0x20	; 32
    7a1c:	90 e0       	ldi	r25, 0x00	; 0
    7a1e:	8f d4       	rcall	.+2334   	; 0x833e <fputc>
    7a20:	5a 94       	dec	r5
    7a22:	d1 f7       	brne	.-12     	; 0x7a18 <vfprintf+0x1c4>
    7a24:	f4 cf       	rjmp	.-24     	; 0x7a0e <vfprintf+0x1ba>
    7a26:	66 20       	and	r6, r6
    7a28:	21 f0       	breq	.+8      	; 0x7a32 <vfprintf+0x1de>
    7a2a:	b7 01       	movw	r22, r14
    7a2c:	86 2d       	mov	r24, r6
    7a2e:	90 e0       	ldi	r25, 0x00	; 0
    7a30:	86 d4       	rcall	.+2316   	; 0x833e <fputc>
    7a32:	03 fd       	sbrc	r16, 3
    7a34:	03 c0       	rjmp	.+6      	; 0x7a3c <vfprintf+0x1e8>
    7a36:	04 e9       	ldi	r16, 0x94	; 148
    7a38:	12 e1       	ldi	r17, 0x12	; 18
    7a3a:	02 c0       	rjmp	.+4      	; 0x7a40 <vfprintf+0x1ec>
    7a3c:	00 e9       	ldi	r16, 0x90	; 144
    7a3e:	12 e1       	ldi	r17, 0x12	; 18
    7a40:	f7 2d       	mov	r31, r7
    7a42:	f0 71       	andi	r31, 0x10	; 16
    7a44:	7f 2e       	mov	r7, r31
    7a46:	f8 01       	movw	r30, r16
    7a48:	84 91       	lpm	r24, Z
    7a4a:	88 23       	and	r24, r24
    7a4c:	09 f4       	brne	.+2      	; 0x7a50 <vfprintf+0x1fc>
    7a4e:	5e c2       	rjmp	.+1212   	; 0x7f0c <vfprintf+0x6b8>
    7a50:	71 10       	cpse	r7, r1
    7a52:	80 52       	subi	r24, 0x20	; 32
    7a54:	b7 01       	movw	r22, r14
    7a56:	90 e0       	ldi	r25, 0x00	; 0
    7a58:	72 d4       	rcall	.+2276   	; 0x833e <fputc>
    7a5a:	0f 5f       	subi	r16, 0xFF	; 255
    7a5c:	1f 4f       	sbci	r17, 0xFF	; 255
    7a5e:	f3 cf       	rjmp	.-26     	; 0x7a46 <vfprintf+0x1f2>
    7a60:	77 fe       	sbrs	r7, 7
    7a62:	0f c0       	rjmp	.+30     	; 0x7a82 <vfprintf+0x22e>
    7a64:	4c 0c       	add	r4, r12
    7a66:	04 ff       	sbrs	r16, 4
    7a68:	04 c0       	rjmp	.+8      	; 0x7a72 <vfprintf+0x21e>
    7a6a:	8a 81       	ldd	r24, Y+2	; 0x02
    7a6c:	81 33       	cpi	r24, 0x31	; 49
    7a6e:	09 f4       	brne	.+2      	; 0x7a72 <vfprintf+0x21e>
    7a70:	4a 94       	dec	r4
    7a72:	14 14       	cp	r1, r4
    7a74:	74 f5       	brge	.+92     	; 0x7ad2 <vfprintf+0x27e>
    7a76:	f8 e0       	ldi	r31, 0x08	; 8
    7a78:	f4 15       	cp	r31, r4
    7a7a:	78 f5       	brcc	.+94     	; 0x7ada <vfprintf+0x286>
    7a7c:	88 e0       	ldi	r24, 0x08	; 8
    7a7e:	48 2e       	mov	r4, r24
    7a80:	2c c0       	rjmp	.+88     	; 0x7ada <vfprintf+0x286>
    7a82:	76 fc       	sbrc	r7, 6
    7a84:	2a c0       	rjmp	.+84     	; 0x7ada <vfprintf+0x286>
    7a86:	81 2f       	mov	r24, r17
    7a88:	90 e0       	ldi	r25, 0x00	; 0
    7a8a:	8c 15       	cp	r24, r12
    7a8c:	9d 05       	cpc	r25, r13
    7a8e:	9c f0       	brlt	.+38     	; 0x7ab6 <vfprintf+0x262>
    7a90:	6c ef       	ldi	r22, 0xFC	; 252
    7a92:	c6 16       	cp	r12, r22
    7a94:	6f ef       	ldi	r22, 0xFF	; 255
    7a96:	d6 06       	cpc	r13, r22
    7a98:	74 f0       	brlt	.+28     	; 0x7ab6 <vfprintf+0x262>
    7a9a:	77 2d       	mov	r23, r7
    7a9c:	70 68       	ori	r23, 0x80	; 128
    7a9e:	77 2e       	mov	r7, r23
    7aa0:	0a c0       	rjmp	.+20     	; 0x7ab6 <vfprintf+0x262>
    7aa2:	e2 e0       	ldi	r30, 0x02	; 2
    7aa4:	f0 e0       	ldi	r31, 0x00	; 0
    7aa6:	ec 0f       	add	r30, r28
    7aa8:	fd 1f       	adc	r31, r29
    7aaa:	e1 0f       	add	r30, r17
    7aac:	f1 1d       	adc	r31, r1
    7aae:	80 81       	ld	r24, Z
    7ab0:	80 33       	cpi	r24, 0x30	; 48
    7ab2:	19 f4       	brne	.+6      	; 0x7aba <vfprintf+0x266>
    7ab4:	11 50       	subi	r17, 0x01	; 1
    7ab6:	11 11       	cpse	r17, r1
    7ab8:	f4 cf       	rjmp	.-24     	; 0x7aa2 <vfprintf+0x24e>
    7aba:	77 fe       	sbrs	r7, 7
    7abc:	0e c0       	rjmp	.+28     	; 0x7ada <vfprintf+0x286>
    7abe:	44 24       	eor	r4, r4
    7ac0:	43 94       	inc	r4
    7ac2:	41 0e       	add	r4, r17
    7ac4:	81 2f       	mov	r24, r17
    7ac6:	90 e0       	ldi	r25, 0x00	; 0
    7ac8:	c8 16       	cp	r12, r24
    7aca:	d9 06       	cpc	r13, r25
    7acc:	2c f4       	brge	.+10     	; 0x7ad8 <vfprintf+0x284>
    7ace:	1c 19       	sub	r17, r12
    7ad0:	04 c0       	rjmp	.+8      	; 0x7ada <vfprintf+0x286>
    7ad2:	44 24       	eor	r4, r4
    7ad4:	43 94       	inc	r4
    7ad6:	01 c0       	rjmp	.+2      	; 0x7ada <vfprintf+0x286>
    7ad8:	10 e0       	ldi	r17, 0x00	; 0
    7ada:	77 fe       	sbrs	r7, 7
    7adc:	07 c0       	rjmp	.+14     	; 0x7aec <vfprintf+0x298>
    7ade:	1c 14       	cp	r1, r12
    7ae0:	1d 04       	cpc	r1, r13
    7ae2:	3c f4       	brge	.+14     	; 0x7af2 <vfprintf+0x29e>
    7ae4:	96 01       	movw	r18, r12
    7ae6:	2f 5f       	subi	r18, 0xFF	; 255
    7ae8:	3f 4f       	sbci	r19, 0xFF	; 255
    7aea:	05 c0       	rjmp	.+10     	; 0x7af6 <vfprintf+0x2a2>
    7aec:	25 e0       	ldi	r18, 0x05	; 5
    7aee:	30 e0       	ldi	r19, 0x00	; 0
    7af0:	02 c0       	rjmp	.+4      	; 0x7af6 <vfprintf+0x2a2>
    7af2:	21 e0       	ldi	r18, 0x01	; 1
    7af4:	30 e0       	ldi	r19, 0x00	; 0
    7af6:	66 20       	and	r6, r6
    7af8:	11 f0       	breq	.+4      	; 0x7afe <vfprintf+0x2aa>
    7afa:	2f 5f       	subi	r18, 0xFF	; 255
    7afc:	3f 4f       	sbci	r19, 0xFF	; 255
    7afe:	11 23       	and	r17, r17
    7b00:	31 f0       	breq	.+12     	; 0x7b0e <vfprintf+0x2ba>
    7b02:	41 2f       	mov	r20, r17
    7b04:	50 e0       	ldi	r21, 0x00	; 0
    7b06:	4f 5f       	subi	r20, 0xFF	; 255
    7b08:	5f 4f       	sbci	r21, 0xFF	; 255
    7b0a:	24 0f       	add	r18, r20
    7b0c:	35 1f       	adc	r19, r21
    7b0e:	45 2d       	mov	r20, r5
    7b10:	50 e0       	ldi	r21, 0x00	; 0
    7b12:	24 17       	cp	r18, r20
    7b14:	35 07       	cpc	r19, r21
    7b16:	14 f4       	brge	.+4      	; 0x7b1c <vfprintf+0x2c8>
    7b18:	52 1a       	sub	r5, r18
    7b1a:	01 c0       	rjmp	.+2      	; 0x7b1e <vfprintf+0x2ca>
    7b1c:	51 2c       	mov	r5, r1
    7b1e:	87 2d       	mov	r24, r7
    7b20:	89 70       	andi	r24, 0x09	; 9
    7b22:	41 f4       	brne	.+16     	; 0x7b34 <vfprintf+0x2e0>
    7b24:	55 20       	and	r5, r5
    7b26:	31 f0       	breq	.+12     	; 0x7b34 <vfprintf+0x2e0>
    7b28:	b7 01       	movw	r22, r14
    7b2a:	80 e2       	ldi	r24, 0x20	; 32
    7b2c:	90 e0       	ldi	r25, 0x00	; 0
    7b2e:	07 d4       	rcall	.+2062   	; 0x833e <fputc>
    7b30:	5a 94       	dec	r5
    7b32:	f8 cf       	rjmp	.-16     	; 0x7b24 <vfprintf+0x2d0>
    7b34:	66 20       	and	r6, r6
    7b36:	21 f0       	breq	.+8      	; 0x7b40 <vfprintf+0x2ec>
    7b38:	b7 01       	movw	r22, r14
    7b3a:	86 2d       	mov	r24, r6
    7b3c:	90 e0       	ldi	r25, 0x00	; 0
    7b3e:	ff d3       	rcall	.+2046   	; 0x833e <fputc>
    7b40:	73 fc       	sbrc	r7, 3
    7b42:	08 c0       	rjmp	.+16     	; 0x7b54 <vfprintf+0x300>
    7b44:	55 20       	and	r5, r5
    7b46:	31 f0       	breq	.+12     	; 0x7b54 <vfprintf+0x300>
    7b48:	b7 01       	movw	r22, r14
    7b4a:	80 e3       	ldi	r24, 0x30	; 48
    7b4c:	90 e0       	ldi	r25, 0x00	; 0
    7b4e:	f7 d3       	rcall	.+2030   	; 0x833e <fputc>
    7b50:	5a 94       	dec	r5
    7b52:	f8 cf       	rjmp	.-16     	; 0x7b44 <vfprintf+0x2f0>
    7b54:	77 fe       	sbrs	r7, 7
    7b56:	5d c0       	rjmp	.+186    	; 0x7c12 <vfprintf+0x3be>
    7b58:	9c 2d       	mov	r25, r12
    7b5a:	8d 2d       	mov	r24, r13
    7b5c:	d7 fe       	sbrs	r13, 7
    7b5e:	02 c0       	rjmp	.+4      	; 0x7b64 <vfprintf+0x310>
    7b60:	90 e0       	ldi	r25, 0x00	; 0
    7b62:	80 e0       	ldi	r24, 0x00	; 0
    7b64:	69 2e       	mov	r6, r25
    7b66:	78 2e       	mov	r7, r24
    7b68:	40 e0       	ldi	r20, 0x00	; 0
    7b6a:	50 e0       	ldi	r21, 0x00	; 0
    7b6c:	c6 01       	movw	r24, r12
    7b6e:	84 19       	sub	r24, r4
    7b70:	91 09       	sbc	r25, r1
    7b72:	8c 87       	std	Y+12, r24	; 0x0c
    7b74:	9d 87       	std	Y+13, r25	; 0x0d
    7b76:	96 01       	movw	r18, r12
    7b78:	26 19       	sub	r18, r6
    7b7a:	37 09       	sbc	r19, r7
    7b7c:	28 0d       	add	r18, r8
    7b7e:	39 1d       	adc	r19, r9
    7b80:	81 2f       	mov	r24, r17
    7b82:	90 e0       	ldi	r25, 0x00	; 0
    7b84:	ee 27       	eor	r30, r30
    7b86:	ff 27       	eor	r31, r31
    7b88:	e8 1b       	sub	r30, r24
    7b8a:	f9 0b       	sbc	r31, r25
    7b8c:	ee 87       	std	Y+14, r30	; 0x0e
    7b8e:	ff 87       	std	Y+15, r31	; 0x0f
    7b90:	ff ef       	ldi	r31, 0xFF	; 255
    7b92:	6f 16       	cp	r6, r31
    7b94:	7f 06       	cpc	r7, r31
    7b96:	61 f4       	brne	.+24     	; 0x7bb0 <vfprintf+0x35c>
    7b98:	b7 01       	movw	r22, r14
    7b9a:	8e e2       	ldi	r24, 0x2E	; 46
    7b9c:	90 e0       	ldi	r25, 0x00	; 0
    7b9e:	2b 8b       	std	Y+19, r18	; 0x13
    7ba0:	3a 8b       	std	Y+18, r19	; 0x12
    7ba2:	48 8b       	std	Y+16, r20	; 0x10
    7ba4:	59 8b       	std	Y+17, r21	; 0x11
    7ba6:	cb d3       	rcall	.+1942   	; 0x833e <fputc>
    7ba8:	59 89       	ldd	r21, Y+17	; 0x11
    7baa:	48 89       	ldd	r20, Y+16	; 0x10
    7bac:	3a 89       	ldd	r19, Y+18	; 0x12
    7bae:	2b 89       	ldd	r18, Y+19	; 0x13
    7bb0:	c6 14       	cp	r12, r6
    7bb2:	d7 04       	cpc	r13, r7
    7bb4:	54 f0       	brlt	.+20     	; 0x7bca <vfprintf+0x376>
    7bb6:	6c 85       	ldd	r22, Y+12	; 0x0c
    7bb8:	7d 85       	ldd	r23, Y+13	; 0x0d
    7bba:	66 15       	cp	r22, r6
    7bbc:	77 05       	cpc	r23, r7
    7bbe:	2c f4       	brge	.+10     	; 0x7bca <vfprintf+0x376>
    7bc0:	f9 01       	movw	r30, r18
    7bc2:	e4 0f       	add	r30, r20
    7bc4:	f5 1f       	adc	r31, r21
    7bc6:	81 81       	ldd	r24, Z+1	; 0x01
    7bc8:	01 c0       	rjmp	.+2      	; 0x7bcc <vfprintf+0x378>
    7bca:	80 e3       	ldi	r24, 0x30	; 48
    7bcc:	71 e0       	ldi	r23, 0x01	; 1
    7bce:	67 1a       	sub	r6, r23
    7bd0:	71 08       	sbc	r7, r1
    7bd2:	4f 5f       	subi	r20, 0xFF	; 255
    7bd4:	5f 4f       	sbci	r21, 0xFF	; 255
    7bd6:	ee 85       	ldd	r30, Y+14	; 0x0e
    7bd8:	ff 85       	ldd	r31, Y+15	; 0x0f
    7bda:	6e 16       	cp	r6, r30
    7bdc:	7f 06       	cpc	r7, r31
    7bde:	64 f0       	brlt	.+24     	; 0x7bf8 <vfprintf+0x3a4>
    7be0:	b7 01       	movw	r22, r14
    7be2:	90 e0       	ldi	r25, 0x00	; 0
    7be4:	2b 8b       	std	Y+19, r18	; 0x13
    7be6:	3a 8b       	std	Y+18, r19	; 0x12
    7be8:	48 8b       	std	Y+16, r20	; 0x10
    7bea:	59 8b       	std	Y+17, r21	; 0x11
    7bec:	a8 d3       	rcall	.+1872   	; 0x833e <fputc>
    7bee:	2b 89       	ldd	r18, Y+19	; 0x13
    7bf0:	3a 89       	ldd	r19, Y+18	; 0x12
    7bf2:	48 89       	ldd	r20, Y+16	; 0x10
    7bf4:	59 89       	ldd	r21, Y+17	; 0x11
    7bf6:	cc cf       	rjmp	.-104    	; 0x7b90 <vfprintf+0x33c>
    7bf8:	6c 14       	cp	r6, r12
    7bfa:	7d 04       	cpc	r7, r13
    7bfc:	39 f4       	brne	.+14     	; 0x7c0c <vfprintf+0x3b8>
    7bfe:	9a 81       	ldd	r25, Y+2	; 0x02
    7c00:	96 33       	cpi	r25, 0x36	; 54
    7c02:	18 f4       	brcc	.+6      	; 0x7c0a <vfprintf+0x3b6>
    7c04:	95 33       	cpi	r25, 0x35	; 53
    7c06:	11 f4       	brne	.+4      	; 0x7c0c <vfprintf+0x3b8>
    7c08:	04 ff       	sbrs	r16, 4
    7c0a:	81 e3       	ldi	r24, 0x31	; 49
    7c0c:	b7 01       	movw	r22, r14
    7c0e:	90 e0       	ldi	r25, 0x00	; 0
    7c10:	45 c0       	rjmp	.+138    	; 0x7c9c <vfprintf+0x448>
    7c12:	8a 81       	ldd	r24, Y+2	; 0x02
    7c14:	81 33       	cpi	r24, 0x31	; 49
    7c16:	09 f0       	breq	.+2      	; 0x7c1a <vfprintf+0x3c6>
    7c18:	0f 7e       	andi	r16, 0xEF	; 239
    7c1a:	b7 01       	movw	r22, r14
    7c1c:	90 e0       	ldi	r25, 0x00	; 0
    7c1e:	8f d3       	rcall	.+1822   	; 0x833e <fputc>
    7c20:	11 11       	cpse	r17, r1
    7c22:	05 c0       	rjmp	.+10     	; 0x7c2e <vfprintf+0x3da>
    7c24:	74 fe       	sbrs	r7, 4
    7c26:	16 c0       	rjmp	.+44     	; 0x7c54 <vfprintf+0x400>
    7c28:	85 e4       	ldi	r24, 0x45	; 69
    7c2a:	90 e0       	ldi	r25, 0x00	; 0
    7c2c:	15 c0       	rjmp	.+42     	; 0x7c58 <vfprintf+0x404>
    7c2e:	b7 01       	movw	r22, r14
    7c30:	8e e2       	ldi	r24, 0x2E	; 46
    7c32:	90 e0       	ldi	r25, 0x00	; 0
    7c34:	84 d3       	rcall	.+1800   	; 0x833e <fputc>
    7c36:	82 e0       	ldi	r24, 0x02	; 2
    7c38:	66 24       	eor	r6, r6
    7c3a:	63 94       	inc	r6
    7c3c:	68 0e       	add	r6, r24
    7c3e:	f4 01       	movw	r30, r8
    7c40:	e8 0f       	add	r30, r24
    7c42:	f1 1d       	adc	r31, r1
    7c44:	80 81       	ld	r24, Z
    7c46:	b7 01       	movw	r22, r14
    7c48:	90 e0       	ldi	r25, 0x00	; 0
    7c4a:	79 d3       	rcall	.+1778   	; 0x833e <fputc>
    7c4c:	11 50       	subi	r17, 0x01	; 1
    7c4e:	51 f3       	breq	.-44     	; 0x7c24 <vfprintf+0x3d0>
    7c50:	86 2d       	mov	r24, r6
    7c52:	f2 cf       	rjmp	.-28     	; 0x7c38 <vfprintf+0x3e4>
    7c54:	85 e6       	ldi	r24, 0x65	; 101
    7c56:	90 e0       	ldi	r25, 0x00	; 0
    7c58:	b7 01       	movw	r22, r14
    7c5a:	71 d3       	rcall	.+1762   	; 0x833e <fputc>
    7c5c:	d7 fc       	sbrc	r13, 7
    7c5e:	05 c0       	rjmp	.+10     	; 0x7c6a <vfprintf+0x416>
    7c60:	c1 14       	cp	r12, r1
    7c62:	d1 04       	cpc	r13, r1
    7c64:	39 f4       	brne	.+14     	; 0x7c74 <vfprintf+0x420>
    7c66:	04 ff       	sbrs	r16, 4
    7c68:	05 c0       	rjmp	.+10     	; 0x7c74 <vfprintf+0x420>
    7c6a:	d1 94       	neg	r13
    7c6c:	c1 94       	neg	r12
    7c6e:	d1 08       	sbc	r13, r1
    7c70:	8d e2       	ldi	r24, 0x2D	; 45
    7c72:	01 c0       	rjmp	.+2      	; 0x7c76 <vfprintf+0x422>
    7c74:	8b e2       	ldi	r24, 0x2B	; 43
    7c76:	b7 01       	movw	r22, r14
    7c78:	90 e0       	ldi	r25, 0x00	; 0
    7c7a:	61 d3       	rcall	.+1730   	; 0x833e <fputc>
    7c7c:	80 e3       	ldi	r24, 0x30	; 48
    7c7e:	6a e0       	ldi	r22, 0x0A	; 10
    7c80:	c6 16       	cp	r12, r22
    7c82:	d1 04       	cpc	r13, r1
    7c84:	2c f0       	brlt	.+10     	; 0x7c90 <vfprintf+0x43c>
    7c86:	8f 5f       	subi	r24, 0xFF	; 255
    7c88:	fa e0       	ldi	r31, 0x0A	; 10
    7c8a:	cf 1a       	sub	r12, r31
    7c8c:	d1 08       	sbc	r13, r1
    7c8e:	f7 cf       	rjmp	.-18     	; 0x7c7e <vfprintf+0x42a>
    7c90:	b7 01       	movw	r22, r14
    7c92:	90 e0       	ldi	r25, 0x00	; 0
    7c94:	54 d3       	rcall	.+1704   	; 0x833e <fputc>
    7c96:	b7 01       	movw	r22, r14
    7c98:	c6 01       	movw	r24, r12
    7c9a:	c0 96       	adiw	r24, 0x30	; 48
    7c9c:	50 d3       	rcall	.+1696   	; 0x833e <fputc>
    7c9e:	36 c1       	rjmp	.+620    	; 0x7f0c <vfprintf+0x6b8>
    7ca0:	83 36       	cpi	r24, 0x63	; 99
    7ca2:	31 f0       	breq	.+12     	; 0x7cb0 <vfprintf+0x45c>
    7ca4:	83 37       	cpi	r24, 0x73	; 115
    7ca6:	79 f0       	breq	.+30     	; 0x7cc6 <vfprintf+0x472>
    7ca8:	83 35       	cpi	r24, 0x53	; 83
    7caa:	09 f0       	breq	.+2      	; 0x7cae <vfprintf+0x45a>
    7cac:	54 c0       	rjmp	.+168    	; 0x7d56 <vfprintf+0x502>
    7cae:	20 c0       	rjmp	.+64     	; 0x7cf0 <vfprintf+0x49c>
    7cb0:	56 01       	movw	r10, r12
    7cb2:	72 e0       	ldi	r23, 0x02	; 2
    7cb4:	a7 0e       	add	r10, r23
    7cb6:	b1 1c       	adc	r11, r1
    7cb8:	f6 01       	movw	r30, r12
    7cba:	80 81       	ld	r24, Z
    7cbc:	89 83       	std	Y+1, r24	; 0x01
    7cbe:	01 e0       	ldi	r16, 0x01	; 1
    7cc0:	10 e0       	ldi	r17, 0x00	; 0
    7cc2:	64 01       	movw	r12, r8
    7cc4:	13 c0       	rjmp	.+38     	; 0x7cec <vfprintf+0x498>
    7cc6:	56 01       	movw	r10, r12
    7cc8:	f2 e0       	ldi	r31, 0x02	; 2
    7cca:	af 0e       	add	r10, r31
    7ccc:	b1 1c       	adc	r11, r1
    7cce:	f6 01       	movw	r30, r12
    7cd0:	c0 80       	ld	r12, Z
    7cd2:	d1 80       	ldd	r13, Z+1	; 0x01
    7cd4:	26 ff       	sbrs	r18, 6
    7cd6:	03 c0       	rjmp	.+6      	; 0x7cde <vfprintf+0x48a>
    7cd8:	61 2f       	mov	r22, r17
    7cda:	70 e0       	ldi	r23, 0x00	; 0
    7cdc:	02 c0       	rjmp	.+4      	; 0x7ce2 <vfprintf+0x48e>
    7cde:	6f ef       	ldi	r22, 0xFF	; 255
    7ce0:	7f ef       	ldi	r23, 0xFF	; 255
    7ce2:	c6 01       	movw	r24, r12
    7ce4:	2b 8b       	std	Y+19, r18	; 0x13
    7ce6:	20 d3       	rcall	.+1600   	; 0x8328 <strnlen>
    7ce8:	8c 01       	movw	r16, r24
    7cea:	2b 89       	ldd	r18, Y+19	; 0x13
    7cec:	2f 77       	andi	r18, 0x7F	; 127
    7cee:	14 c0       	rjmp	.+40     	; 0x7d18 <vfprintf+0x4c4>
    7cf0:	56 01       	movw	r10, r12
    7cf2:	f2 e0       	ldi	r31, 0x02	; 2
    7cf4:	af 0e       	add	r10, r31
    7cf6:	b1 1c       	adc	r11, r1
    7cf8:	f6 01       	movw	r30, r12
    7cfa:	c0 80       	ld	r12, Z
    7cfc:	d1 80       	ldd	r13, Z+1	; 0x01
    7cfe:	26 ff       	sbrs	r18, 6
    7d00:	03 c0       	rjmp	.+6      	; 0x7d08 <vfprintf+0x4b4>
    7d02:	61 2f       	mov	r22, r17
    7d04:	70 e0       	ldi	r23, 0x00	; 0
    7d06:	02 c0       	rjmp	.+4      	; 0x7d0c <vfprintf+0x4b8>
    7d08:	6f ef       	ldi	r22, 0xFF	; 255
    7d0a:	7f ef       	ldi	r23, 0xFF	; 255
    7d0c:	c6 01       	movw	r24, r12
    7d0e:	2b 8b       	std	Y+19, r18	; 0x13
    7d10:	bf d2       	rcall	.+1406   	; 0x8290 <strnlen_P>
    7d12:	8c 01       	movw	r16, r24
    7d14:	2b 89       	ldd	r18, Y+19	; 0x13
    7d16:	20 68       	ori	r18, 0x80	; 128
    7d18:	72 2e       	mov	r7, r18
    7d1a:	23 fd       	sbrc	r18, 3
    7d1c:	18 c0       	rjmp	.+48     	; 0x7d4e <vfprintf+0x4fa>
    7d1e:	85 2d       	mov	r24, r5
    7d20:	90 e0       	ldi	r25, 0x00	; 0
    7d22:	08 17       	cp	r16, r24
    7d24:	19 07       	cpc	r17, r25
    7d26:	98 f4       	brcc	.+38     	; 0x7d4e <vfprintf+0x4fa>
    7d28:	b7 01       	movw	r22, r14
    7d2a:	80 e2       	ldi	r24, 0x20	; 32
    7d2c:	90 e0       	ldi	r25, 0x00	; 0
    7d2e:	07 d3       	rcall	.+1550   	; 0x833e <fputc>
    7d30:	5a 94       	dec	r5
    7d32:	f5 cf       	rjmp	.-22     	; 0x7d1e <vfprintf+0x4ca>
    7d34:	f6 01       	movw	r30, r12
    7d36:	77 fc       	sbrc	r7, 7
    7d38:	85 91       	lpm	r24, Z+
    7d3a:	77 fe       	sbrs	r7, 7
    7d3c:	81 91       	ld	r24, Z+
    7d3e:	6f 01       	movw	r12, r30
    7d40:	b7 01       	movw	r22, r14
    7d42:	90 e0       	ldi	r25, 0x00	; 0
    7d44:	fc d2       	rcall	.+1528   	; 0x833e <fputc>
    7d46:	51 10       	cpse	r5, r1
    7d48:	5a 94       	dec	r5
    7d4a:	01 50       	subi	r16, 0x01	; 1
    7d4c:	11 09       	sbc	r17, r1
    7d4e:	01 15       	cp	r16, r1
    7d50:	11 05       	cpc	r17, r1
    7d52:	81 f7       	brne	.-32     	; 0x7d34 <vfprintf+0x4e0>
    7d54:	db c0       	rjmp	.+438    	; 0x7f0c <vfprintf+0x6b8>
    7d56:	84 36       	cpi	r24, 0x64	; 100
    7d58:	11 f0       	breq	.+4      	; 0x7d5e <vfprintf+0x50a>
    7d5a:	89 36       	cpi	r24, 0x69	; 105
    7d5c:	49 f5       	brne	.+82     	; 0x7db0 <vfprintf+0x55c>
    7d5e:	56 01       	movw	r10, r12
    7d60:	27 ff       	sbrs	r18, 7
    7d62:	09 c0       	rjmp	.+18     	; 0x7d76 <vfprintf+0x522>
    7d64:	f4 e0       	ldi	r31, 0x04	; 4
    7d66:	af 0e       	add	r10, r31
    7d68:	b1 1c       	adc	r11, r1
    7d6a:	f6 01       	movw	r30, r12
    7d6c:	60 81       	ld	r22, Z
    7d6e:	71 81       	ldd	r23, Z+1	; 0x01
    7d70:	82 81       	ldd	r24, Z+2	; 0x02
    7d72:	93 81       	ldd	r25, Z+3	; 0x03
    7d74:	0a c0       	rjmp	.+20     	; 0x7d8a <vfprintf+0x536>
    7d76:	f2 e0       	ldi	r31, 0x02	; 2
    7d78:	af 0e       	add	r10, r31
    7d7a:	b1 1c       	adc	r11, r1
    7d7c:	f6 01       	movw	r30, r12
    7d7e:	60 81       	ld	r22, Z
    7d80:	71 81       	ldd	r23, Z+1	; 0x01
    7d82:	88 27       	eor	r24, r24
    7d84:	77 fd       	sbrc	r23, 7
    7d86:	80 95       	com	r24
    7d88:	98 2f       	mov	r25, r24
    7d8a:	02 2f       	mov	r16, r18
    7d8c:	0f 76       	andi	r16, 0x6F	; 111
    7d8e:	97 ff       	sbrs	r25, 7
    7d90:	08 c0       	rjmp	.+16     	; 0x7da2 <vfprintf+0x54e>
    7d92:	90 95       	com	r25
    7d94:	80 95       	com	r24
    7d96:	70 95       	com	r23
    7d98:	61 95       	neg	r22
    7d9a:	7f 4f       	sbci	r23, 0xFF	; 255
    7d9c:	8f 4f       	sbci	r24, 0xFF	; 255
    7d9e:	9f 4f       	sbci	r25, 0xFF	; 255
    7da0:	00 68       	ori	r16, 0x80	; 128
    7da2:	2a e0       	ldi	r18, 0x0A	; 10
    7da4:	30 e0       	ldi	r19, 0x00	; 0
    7da6:	a4 01       	movw	r20, r8
    7da8:	24 d3       	rcall	.+1608   	; 0x83f2 <__ultoa_invert>
    7daa:	c8 2e       	mov	r12, r24
    7dac:	c8 18       	sub	r12, r8
    7dae:	3d c0       	rjmp	.+122    	; 0x7e2a <vfprintf+0x5d6>
    7db0:	02 2f       	mov	r16, r18
    7db2:	85 37       	cpi	r24, 0x75	; 117
    7db4:	21 f4       	brne	.+8      	; 0x7dbe <vfprintf+0x56a>
    7db6:	0f 7e       	andi	r16, 0xEF	; 239
    7db8:	2a e0       	ldi	r18, 0x0A	; 10
    7dba:	30 e0       	ldi	r19, 0x00	; 0
    7dbc:	1d c0       	rjmp	.+58     	; 0x7df8 <vfprintf+0x5a4>
    7dbe:	09 7f       	andi	r16, 0xF9	; 249
    7dc0:	8f 36       	cpi	r24, 0x6F	; 111
    7dc2:	91 f0       	breq	.+36     	; 0x7de8 <vfprintf+0x594>
    7dc4:	18 f4       	brcc	.+6      	; 0x7dcc <vfprintf+0x578>
    7dc6:	88 35       	cpi	r24, 0x58	; 88
    7dc8:	59 f0       	breq	.+22     	; 0x7de0 <vfprintf+0x58c>
    7dca:	a9 c0       	rjmp	.+338    	; 0x7f1e <vfprintf+0x6ca>
    7dcc:	80 37       	cpi	r24, 0x70	; 112
    7dce:	19 f0       	breq	.+6      	; 0x7dd6 <vfprintf+0x582>
    7dd0:	88 37       	cpi	r24, 0x78	; 120
    7dd2:	11 f0       	breq	.+4      	; 0x7dd8 <vfprintf+0x584>
    7dd4:	a4 c0       	rjmp	.+328    	; 0x7f1e <vfprintf+0x6ca>
    7dd6:	00 61       	ori	r16, 0x10	; 16
    7dd8:	04 ff       	sbrs	r16, 4
    7dda:	09 c0       	rjmp	.+18     	; 0x7dee <vfprintf+0x59a>
    7ddc:	04 60       	ori	r16, 0x04	; 4
    7dde:	07 c0       	rjmp	.+14     	; 0x7dee <vfprintf+0x59a>
    7de0:	24 ff       	sbrs	r18, 4
    7de2:	08 c0       	rjmp	.+16     	; 0x7df4 <vfprintf+0x5a0>
    7de4:	06 60       	ori	r16, 0x06	; 6
    7de6:	06 c0       	rjmp	.+12     	; 0x7df4 <vfprintf+0x5a0>
    7de8:	28 e0       	ldi	r18, 0x08	; 8
    7dea:	30 e0       	ldi	r19, 0x00	; 0
    7dec:	05 c0       	rjmp	.+10     	; 0x7df8 <vfprintf+0x5a4>
    7dee:	20 e1       	ldi	r18, 0x10	; 16
    7df0:	30 e0       	ldi	r19, 0x00	; 0
    7df2:	02 c0       	rjmp	.+4      	; 0x7df8 <vfprintf+0x5a4>
    7df4:	20 e1       	ldi	r18, 0x10	; 16
    7df6:	32 e0       	ldi	r19, 0x02	; 2
    7df8:	56 01       	movw	r10, r12
    7dfa:	07 ff       	sbrs	r16, 7
    7dfc:	09 c0       	rjmp	.+18     	; 0x7e10 <vfprintf+0x5bc>
    7dfe:	f4 e0       	ldi	r31, 0x04	; 4
    7e00:	af 0e       	add	r10, r31
    7e02:	b1 1c       	adc	r11, r1
    7e04:	f6 01       	movw	r30, r12
    7e06:	60 81       	ld	r22, Z
    7e08:	71 81       	ldd	r23, Z+1	; 0x01
    7e0a:	82 81       	ldd	r24, Z+2	; 0x02
    7e0c:	93 81       	ldd	r25, Z+3	; 0x03
    7e0e:	08 c0       	rjmp	.+16     	; 0x7e20 <vfprintf+0x5cc>
    7e10:	f2 e0       	ldi	r31, 0x02	; 2
    7e12:	af 0e       	add	r10, r31
    7e14:	b1 1c       	adc	r11, r1
    7e16:	f6 01       	movw	r30, r12
    7e18:	60 81       	ld	r22, Z
    7e1a:	71 81       	ldd	r23, Z+1	; 0x01
    7e1c:	80 e0       	ldi	r24, 0x00	; 0
    7e1e:	90 e0       	ldi	r25, 0x00	; 0
    7e20:	a4 01       	movw	r20, r8
    7e22:	e7 d2       	rcall	.+1486   	; 0x83f2 <__ultoa_invert>
    7e24:	c8 2e       	mov	r12, r24
    7e26:	c8 18       	sub	r12, r8
    7e28:	0f 77       	andi	r16, 0x7F	; 127
    7e2a:	06 ff       	sbrs	r16, 6
    7e2c:	0b c0       	rjmp	.+22     	; 0x7e44 <vfprintf+0x5f0>
    7e2e:	20 2f       	mov	r18, r16
    7e30:	2e 7f       	andi	r18, 0xFE	; 254
    7e32:	c1 16       	cp	r12, r17
    7e34:	50 f4       	brcc	.+20     	; 0x7e4a <vfprintf+0x5f6>
    7e36:	04 ff       	sbrs	r16, 4
    7e38:	0a c0       	rjmp	.+20     	; 0x7e4e <vfprintf+0x5fa>
    7e3a:	02 fd       	sbrc	r16, 2
    7e3c:	08 c0       	rjmp	.+16     	; 0x7e4e <vfprintf+0x5fa>
    7e3e:	20 2f       	mov	r18, r16
    7e40:	2e 7e       	andi	r18, 0xEE	; 238
    7e42:	05 c0       	rjmp	.+10     	; 0x7e4e <vfprintf+0x5fa>
    7e44:	dc 2c       	mov	r13, r12
    7e46:	20 2f       	mov	r18, r16
    7e48:	03 c0       	rjmp	.+6      	; 0x7e50 <vfprintf+0x5fc>
    7e4a:	dc 2c       	mov	r13, r12
    7e4c:	01 c0       	rjmp	.+2      	; 0x7e50 <vfprintf+0x5fc>
    7e4e:	d1 2e       	mov	r13, r17
    7e50:	24 ff       	sbrs	r18, 4
    7e52:	0d c0       	rjmp	.+26     	; 0x7e6e <vfprintf+0x61a>
    7e54:	fe 01       	movw	r30, r28
    7e56:	ec 0d       	add	r30, r12
    7e58:	f1 1d       	adc	r31, r1
    7e5a:	80 81       	ld	r24, Z
    7e5c:	80 33       	cpi	r24, 0x30	; 48
    7e5e:	11 f4       	brne	.+4      	; 0x7e64 <vfprintf+0x610>
    7e60:	29 7e       	andi	r18, 0xE9	; 233
    7e62:	09 c0       	rjmp	.+18     	; 0x7e76 <vfprintf+0x622>
    7e64:	22 ff       	sbrs	r18, 2
    7e66:	06 c0       	rjmp	.+12     	; 0x7e74 <vfprintf+0x620>
    7e68:	d3 94       	inc	r13
    7e6a:	d3 94       	inc	r13
    7e6c:	04 c0       	rjmp	.+8      	; 0x7e76 <vfprintf+0x622>
    7e6e:	82 2f       	mov	r24, r18
    7e70:	86 78       	andi	r24, 0x86	; 134
    7e72:	09 f0       	breq	.+2      	; 0x7e76 <vfprintf+0x622>
    7e74:	d3 94       	inc	r13
    7e76:	23 fd       	sbrc	r18, 3
    7e78:	12 c0       	rjmp	.+36     	; 0x7e9e <vfprintf+0x64a>
    7e7a:	20 ff       	sbrs	r18, 0
    7e7c:	06 c0       	rjmp	.+12     	; 0x7e8a <vfprintf+0x636>
    7e7e:	1c 2d       	mov	r17, r12
    7e80:	d5 14       	cp	r13, r5
    7e82:	18 f4       	brcc	.+6      	; 0x7e8a <vfprintf+0x636>
    7e84:	15 0d       	add	r17, r5
    7e86:	1d 19       	sub	r17, r13
    7e88:	d5 2c       	mov	r13, r5
    7e8a:	d5 14       	cp	r13, r5
    7e8c:	60 f4       	brcc	.+24     	; 0x7ea6 <vfprintf+0x652>
    7e8e:	b7 01       	movw	r22, r14
    7e90:	80 e2       	ldi	r24, 0x20	; 32
    7e92:	90 e0       	ldi	r25, 0x00	; 0
    7e94:	2b 8b       	std	Y+19, r18	; 0x13
    7e96:	53 d2       	rcall	.+1190   	; 0x833e <fputc>
    7e98:	d3 94       	inc	r13
    7e9a:	2b 89       	ldd	r18, Y+19	; 0x13
    7e9c:	f6 cf       	rjmp	.-20     	; 0x7e8a <vfprintf+0x636>
    7e9e:	d5 14       	cp	r13, r5
    7ea0:	10 f4       	brcc	.+4      	; 0x7ea6 <vfprintf+0x652>
    7ea2:	5d 18       	sub	r5, r13
    7ea4:	01 c0       	rjmp	.+2      	; 0x7ea8 <vfprintf+0x654>
    7ea6:	51 2c       	mov	r5, r1
    7ea8:	24 ff       	sbrs	r18, 4
    7eaa:	11 c0       	rjmp	.+34     	; 0x7ece <vfprintf+0x67a>
    7eac:	b7 01       	movw	r22, r14
    7eae:	80 e3       	ldi	r24, 0x30	; 48
    7eb0:	90 e0       	ldi	r25, 0x00	; 0
    7eb2:	2b 8b       	std	Y+19, r18	; 0x13
    7eb4:	44 d2       	rcall	.+1160   	; 0x833e <fputc>
    7eb6:	2b 89       	ldd	r18, Y+19	; 0x13
    7eb8:	22 ff       	sbrs	r18, 2
    7eba:	16 c0       	rjmp	.+44     	; 0x7ee8 <vfprintf+0x694>
    7ebc:	21 ff       	sbrs	r18, 1
    7ebe:	03 c0       	rjmp	.+6      	; 0x7ec6 <vfprintf+0x672>
    7ec0:	88 e5       	ldi	r24, 0x58	; 88
    7ec2:	90 e0       	ldi	r25, 0x00	; 0
    7ec4:	02 c0       	rjmp	.+4      	; 0x7eca <vfprintf+0x676>
    7ec6:	88 e7       	ldi	r24, 0x78	; 120
    7ec8:	90 e0       	ldi	r25, 0x00	; 0
    7eca:	b7 01       	movw	r22, r14
    7ecc:	0c c0       	rjmp	.+24     	; 0x7ee6 <vfprintf+0x692>
    7ece:	82 2f       	mov	r24, r18
    7ed0:	86 78       	andi	r24, 0x86	; 134
    7ed2:	51 f0       	breq	.+20     	; 0x7ee8 <vfprintf+0x694>
    7ed4:	21 fd       	sbrc	r18, 1
    7ed6:	02 c0       	rjmp	.+4      	; 0x7edc <vfprintf+0x688>
    7ed8:	80 e2       	ldi	r24, 0x20	; 32
    7eda:	01 c0       	rjmp	.+2      	; 0x7ede <vfprintf+0x68a>
    7edc:	8b e2       	ldi	r24, 0x2B	; 43
    7ede:	27 fd       	sbrc	r18, 7
    7ee0:	8d e2       	ldi	r24, 0x2D	; 45
    7ee2:	b7 01       	movw	r22, r14
    7ee4:	90 e0       	ldi	r25, 0x00	; 0
    7ee6:	2b d2       	rcall	.+1110   	; 0x833e <fputc>
    7ee8:	c1 16       	cp	r12, r17
    7eea:	30 f4       	brcc	.+12     	; 0x7ef8 <vfprintf+0x6a4>
    7eec:	b7 01       	movw	r22, r14
    7eee:	80 e3       	ldi	r24, 0x30	; 48
    7ef0:	90 e0       	ldi	r25, 0x00	; 0
    7ef2:	25 d2       	rcall	.+1098   	; 0x833e <fputc>
    7ef4:	11 50       	subi	r17, 0x01	; 1
    7ef6:	f8 cf       	rjmp	.-16     	; 0x7ee8 <vfprintf+0x694>
    7ef8:	ca 94       	dec	r12
    7efa:	f4 01       	movw	r30, r8
    7efc:	ec 0d       	add	r30, r12
    7efe:	f1 1d       	adc	r31, r1
    7f00:	80 81       	ld	r24, Z
    7f02:	b7 01       	movw	r22, r14
    7f04:	90 e0       	ldi	r25, 0x00	; 0
    7f06:	1b d2       	rcall	.+1078   	; 0x833e <fputc>
    7f08:	c1 10       	cpse	r12, r1
    7f0a:	f6 cf       	rjmp	.-20     	; 0x7ef8 <vfprintf+0x6a4>
    7f0c:	55 20       	and	r5, r5
    7f0e:	09 f4       	brne	.+2      	; 0x7f12 <vfprintf+0x6be>
    7f10:	dd cc       	rjmp	.-1606   	; 0x78cc <vfprintf+0x78>
    7f12:	b7 01       	movw	r22, r14
    7f14:	80 e2       	ldi	r24, 0x20	; 32
    7f16:	90 e0       	ldi	r25, 0x00	; 0
    7f18:	12 d2       	rcall	.+1060   	; 0x833e <fputc>
    7f1a:	5a 94       	dec	r5
    7f1c:	f7 cf       	rjmp	.-18     	; 0x7f0c <vfprintf+0x6b8>
    7f1e:	f7 01       	movw	r30, r14
    7f20:	86 81       	ldd	r24, Z+6	; 0x06
    7f22:	97 81       	ldd	r25, Z+7	; 0x07
    7f24:	02 c0       	rjmp	.+4      	; 0x7f2a <vfprintf+0x6d6>
    7f26:	8f ef       	ldi	r24, 0xFF	; 255
    7f28:	9f ef       	ldi	r25, 0xFF	; 255
    7f2a:	63 96       	adiw	r28, 0x13	; 19
    7f2c:	cd bf       	out	0x3d, r28	; 61
    7f2e:	de bf       	out	0x3e, r29	; 62
    7f30:	df 91       	pop	r29
    7f32:	cf 91       	pop	r28
    7f34:	1f 91       	pop	r17
    7f36:	0f 91       	pop	r16
    7f38:	ff 90       	pop	r15
    7f3a:	ef 90       	pop	r14
    7f3c:	df 90       	pop	r13
    7f3e:	cf 90       	pop	r12
    7f40:	bf 90       	pop	r11
    7f42:	af 90       	pop	r10
    7f44:	9f 90       	pop	r9
    7f46:	8f 90       	pop	r8
    7f48:	7f 90       	pop	r7
    7f4a:	6f 90       	pop	r6
    7f4c:	5f 90       	pop	r5
    7f4e:	4f 90       	pop	r4
    7f50:	3f 90       	pop	r3
    7f52:	2f 90       	pop	r2
    7f54:	08 95       	ret

00007f56 <__divmodhi4>:
    7f56:	97 fb       	bst	r25, 7
    7f58:	07 2e       	mov	r0, r23
    7f5a:	16 f4       	brtc	.+4      	; 0x7f60 <__divmodhi4+0xa>
    7f5c:	00 94       	com	r0
    7f5e:	06 d0       	rcall	.+12     	; 0x7f6c <__divmodhi4_neg1>
    7f60:	77 fd       	sbrc	r23, 7
    7f62:	08 d0       	rcall	.+16     	; 0x7f74 <__divmodhi4_neg2>
    7f64:	52 d0       	rcall	.+164    	; 0x800a <__udivmodhi4>
    7f66:	07 fc       	sbrc	r0, 7
    7f68:	05 d0       	rcall	.+10     	; 0x7f74 <__divmodhi4_neg2>
    7f6a:	3e f4       	brtc	.+14     	; 0x7f7a <__divmodhi4_exit>

00007f6c <__divmodhi4_neg1>:
    7f6c:	90 95       	com	r25
    7f6e:	81 95       	neg	r24
    7f70:	9f 4f       	sbci	r25, 0xFF	; 255
    7f72:	08 95       	ret

00007f74 <__divmodhi4_neg2>:
    7f74:	70 95       	com	r23
    7f76:	61 95       	neg	r22
    7f78:	7f 4f       	sbci	r23, 0xFF	; 255

00007f7a <__divmodhi4_exit>:
    7f7a:	08 95       	ret

00007f7c <__udivmodsi4>:
    7f7c:	a1 e2       	ldi	r26, 0x21	; 33
    7f7e:	1a 2e       	mov	r1, r26
    7f80:	aa 1b       	sub	r26, r26
    7f82:	bb 1b       	sub	r27, r27
    7f84:	fd 01       	movw	r30, r26
    7f86:	0d c0       	rjmp	.+26     	; 0x7fa2 <__udivmodsi4_ep>

00007f88 <__udivmodsi4_loop>:
    7f88:	aa 1f       	adc	r26, r26
    7f8a:	bb 1f       	adc	r27, r27
    7f8c:	ee 1f       	adc	r30, r30
    7f8e:	ff 1f       	adc	r31, r31
    7f90:	a2 17       	cp	r26, r18
    7f92:	b3 07       	cpc	r27, r19
    7f94:	e4 07       	cpc	r30, r20
    7f96:	f5 07       	cpc	r31, r21
    7f98:	20 f0       	brcs	.+8      	; 0x7fa2 <__udivmodsi4_ep>
    7f9a:	a2 1b       	sub	r26, r18
    7f9c:	b3 0b       	sbc	r27, r19
    7f9e:	e4 0b       	sbc	r30, r20
    7fa0:	f5 0b       	sbc	r31, r21

00007fa2 <__udivmodsi4_ep>:
    7fa2:	66 1f       	adc	r22, r22
    7fa4:	77 1f       	adc	r23, r23
    7fa6:	88 1f       	adc	r24, r24
    7fa8:	99 1f       	adc	r25, r25
    7faa:	1a 94       	dec	r1
    7fac:	69 f7       	brne	.-38     	; 0x7f88 <__udivmodsi4_loop>
    7fae:	60 95       	com	r22
    7fb0:	70 95       	com	r23
    7fb2:	80 95       	com	r24
    7fb4:	90 95       	com	r25
    7fb6:	9b 01       	movw	r18, r22
    7fb8:	ac 01       	movw	r20, r24
    7fba:	bd 01       	movw	r22, r26
    7fbc:	cf 01       	movw	r24, r30
    7fbe:	08 95       	ret

00007fc0 <__tablejump2__>:
    7fc0:	ee 0f       	add	r30, r30
    7fc2:	ff 1f       	adc	r31, r31

00007fc4 <__tablejump__>:
    7fc4:	05 90       	lpm	r0, Z+
    7fc6:	f4 91       	lpm	r31, Z
    7fc8:	e0 2d       	mov	r30, r0
    7fca:	19 94       	eijmp

00007fcc <__umulhisi3>:
    7fcc:	a2 9f       	mul	r26, r18
    7fce:	b0 01       	movw	r22, r0
    7fd0:	b3 9f       	mul	r27, r19
    7fd2:	c0 01       	movw	r24, r0
    7fd4:	a3 9f       	mul	r26, r19
    7fd6:	70 0d       	add	r23, r0
    7fd8:	81 1d       	adc	r24, r1
    7fda:	11 24       	eor	r1, r1
    7fdc:	91 1d       	adc	r25, r1
    7fde:	b2 9f       	mul	r27, r18
    7fe0:	70 0d       	add	r23, r0
    7fe2:	81 1d       	adc	r24, r1
    7fe4:	11 24       	eor	r1, r1
    7fe6:	91 1d       	adc	r25, r1
    7fe8:	08 95       	ret

00007fea <__usmulhisi3>:
    7fea:	f0 df       	rcall	.-32     	; 0x7fcc <__umulhisi3>

00007fec <__usmulhisi3_tail>:
    7fec:	b7 ff       	sbrs	r27, 7
    7fee:	08 95       	ret
    7ff0:	82 1b       	sub	r24, r18
    7ff2:	93 0b       	sbc	r25, r19
    7ff4:	08 95       	ret

00007ff6 <__muluhisi3>:
    7ff6:	ea df       	rcall	.-44     	; 0x7fcc <__umulhisi3>
    7ff8:	a5 9f       	mul	r26, r21
    7ffa:	90 0d       	add	r25, r0
    7ffc:	b4 9f       	mul	r27, r20
    7ffe:	90 0d       	add	r25, r0
    8000:	a4 9f       	mul	r26, r20
    8002:	80 0d       	add	r24, r0
    8004:	91 1d       	adc	r25, r1
    8006:	11 24       	eor	r1, r1
    8008:	08 95       	ret

0000800a <__udivmodhi4>:
    800a:	aa 1b       	sub	r26, r26
    800c:	bb 1b       	sub	r27, r27
    800e:	51 e1       	ldi	r21, 0x11	; 17
    8010:	07 c0       	rjmp	.+14     	; 0x8020 <__udivmodhi4_ep>

00008012 <__udivmodhi4_loop>:
    8012:	aa 1f       	adc	r26, r26
    8014:	bb 1f       	adc	r27, r27
    8016:	a6 17       	cp	r26, r22
    8018:	b7 07       	cpc	r27, r23
    801a:	10 f0       	brcs	.+4      	; 0x8020 <__udivmodhi4_ep>
    801c:	a6 1b       	sub	r26, r22
    801e:	b7 0b       	sbc	r27, r23

00008020 <__udivmodhi4_ep>:
    8020:	88 1f       	adc	r24, r24
    8022:	99 1f       	adc	r25, r25
    8024:	5a 95       	dec	r21
    8026:	a9 f7       	brne	.-22     	; 0x8012 <__udivmodhi4_loop>
    8028:	80 95       	com	r24
    802a:	90 95       	com	r25
    802c:	bc 01       	movw	r22, r24
    802e:	cd 01       	movw	r24, r26
    8030:	08 95       	ret

00008032 <do_rand>:
    8032:	8f 92       	push	r8
    8034:	9f 92       	push	r9
    8036:	af 92       	push	r10
    8038:	bf 92       	push	r11
    803a:	cf 92       	push	r12
    803c:	df 92       	push	r13
    803e:	ef 92       	push	r14
    8040:	ff 92       	push	r15
    8042:	cf 93       	push	r28
    8044:	df 93       	push	r29
    8046:	ec 01       	movw	r28, r24
    8048:	68 81       	ld	r22, Y
    804a:	79 81       	ldd	r23, Y+1	; 0x01
    804c:	8a 81       	ldd	r24, Y+2	; 0x02
    804e:	9b 81       	ldd	r25, Y+3	; 0x03
    8050:	61 15       	cp	r22, r1
    8052:	71 05       	cpc	r23, r1
    8054:	81 05       	cpc	r24, r1
    8056:	91 05       	cpc	r25, r1
    8058:	21 f4       	brne	.+8      	; 0x8062 <do_rand+0x30>
    805a:	64 e2       	ldi	r22, 0x24	; 36
    805c:	79 ed       	ldi	r23, 0xD9	; 217
    805e:	8b e5       	ldi	r24, 0x5B	; 91
    8060:	97 e0       	ldi	r25, 0x07	; 7
    8062:	2d e1       	ldi	r18, 0x1D	; 29
    8064:	33 ef       	ldi	r19, 0xF3	; 243
    8066:	41 e0       	ldi	r20, 0x01	; 1
    8068:	50 e0       	ldi	r21, 0x00	; 0
    806a:	21 d2       	rcall	.+1090   	; 0x84ae <__divmodsi4>
    806c:	49 01       	movw	r8, r18
    806e:	5a 01       	movw	r10, r20
    8070:	9b 01       	movw	r18, r22
    8072:	ac 01       	movw	r20, r24
    8074:	a7 ea       	ldi	r26, 0xA7	; 167
    8076:	b1 e4       	ldi	r27, 0x41	; 65
    8078:	be df       	rcall	.-132    	; 0x7ff6 <__muluhisi3>
    807a:	6b 01       	movw	r12, r22
    807c:	7c 01       	movw	r14, r24
    807e:	ac ee       	ldi	r26, 0xEC	; 236
    8080:	b4 ef       	ldi	r27, 0xF4	; 244
    8082:	a5 01       	movw	r20, r10
    8084:	94 01       	movw	r18, r8
    8086:	31 d2       	rcall	.+1122   	; 0x84ea <__mulohisi3>
    8088:	c6 0e       	add	r12, r22
    808a:	d7 1e       	adc	r13, r23
    808c:	e8 1e       	adc	r14, r24
    808e:	f9 1e       	adc	r15, r25
    8090:	f7 fe       	sbrs	r15, 7
    8092:	06 c0       	rjmp	.+12     	; 0x80a0 <do_rand+0x6e>
    8094:	81 e0       	ldi	r24, 0x01	; 1
    8096:	c8 1a       	sub	r12, r24
    8098:	d1 08       	sbc	r13, r1
    809a:	e1 08       	sbc	r14, r1
    809c:	80 e8       	ldi	r24, 0x80	; 128
    809e:	f8 0a       	sbc	r15, r24
    80a0:	c8 82       	st	Y, r12
    80a2:	d9 82       	std	Y+1, r13	; 0x01
    80a4:	ea 82       	std	Y+2, r14	; 0x02
    80a6:	fb 82       	std	Y+3, r15	; 0x03
    80a8:	c6 01       	movw	r24, r12
    80aa:	9f 77       	andi	r25, 0x7F	; 127
    80ac:	df 91       	pop	r29
    80ae:	cf 91       	pop	r28
    80b0:	ff 90       	pop	r15
    80b2:	ef 90       	pop	r14
    80b4:	df 90       	pop	r13
    80b6:	cf 90       	pop	r12
    80b8:	bf 90       	pop	r11
    80ba:	af 90       	pop	r10
    80bc:	9f 90       	pop	r9
    80be:	8f 90       	pop	r8
    80c0:	08 95       	ret

000080c2 <rand_r>:
    80c2:	b7 cf       	rjmp	.-146    	; 0x8032 <do_rand>

000080c4 <rand>:
    80c4:	80 e0       	ldi	r24, 0x00	; 0
    80c6:	90 e2       	ldi	r25, 0x20	; 32
    80c8:	b4 cf       	rjmp	.-152    	; 0x8032 <do_rand>

000080ca <srand>:
    80ca:	a0 e0       	ldi	r26, 0x00	; 0
    80cc:	b0 e0       	ldi	r27, 0x00	; 0
    80ce:	80 93 00 20 	sts	0x2000, r24
    80d2:	90 93 01 20 	sts	0x2001, r25
    80d6:	a0 93 02 20 	sts	0x2002, r26
    80da:	b0 93 03 20 	sts	0x2003, r27
    80de:	08 95       	ret

000080e0 <__ftoa_engine>:
    80e0:	28 30       	cpi	r18, 0x08	; 8
    80e2:	08 f0       	brcs	.+2      	; 0x80e6 <__ftoa_engine+0x6>
    80e4:	27 e0       	ldi	r18, 0x07	; 7
    80e6:	33 27       	eor	r19, r19
    80e8:	da 01       	movw	r26, r20
    80ea:	99 0f       	add	r25, r25
    80ec:	31 1d       	adc	r19, r1
    80ee:	87 fd       	sbrc	r24, 7
    80f0:	91 60       	ori	r25, 0x01	; 1
    80f2:	00 96       	adiw	r24, 0x00	; 0
    80f4:	61 05       	cpc	r22, r1
    80f6:	71 05       	cpc	r23, r1
    80f8:	39 f4       	brne	.+14     	; 0x8108 <__ftoa_engine+0x28>
    80fa:	32 60       	ori	r19, 0x02	; 2
    80fc:	2e 5f       	subi	r18, 0xFE	; 254
    80fe:	3d 93       	st	X+, r19
    8100:	30 e3       	ldi	r19, 0x30	; 48
    8102:	2a 95       	dec	r18
    8104:	e1 f7       	brne	.-8      	; 0x80fe <__ftoa_engine+0x1e>
    8106:	08 95       	ret
    8108:	9f 3f       	cpi	r25, 0xFF	; 255
    810a:	30 f0       	brcs	.+12     	; 0x8118 <__ftoa_engine+0x38>
    810c:	80 38       	cpi	r24, 0x80	; 128
    810e:	71 05       	cpc	r23, r1
    8110:	61 05       	cpc	r22, r1
    8112:	09 f0       	breq	.+2      	; 0x8116 <__ftoa_engine+0x36>
    8114:	3c 5f       	subi	r19, 0xFC	; 252
    8116:	3c 5f       	subi	r19, 0xFC	; 252
    8118:	3d 93       	st	X+, r19
    811a:	91 30       	cpi	r25, 0x01	; 1
    811c:	08 f0       	brcs	.+2      	; 0x8120 <__ftoa_engine+0x40>
    811e:	80 68       	ori	r24, 0x80	; 128
    8120:	91 1d       	adc	r25, r1
    8122:	df 93       	push	r29
    8124:	cf 93       	push	r28
    8126:	1f 93       	push	r17
    8128:	0f 93       	push	r16
    812a:	ff 92       	push	r15
    812c:	ef 92       	push	r14
    812e:	19 2f       	mov	r17, r25
    8130:	98 7f       	andi	r25, 0xF8	; 248
    8132:	96 95       	lsr	r25
    8134:	e9 2f       	mov	r30, r25
    8136:	96 95       	lsr	r25
    8138:	96 95       	lsr	r25
    813a:	e9 0f       	add	r30, r25
    813c:	ff 27       	eor	r31, r31
    813e:	ee 50       	subi	r30, 0x0E	; 14
    8140:	fd 4e       	sbci	r31, 0xED	; 237
    8142:	99 27       	eor	r25, r25
    8144:	33 27       	eor	r19, r19
    8146:	ee 24       	eor	r14, r14
    8148:	ff 24       	eor	r15, r15
    814a:	a7 01       	movw	r20, r14
    814c:	e7 01       	movw	r28, r14
    814e:	05 90       	lpm	r0, Z+
    8150:	08 94       	sec
    8152:	07 94       	ror	r0
    8154:	28 f4       	brcc	.+10     	; 0x8160 <__ftoa_engine+0x80>
    8156:	36 0f       	add	r19, r22
    8158:	e7 1e       	adc	r14, r23
    815a:	f8 1e       	adc	r15, r24
    815c:	49 1f       	adc	r20, r25
    815e:	51 1d       	adc	r21, r1
    8160:	66 0f       	add	r22, r22
    8162:	77 1f       	adc	r23, r23
    8164:	88 1f       	adc	r24, r24
    8166:	99 1f       	adc	r25, r25
    8168:	06 94       	lsr	r0
    816a:	a1 f7       	brne	.-24     	; 0x8154 <__ftoa_engine+0x74>
    816c:	05 90       	lpm	r0, Z+
    816e:	07 94       	ror	r0
    8170:	28 f4       	brcc	.+10     	; 0x817c <__ftoa_engine+0x9c>
    8172:	e7 0e       	add	r14, r23
    8174:	f8 1e       	adc	r15, r24
    8176:	49 1f       	adc	r20, r25
    8178:	56 1f       	adc	r21, r22
    817a:	c1 1d       	adc	r28, r1
    817c:	77 0f       	add	r23, r23
    817e:	88 1f       	adc	r24, r24
    8180:	99 1f       	adc	r25, r25
    8182:	66 1f       	adc	r22, r22
    8184:	06 94       	lsr	r0
    8186:	a1 f7       	brne	.-24     	; 0x8170 <__ftoa_engine+0x90>
    8188:	05 90       	lpm	r0, Z+
    818a:	07 94       	ror	r0
    818c:	28 f4       	brcc	.+10     	; 0x8198 <__ftoa_engine+0xb8>
    818e:	f8 0e       	add	r15, r24
    8190:	49 1f       	adc	r20, r25
    8192:	56 1f       	adc	r21, r22
    8194:	c7 1f       	adc	r28, r23
    8196:	d1 1d       	adc	r29, r1
    8198:	88 0f       	add	r24, r24
    819a:	99 1f       	adc	r25, r25
    819c:	66 1f       	adc	r22, r22
    819e:	77 1f       	adc	r23, r23
    81a0:	06 94       	lsr	r0
    81a2:	a1 f7       	brne	.-24     	; 0x818c <__ftoa_engine+0xac>
    81a4:	05 90       	lpm	r0, Z+
    81a6:	07 94       	ror	r0
    81a8:	20 f4       	brcc	.+8      	; 0x81b2 <__ftoa_engine+0xd2>
    81aa:	49 0f       	add	r20, r25
    81ac:	56 1f       	adc	r21, r22
    81ae:	c7 1f       	adc	r28, r23
    81b0:	d8 1f       	adc	r29, r24
    81b2:	99 0f       	add	r25, r25
    81b4:	66 1f       	adc	r22, r22
    81b6:	77 1f       	adc	r23, r23
    81b8:	88 1f       	adc	r24, r24
    81ba:	06 94       	lsr	r0
    81bc:	a9 f7       	brne	.-22     	; 0x81a8 <__ftoa_engine+0xc8>
    81be:	84 91       	lpm	r24, Z
    81c0:	10 95       	com	r17
    81c2:	17 70       	andi	r17, 0x07	; 7
    81c4:	41 f0       	breq	.+16     	; 0x81d6 <__ftoa_engine+0xf6>
    81c6:	d6 95       	lsr	r29
    81c8:	c7 95       	ror	r28
    81ca:	57 95       	ror	r21
    81cc:	47 95       	ror	r20
    81ce:	f7 94       	ror	r15
    81d0:	e7 94       	ror	r14
    81d2:	1a 95       	dec	r17
    81d4:	c1 f7       	brne	.-16     	; 0x81c6 <__ftoa_engine+0xe6>
    81d6:	e8 e9       	ldi	r30, 0x98	; 152
    81d8:	f2 e1       	ldi	r31, 0x12	; 18
    81da:	68 94       	set
    81dc:	15 90       	lpm	r1, Z+
    81de:	15 91       	lpm	r17, Z+
    81e0:	35 91       	lpm	r19, Z+
    81e2:	65 91       	lpm	r22, Z+
    81e4:	95 91       	lpm	r25, Z+
    81e6:	05 90       	lpm	r0, Z+
    81e8:	7f e2       	ldi	r23, 0x2F	; 47
    81ea:	73 95       	inc	r23
    81ec:	e1 18       	sub	r14, r1
    81ee:	f1 0a       	sbc	r15, r17
    81f0:	43 0b       	sbc	r20, r19
    81f2:	56 0b       	sbc	r21, r22
    81f4:	c9 0b       	sbc	r28, r25
    81f6:	d0 09       	sbc	r29, r0
    81f8:	c0 f7       	brcc	.-16     	; 0x81ea <__ftoa_engine+0x10a>
    81fa:	e1 0c       	add	r14, r1
    81fc:	f1 1e       	adc	r15, r17
    81fe:	43 1f       	adc	r20, r19
    8200:	56 1f       	adc	r21, r22
    8202:	c9 1f       	adc	r28, r25
    8204:	d0 1d       	adc	r29, r0
    8206:	7e f4       	brtc	.+30     	; 0x8226 <__ftoa_engine+0x146>
    8208:	70 33       	cpi	r23, 0x30	; 48
    820a:	11 f4       	brne	.+4      	; 0x8210 <__ftoa_engine+0x130>
    820c:	8a 95       	dec	r24
    820e:	e6 cf       	rjmp	.-52     	; 0x81dc <__ftoa_engine+0xfc>
    8210:	e8 94       	clt
    8212:	01 50       	subi	r16, 0x01	; 1
    8214:	30 f0       	brcs	.+12     	; 0x8222 <__ftoa_engine+0x142>
    8216:	08 0f       	add	r16, r24
    8218:	0a f4       	brpl	.+2      	; 0x821c <__ftoa_engine+0x13c>
    821a:	00 27       	eor	r16, r16
    821c:	02 17       	cp	r16, r18
    821e:	08 f4       	brcc	.+2      	; 0x8222 <__ftoa_engine+0x142>
    8220:	20 2f       	mov	r18, r16
    8222:	23 95       	inc	r18
    8224:	02 2f       	mov	r16, r18
    8226:	7a 33       	cpi	r23, 0x3A	; 58
    8228:	28 f0       	brcs	.+10     	; 0x8234 <__ftoa_engine+0x154>
    822a:	79 e3       	ldi	r23, 0x39	; 57
    822c:	7d 93       	st	X+, r23
    822e:	2a 95       	dec	r18
    8230:	e9 f7       	brne	.-6      	; 0x822c <__ftoa_engine+0x14c>
    8232:	10 c0       	rjmp	.+32     	; 0x8254 <__ftoa_engine+0x174>
    8234:	7d 93       	st	X+, r23
    8236:	2a 95       	dec	r18
    8238:	89 f6       	brne	.-94     	; 0x81dc <__ftoa_engine+0xfc>
    823a:	06 94       	lsr	r0
    823c:	97 95       	ror	r25
    823e:	67 95       	ror	r22
    8240:	37 95       	ror	r19
    8242:	17 95       	ror	r17
    8244:	17 94       	ror	r1
    8246:	e1 18       	sub	r14, r1
    8248:	f1 0a       	sbc	r15, r17
    824a:	43 0b       	sbc	r20, r19
    824c:	56 0b       	sbc	r21, r22
    824e:	c9 0b       	sbc	r28, r25
    8250:	d0 09       	sbc	r29, r0
    8252:	98 f0       	brcs	.+38     	; 0x827a <__ftoa_engine+0x19a>
    8254:	23 95       	inc	r18
    8256:	7e 91       	ld	r23, -X
    8258:	73 95       	inc	r23
    825a:	7a 33       	cpi	r23, 0x3A	; 58
    825c:	08 f0       	brcs	.+2      	; 0x8260 <__ftoa_engine+0x180>
    825e:	70 e3       	ldi	r23, 0x30	; 48
    8260:	7c 93       	st	X, r23
    8262:	20 13       	cpse	r18, r16
    8264:	b8 f7       	brcc	.-18     	; 0x8254 <__ftoa_engine+0x174>
    8266:	7e 91       	ld	r23, -X
    8268:	70 61       	ori	r23, 0x10	; 16
    826a:	7d 93       	st	X+, r23
    826c:	30 f0       	brcs	.+12     	; 0x827a <__ftoa_engine+0x19a>
    826e:	83 95       	inc	r24
    8270:	71 e3       	ldi	r23, 0x31	; 49
    8272:	7d 93       	st	X+, r23
    8274:	70 e3       	ldi	r23, 0x30	; 48
    8276:	2a 95       	dec	r18
    8278:	e1 f7       	brne	.-8      	; 0x8272 <__ftoa_engine+0x192>
    827a:	11 24       	eor	r1, r1
    827c:	ef 90       	pop	r14
    827e:	ff 90       	pop	r15
    8280:	0f 91       	pop	r16
    8282:	1f 91       	pop	r17
    8284:	cf 91       	pop	r28
    8286:	df 91       	pop	r29
    8288:	99 27       	eor	r25, r25
    828a:	87 fd       	sbrc	r24, 7
    828c:	90 95       	com	r25
    828e:	08 95       	ret

00008290 <strnlen_P>:
    8290:	fc 01       	movw	r30, r24
    8292:	05 90       	lpm	r0, Z+
    8294:	61 50       	subi	r22, 0x01	; 1
    8296:	70 40       	sbci	r23, 0x00	; 0
    8298:	01 10       	cpse	r0, r1
    829a:	d8 f7       	brcc	.-10     	; 0x8292 <strnlen_P+0x2>
    829c:	80 95       	com	r24
    829e:	90 95       	com	r25
    82a0:	8e 0f       	add	r24, r30
    82a2:	9f 1f       	adc	r25, r31
    82a4:	08 95       	ret

000082a6 <memcmp>:
    82a6:	fb 01       	movw	r30, r22
    82a8:	dc 01       	movw	r26, r24
    82aa:	04 c0       	rjmp	.+8      	; 0x82b4 <memcmp+0xe>
    82ac:	8d 91       	ld	r24, X+
    82ae:	01 90       	ld	r0, Z+
    82b0:	80 19       	sub	r24, r0
    82b2:	21 f4       	brne	.+8      	; 0x82bc <memcmp+0x16>
    82b4:	41 50       	subi	r20, 0x01	; 1
    82b6:	50 40       	sbci	r21, 0x00	; 0
    82b8:	c8 f7       	brcc	.-14     	; 0x82ac <memcmp+0x6>
    82ba:	88 1b       	sub	r24, r24
    82bc:	99 0b       	sbc	r25, r25
    82be:	08 95       	ret

000082c0 <memcpy>:
    82c0:	fb 01       	movw	r30, r22
    82c2:	dc 01       	movw	r26, r24
    82c4:	02 c0       	rjmp	.+4      	; 0x82ca <memcpy+0xa>
    82c6:	01 90       	ld	r0, Z+
    82c8:	0d 92       	st	X+, r0
    82ca:	41 50       	subi	r20, 0x01	; 1
    82cc:	50 40       	sbci	r21, 0x00	; 0
    82ce:	d8 f7       	brcc	.-10     	; 0x82c6 <memcpy+0x6>
    82d0:	08 95       	ret

000082d2 <memset>:
    82d2:	dc 01       	movw	r26, r24
    82d4:	01 c0       	rjmp	.+2      	; 0x82d8 <memset+0x6>
    82d6:	6d 93       	st	X+, r22
    82d8:	41 50       	subi	r20, 0x01	; 1
    82da:	50 40       	sbci	r21, 0x00	; 0
    82dc:	e0 f7       	brcc	.-8      	; 0x82d6 <memset+0x4>
    82de:	08 95       	ret

000082e0 <strcpy>:
    82e0:	fb 01       	movw	r30, r22
    82e2:	dc 01       	movw	r26, r24
    82e4:	01 90       	ld	r0, Z+
    82e6:	0d 92       	st	X+, r0
    82e8:	00 20       	and	r0, r0
    82ea:	e1 f7       	brne	.-8      	; 0x82e4 <strcpy+0x4>
    82ec:	08 95       	ret

000082ee <strncmp>:
    82ee:	fb 01       	movw	r30, r22
    82f0:	dc 01       	movw	r26, r24
    82f2:	41 50       	subi	r20, 0x01	; 1
    82f4:	50 40       	sbci	r21, 0x00	; 0
    82f6:	30 f0       	brcs	.+12     	; 0x8304 <strncmp+0x16>
    82f8:	8d 91       	ld	r24, X+
    82fa:	01 90       	ld	r0, Z+
    82fc:	80 19       	sub	r24, r0
    82fe:	19 f4       	brne	.+6      	; 0x8306 <strncmp+0x18>
    8300:	00 20       	and	r0, r0
    8302:	b9 f7       	brne	.-18     	; 0x82f2 <strncmp+0x4>
    8304:	88 1b       	sub	r24, r24
    8306:	99 0b       	sbc	r25, r25
    8308:	08 95       	ret

0000830a <strncpy>:
    830a:	fb 01       	movw	r30, r22
    830c:	dc 01       	movw	r26, r24
    830e:	41 50       	subi	r20, 0x01	; 1
    8310:	50 40       	sbci	r21, 0x00	; 0
    8312:	48 f0       	brcs	.+18     	; 0x8326 <strncpy+0x1c>
    8314:	01 90       	ld	r0, Z+
    8316:	0d 92       	st	X+, r0
    8318:	00 20       	and	r0, r0
    831a:	c9 f7       	brne	.-14     	; 0x830e <strncpy+0x4>
    831c:	01 c0       	rjmp	.+2      	; 0x8320 <strncpy+0x16>
    831e:	1d 92       	st	X+, r1
    8320:	41 50       	subi	r20, 0x01	; 1
    8322:	50 40       	sbci	r21, 0x00	; 0
    8324:	e0 f7       	brcc	.-8      	; 0x831e <strncpy+0x14>
    8326:	08 95       	ret

00008328 <strnlen>:
    8328:	fc 01       	movw	r30, r24
    832a:	61 50       	subi	r22, 0x01	; 1
    832c:	70 40       	sbci	r23, 0x00	; 0
    832e:	01 90       	ld	r0, Z+
    8330:	01 10       	cpse	r0, r1
    8332:	d8 f7       	brcc	.-10     	; 0x832a <strnlen+0x2>
    8334:	80 95       	com	r24
    8336:	90 95       	com	r25
    8338:	8e 0f       	add	r24, r30
    833a:	9f 1f       	adc	r25, r31
    833c:	08 95       	ret

0000833e <fputc>:
    833e:	0f 93       	push	r16
    8340:	1f 93       	push	r17
    8342:	cf 93       	push	r28
    8344:	df 93       	push	r29
    8346:	18 2f       	mov	r17, r24
    8348:	09 2f       	mov	r16, r25
    834a:	eb 01       	movw	r28, r22
    834c:	8b 81       	ldd	r24, Y+3	; 0x03
    834e:	81 fd       	sbrc	r24, 1
    8350:	03 c0       	rjmp	.+6      	; 0x8358 <fputc+0x1a>
    8352:	8f ef       	ldi	r24, 0xFF	; 255
    8354:	9f ef       	ldi	r25, 0xFF	; 255
    8356:	20 c0       	rjmp	.+64     	; 0x8398 <fputc+0x5a>
    8358:	82 ff       	sbrs	r24, 2
    835a:	10 c0       	rjmp	.+32     	; 0x837c <fputc+0x3e>
    835c:	4e 81       	ldd	r20, Y+6	; 0x06
    835e:	5f 81       	ldd	r21, Y+7	; 0x07
    8360:	2c 81       	ldd	r18, Y+4	; 0x04
    8362:	3d 81       	ldd	r19, Y+5	; 0x05
    8364:	42 17       	cp	r20, r18
    8366:	53 07       	cpc	r21, r19
    8368:	7c f4       	brge	.+30     	; 0x8388 <fputc+0x4a>
    836a:	e8 81       	ld	r30, Y
    836c:	f9 81       	ldd	r31, Y+1	; 0x01
    836e:	9f 01       	movw	r18, r30
    8370:	2f 5f       	subi	r18, 0xFF	; 255
    8372:	3f 4f       	sbci	r19, 0xFF	; 255
    8374:	28 83       	st	Y, r18
    8376:	39 83       	std	Y+1, r19	; 0x01
    8378:	10 83       	st	Z, r17
    837a:	06 c0       	rjmp	.+12     	; 0x8388 <fputc+0x4a>
    837c:	e8 85       	ldd	r30, Y+8	; 0x08
    837e:	f9 85       	ldd	r31, Y+9	; 0x09
    8380:	81 2f       	mov	r24, r17
    8382:	19 95       	eicall
    8384:	89 2b       	or	r24, r25
    8386:	29 f7       	brne	.-54     	; 0x8352 <fputc+0x14>
    8388:	2e 81       	ldd	r18, Y+6	; 0x06
    838a:	3f 81       	ldd	r19, Y+7	; 0x07
    838c:	2f 5f       	subi	r18, 0xFF	; 255
    838e:	3f 4f       	sbci	r19, 0xFF	; 255
    8390:	2e 83       	std	Y+6, r18	; 0x06
    8392:	3f 83       	std	Y+7, r19	; 0x07
    8394:	81 2f       	mov	r24, r17
    8396:	90 2f       	mov	r25, r16
    8398:	df 91       	pop	r29
    839a:	cf 91       	pop	r28
    839c:	1f 91       	pop	r17
    839e:	0f 91       	pop	r16
    83a0:	08 95       	ret

000083a2 <sprintf>:
    83a2:	0f 93       	push	r16
    83a4:	1f 93       	push	r17
    83a6:	cf 93       	push	r28
    83a8:	df 93       	push	r29
    83aa:	cd b7       	in	r28, 0x3d	; 61
    83ac:	de b7       	in	r29, 0x3e	; 62
    83ae:	2e 97       	sbiw	r28, 0x0e	; 14
    83b0:	cd bf       	out	0x3d, r28	; 61
    83b2:	de bf       	out	0x3e, r29	; 62
    83b4:	0e 89       	ldd	r16, Y+22	; 0x16
    83b6:	1f 89       	ldd	r17, Y+23	; 0x17
    83b8:	86 e0       	ldi	r24, 0x06	; 6
    83ba:	8c 83       	std	Y+4, r24	; 0x04
    83bc:	09 83       	std	Y+1, r16	; 0x01
    83be:	1a 83       	std	Y+2, r17	; 0x02
    83c0:	8f ef       	ldi	r24, 0xFF	; 255
    83c2:	9f e7       	ldi	r25, 0x7F	; 127
    83c4:	8d 83       	std	Y+5, r24	; 0x05
    83c6:	9e 83       	std	Y+6, r25	; 0x06
    83c8:	ae 01       	movw	r20, r28
    83ca:	46 5e       	subi	r20, 0xE6	; 230
    83cc:	5f 4f       	sbci	r21, 0xFF	; 255
    83ce:	68 8d       	ldd	r22, Y+24	; 0x18
    83d0:	79 8d       	ldd	r23, Y+25	; 0x19
    83d2:	ce 01       	movw	r24, r28
    83d4:	01 96       	adiw	r24, 0x01	; 1
    83d6:	3e da       	rcall	.-2948   	; 0x7854 <vfprintf>
    83d8:	ef 81       	ldd	r30, Y+7	; 0x07
    83da:	f8 85       	ldd	r31, Y+8	; 0x08
    83dc:	e0 0f       	add	r30, r16
    83de:	f1 1f       	adc	r31, r17
    83e0:	10 82       	st	Z, r1
    83e2:	2e 96       	adiw	r28, 0x0e	; 14
    83e4:	cd bf       	out	0x3d, r28	; 61
    83e6:	de bf       	out	0x3e, r29	; 62
    83e8:	df 91       	pop	r29
    83ea:	cf 91       	pop	r28
    83ec:	1f 91       	pop	r17
    83ee:	0f 91       	pop	r16
    83f0:	08 95       	ret

000083f2 <__ultoa_invert>:
    83f2:	fa 01       	movw	r30, r20
    83f4:	aa 27       	eor	r26, r26
    83f6:	28 30       	cpi	r18, 0x08	; 8
    83f8:	51 f1       	breq	.+84     	; 0x844e <__ultoa_invert+0x5c>
    83fa:	20 31       	cpi	r18, 0x10	; 16
    83fc:	81 f1       	breq	.+96     	; 0x845e <__ultoa_invert+0x6c>
    83fe:	e8 94       	clt
    8400:	6f 93       	push	r22
    8402:	6e 7f       	andi	r22, 0xFE	; 254
    8404:	6e 5f       	subi	r22, 0xFE	; 254
    8406:	7f 4f       	sbci	r23, 0xFF	; 255
    8408:	8f 4f       	sbci	r24, 0xFF	; 255
    840a:	9f 4f       	sbci	r25, 0xFF	; 255
    840c:	af 4f       	sbci	r26, 0xFF	; 255
    840e:	b1 e0       	ldi	r27, 0x01	; 1
    8410:	3e d0       	rcall	.+124    	; 0x848e <__ultoa_invert+0x9c>
    8412:	b4 e0       	ldi	r27, 0x04	; 4
    8414:	3c d0       	rcall	.+120    	; 0x848e <__ultoa_invert+0x9c>
    8416:	67 0f       	add	r22, r23
    8418:	78 1f       	adc	r23, r24
    841a:	89 1f       	adc	r24, r25
    841c:	9a 1f       	adc	r25, r26
    841e:	a1 1d       	adc	r26, r1
    8420:	68 0f       	add	r22, r24
    8422:	79 1f       	adc	r23, r25
    8424:	8a 1f       	adc	r24, r26
    8426:	91 1d       	adc	r25, r1
    8428:	a1 1d       	adc	r26, r1
    842a:	6a 0f       	add	r22, r26
    842c:	71 1d       	adc	r23, r1
    842e:	81 1d       	adc	r24, r1
    8430:	91 1d       	adc	r25, r1
    8432:	a1 1d       	adc	r26, r1
    8434:	20 d0       	rcall	.+64     	; 0x8476 <__ultoa_invert+0x84>
    8436:	09 f4       	brne	.+2      	; 0x843a <__ultoa_invert+0x48>
    8438:	68 94       	set
    843a:	3f 91       	pop	r19
    843c:	2a e0       	ldi	r18, 0x0A	; 10
    843e:	26 9f       	mul	r18, r22
    8440:	11 24       	eor	r1, r1
    8442:	30 19       	sub	r19, r0
    8444:	30 5d       	subi	r19, 0xD0	; 208
    8446:	31 93       	st	Z+, r19
    8448:	de f6       	brtc	.-74     	; 0x8400 <__ultoa_invert+0xe>
    844a:	cf 01       	movw	r24, r30
    844c:	08 95       	ret
    844e:	46 2f       	mov	r20, r22
    8450:	47 70       	andi	r20, 0x07	; 7
    8452:	40 5d       	subi	r20, 0xD0	; 208
    8454:	41 93       	st	Z+, r20
    8456:	b3 e0       	ldi	r27, 0x03	; 3
    8458:	0f d0       	rcall	.+30     	; 0x8478 <__ultoa_invert+0x86>
    845a:	c9 f7       	brne	.-14     	; 0x844e <__ultoa_invert+0x5c>
    845c:	f6 cf       	rjmp	.-20     	; 0x844a <__ultoa_invert+0x58>
    845e:	46 2f       	mov	r20, r22
    8460:	4f 70       	andi	r20, 0x0F	; 15
    8462:	40 5d       	subi	r20, 0xD0	; 208
    8464:	4a 33       	cpi	r20, 0x3A	; 58
    8466:	18 f0       	brcs	.+6      	; 0x846e <__ultoa_invert+0x7c>
    8468:	49 5d       	subi	r20, 0xD9	; 217
    846a:	31 fd       	sbrc	r19, 1
    846c:	40 52       	subi	r20, 0x20	; 32
    846e:	41 93       	st	Z+, r20
    8470:	02 d0       	rcall	.+4      	; 0x8476 <__ultoa_invert+0x84>
    8472:	a9 f7       	brne	.-22     	; 0x845e <__ultoa_invert+0x6c>
    8474:	ea cf       	rjmp	.-44     	; 0x844a <__ultoa_invert+0x58>
    8476:	b4 e0       	ldi	r27, 0x04	; 4
    8478:	a6 95       	lsr	r26
    847a:	97 95       	ror	r25
    847c:	87 95       	ror	r24
    847e:	77 95       	ror	r23
    8480:	67 95       	ror	r22
    8482:	ba 95       	dec	r27
    8484:	c9 f7       	brne	.-14     	; 0x8478 <__ultoa_invert+0x86>
    8486:	00 97       	sbiw	r24, 0x00	; 0
    8488:	61 05       	cpc	r22, r1
    848a:	71 05       	cpc	r23, r1
    848c:	08 95       	ret
    848e:	9b 01       	movw	r18, r22
    8490:	ac 01       	movw	r20, r24
    8492:	0a 2e       	mov	r0, r26
    8494:	06 94       	lsr	r0
    8496:	57 95       	ror	r21
    8498:	47 95       	ror	r20
    849a:	37 95       	ror	r19
    849c:	27 95       	ror	r18
    849e:	ba 95       	dec	r27
    84a0:	c9 f7       	brne	.-14     	; 0x8494 <__ultoa_invert+0xa2>
    84a2:	62 0f       	add	r22, r18
    84a4:	73 1f       	adc	r23, r19
    84a6:	84 1f       	adc	r24, r20
    84a8:	95 1f       	adc	r25, r21
    84aa:	a0 1d       	adc	r26, r0
    84ac:	08 95       	ret

000084ae <__divmodsi4>:
    84ae:	05 2e       	mov	r0, r21
    84b0:	97 fb       	bst	r25, 7
    84b2:	16 f4       	brtc	.+4      	; 0x84b8 <__divmodsi4+0xa>
    84b4:	00 94       	com	r0
    84b6:	0f d0       	rcall	.+30     	; 0x84d6 <__negsi2>
    84b8:	57 fd       	sbrc	r21, 7
    84ba:	05 d0       	rcall	.+10     	; 0x84c6 <__divmodsi4_neg2>
    84bc:	5f dd       	rcall	.-1346   	; 0x7f7c <__udivmodsi4>
    84be:	07 fc       	sbrc	r0, 7
    84c0:	02 d0       	rcall	.+4      	; 0x84c6 <__divmodsi4_neg2>
    84c2:	46 f4       	brtc	.+16     	; 0x84d4 <__divmodsi4_exit>
    84c4:	08 c0       	rjmp	.+16     	; 0x84d6 <__negsi2>

000084c6 <__divmodsi4_neg2>:
    84c6:	50 95       	com	r21
    84c8:	40 95       	com	r20
    84ca:	30 95       	com	r19
    84cc:	21 95       	neg	r18
    84ce:	3f 4f       	sbci	r19, 0xFF	; 255
    84d0:	4f 4f       	sbci	r20, 0xFF	; 255
    84d2:	5f 4f       	sbci	r21, 0xFF	; 255

000084d4 <__divmodsi4_exit>:
    84d4:	08 95       	ret

000084d6 <__negsi2>:
    84d6:	90 95       	com	r25
    84d8:	80 95       	com	r24
    84da:	70 95       	com	r23
    84dc:	61 95       	neg	r22
    84de:	7f 4f       	sbci	r23, 0xFF	; 255
    84e0:	8f 4f       	sbci	r24, 0xFF	; 255
    84e2:	9f 4f       	sbci	r25, 0xFF	; 255
    84e4:	08 95       	ret

000084e6 <__mulshisi3>:
    84e6:	b7 ff       	sbrs	r27, 7
    84e8:	86 cd       	rjmp	.-1268   	; 0x7ff6 <__muluhisi3>

000084ea <__mulohisi3>:
    84ea:	85 dd       	rcall	.-1270   	; 0x7ff6 <__muluhisi3>
    84ec:	82 1b       	sub	r24, r18
    84ee:	93 0b       	sbc	r25, r19
    84f0:	08 95       	ret

000084f2 <_exit>:
    84f2:	f8 94       	cli

000084f4 <__stop_program>:
    84f4:	ff cf       	rjmp	.-2      	; 0x84f4 <__stop_program>
